var tipuesearch = {"pages":[{"text":"wavy wavy A spectral ocean wave modeling framework. Getting started Building wavy Building a simple program with wavy Examples Design principles Features Development status Getting started Building wavy git clone --recursive https://github.com/wavebitscientific/wavy.git\nFC=gfortran make\nmkdir build\ncd build\nFC=gfortran cmake ..\nmake\nctest Change the FC value if building with a different Fortran compiler. By default, wavy will be built in single precision (32-bit reals).\nTo build it in double (64-bit reals) or quadruple precision (128-bit reals),\nuse the -DREAL argument when invoking cmake : FC=gfortran cmake .. -DREAL=64 # for double precision or: FC=gfortran cmake .. -DREAL=128 # for quad precision wavy needs gcc-6.3.0 or later to succesfully build and pass all tests. Building a simple program with wavy If you compiled wavy in wavy/build , then the module files and the library\nare located in wavy/build/include and wavy/build/lib , respectively. \nFor example, if we want to build a simple wavy hello world program from\nthe base directory, we could do it like this: gfortran hello.f90 -o hello -Ibuild/include -Lbuild/lib -lwavy Examples Initialize a omnidirectional spectrum instance in the frequency range from \n0.04 to 2 Hz with logarithmic increment of 1.1, in mean water depth of 1000 m: use mod_spectrum , only : spectrum_type type ( spectrum_type ) :: spec ! initialize a spectrum instance spec = spectrum_type ( fmin = 0.04 , fmax = 2. , df = 1.1 , ndirs = 1 , depth = 100 0. ) Same as above, but directional spectrum with 36 directional bins: spec = spectrum_type ( fmin = 0.04 , fmax = 2. , df = 1.1 , ndirs = 36 , depth = 100 0. ) Initialize omnidirectional spectrum with JONSWAP shape at wind speed of 10 m/s,\nand fetch of 100 km: use mod_spectrum , only : spectrum_type use mod_spectral_shapes , only : jonswap type ( spectrum_type ) :: spec ! initialize a spectrum instance spec = spectrum_type ( fmin = 0.04 , fmax = 2. , df = 1.1 , ndirs = 1 , depth = 100 0. ) ! assign a JONSWAP-shape spectrum to the instance spec = jonswap ( spec % getFrequency (), wspd = 1 0. , fetch = 1 e5 , grav = 9.8 ) Above examples will work with default precision ( REAL32 ). \nTo write code that is always compatible with precision specified at \nbuild time, use mod_precision module: use mod_precision , only : rk => realkind use mod_spectrum , only : spectrum_type use mod_spectral_shapes , only : jonswap type ( spectrum_type ) :: spec ! initialize a spectrum instance spec = spectrum_type ( fmin = 0.04_rk , fmax = 2._rk , df = 1.1_rk , ndirs = 1 , depth = 100 0._rk ) ! assign a JONSWAP-shape spectrum to the instance spec = jonswap ( spec % getFrequency (), wspd = 1 0._rk , fetch = 1 e5_rk , grav = 9.8_rk ) There are many pre-built diagnostics that can be output from a spectrum instance, here is a taste of a few: write ( * , * ) 'Significant wave height [m]: ' , spec % significantWaveHeight () write ( * , * ) '       Mean wave period [s]: ' , spec % meanPeriod () write ( * , * ) '      Mean square slope [-]: ' , spec % meanSquareSlope () write ( * , * ) '         Stokes drift [m/s]: ' , spec % stokesDrift ([ 0._rk ]) outputs: Significant wave height [m]:    2.13949418    \n        Mean wave period [s]:    5.20506239    \n       Mean square slope [-]:    2.39831898E-02\n          Stokes drift [m/s]:    4.87080999E-02 Design principles Pure Fortran goodness Object-oriented for high-level abstractions, functional for the computational kernels Framework to contruct arbitrary wave models Provides a rich set of source functions, parametric shapes, numerical schemes, and wave diagnostics Easy to use by existing atmosphere and ocean models Supports single (32-bit), double (64-bit), and quadruple (128-bit)  precision floating point arithmetic Self-documented Fully unit-tested Features Classes: [x] Spectrum class: supports omnidirectional and directional spectra [x] Grid class: supports regular 1-d and 2-d grids [x] Domain class: built from Grid and Spectrum instances. Source functions: [x] Sin, Sds, Sdt, Snl, Sbf (Donelan et al., 2012) [ ] Sin, Sds, WAM cycle 3 (Komen et al., 1984) [ ] Sin, Sds (Tolman and Chalikov, 1996) [ ] Sin, Sds, WAM cycle 4 (Janssen, 2004) [ ] Sin, Sds, (Ardhuin et al., 2010) [ ] Snl (Donelan et al., 2012) [ ] Snl, DIA (Hasselmann et al., 1985) Parametric spectra: [x] Donelan, Hamilton & Hui (1985) [x] JONSWAP (1973) [x] Phillips (1956) [x] Pierson-Moskowitz (1964) Grid projections: [x] Cartesian [ ] Spherical Time integration scheme: [x] First order, forward Euler (explicit) [x] First order, backward Euler (implicit) [x] Exact exponential Advection schemes: [x] Upwind differences, 1st order, 1-d [x] Upwind differences, 1st order, 2-d [x] Upwind differences, 2nd order, 1-d [x] Upwind differences, 2nd order, 2-d [x] Centered differences, 2nd order, 1-d [x] Centered differences, 2nd order, 2-d [ ] Flux corrected transport (Zalesak, 1979) [ ] Smolarkiewitz anti-diffusive velocity scheme (Smolarkiewitz, 1981) [ ] MPDATA (Smolarkiewitz, 1983) [ ] ULTIMATE QUICKEST (Wavewatch III) Stokes drift: [ ] Monochromatic [x] Exact [ ] Webb and Fox-Kemper (2011) [ ] Breivik et al. (2015) Parallel execution: [ ] Fortran Coarrays Input/Output: [ ] NetCDF [x] JSON Development status wavy is in early development. Contributors are highly needed,\nespecially for implementing source functions. You can start \ncontributing by opening an issue . Developer Info Wavebit Scientific LLC","tags":"","loc":"index.html","title":" wavy "},{"text":"This File Depends On sourcefile~~mod_grid.f90~~EfferentGraph sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_utility.f90->sourcefile~mod_grid.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_grid.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_grid.f90~~AfferentGraph sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_grid.f90->sourcefile~mod_domain.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_grid Source Code mod_grid.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. ! !=============================================================================== module mod_grid use mod_precision , only : intkind , realkind use mod_utility , only : diff implicit none integer ( kind = intkind ), parameter :: stdout = 6 integer ( kind = intkind ), parameter :: stderr = 0 private public :: grid_type type :: grid_type private integer ( kind = intkind ), dimension ( 2 ) :: lb !! Lower bounds of the grid integer ( kind = intkind ), dimension ( 2 ) :: ub !! Upper bounds of the grid real ( kind = realkind ), dimension (:,:), allocatable :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: y !! Distance in y-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: dx !! Grid spacing in x-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: dy !! Grid spacing in y-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: lon !! Longitude [rad] real ( kind = realkind ), dimension (:,:), allocatable :: lat !! Latitude [rad] real ( kind = realkind ), dimension (:,:), allocatable :: alpha !! Grid rotation angle [rad] contains procedure , public , pass ( self ) :: getLowerBounds procedure , public , pass ( self ) :: getUpperBounds procedure , public , pass ( self ) :: getAxisX procedure , public , pass ( self ) :: getAxisY procedure , public , pass ( self ) :: getGridSpacingX procedure , public , pass ( self ) :: getGridSpacingY procedure , public , pass ( self ) :: getGridRotation procedure , public , pass ( self ) :: getLongitude procedure , public , pass ( self ) :: getLatitude endtype grid_type interface grid_type module procedure :: constructor_1d module procedure :: constructor_2d endinterface grid_type !=============================================================================== contains !------------------------------------------------------------------------------- type ( grid_type ) function constructor_1d ( lb , ub , x , dx ) result ( grid ) integer ( kind = intkind ), intent ( in ) :: lb !! Lower bound indices of the grid array integer ( kind = intkind ), intent ( in ) :: ub !! Upper bound indices of the grid array real ( kind = realkind ), dimension (:), intent ( in ), optional :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:), intent ( in ), optional :: dx !! Grid spacing in x-direction [m] integer ( kind = intkind ) :: i grid % lb ( 1 ) = lb grid % ub ( 1 ) = ub grid % lb ( 2 ) = 1 grid % ub ( 2 ) = 1 allocate ( grid % x ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dx ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) if ( present ( x ) . and . . not . present ( dx )) then ! x is given as input argument grid % x (:, 1 ) = x ! Compute dx using centered differences grid % dx (:, 1 ) = diff ( x ) elseif (. not . present ( x ) . and . present ( dx )) then ! dx is given as input argument grid % dx (:, 1 ) = dx ! Compute x using dx provided as input argument grid % x ( 1 , 1 ) = 0 do i = grid % lb ( 1 ) + 1 , grid % ub ( 1 ) grid % x ( i , 1 ) = grid % x ( i - 1 , 1 ) + grid % dx ( i , 1 ) enddo endif allocate ( grid % y ( 0 , 0 )) allocate ( grid % dy ( 0 , 0 )) allocate ( grid % lon ( 0 , 0 )) allocate ( grid % lat ( 0 , 0 )) endfunction constructor_1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- type ( grid_type ) function constructor_2d ( lb , ub , x , y , dx , dy , lon , lat ) result ( grid ) integer ( kind = intkind ), dimension (:), intent ( in ) :: lb !! Lower bound indices of the grid array integer ( kind = intkind ), dimension (:), intent ( in ) :: ub !! Upper bound indices of the grid array real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: y !! Distance in y-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: dx !! Grid spacing in x-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: dy !! Grid spacing in y-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: lon !! Longitude [rad] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: lat !! Latitude [rad] integer ( kind = intkind ) :: grid_rank integer ( kind = intkind ) :: idm , jdm integer ( kind = intkind ) :: i , j ! Raise error if lb and ub are not of matching ranks if (. not . size ( lb ) == size ( ub )) then write ( unit = stderr , fmt = '(a)' ) 'Error in grid constructor: size(lb) must == ' & // 'size(ub)' stop 1 endif grid % lb = lb grid % ub = ub allocate ( grid % x ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % y ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dx ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dy ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) if ( present ( x ) . and . present ( y )) then ! x and y are given as input arguments grid % x = x grid % y = y ! Compute dx and dy using centered differences grid % dx = diff ( x , dim = 1 ) grid % dy = diff ( y , dim = 2 ) elseif ( present ( dx ) . and . present ( dy )) then ! dx and dy are given as input arguments grid % dx = dx grid % dy = dy ! Compute x using dx provided as input argument grid % x ( 1 ,:) = 0 do i = grid % lb ( 1 ) + 1 , grid % ub ( 1 ) grid % x ( i ,:) = grid % x ( i - 1 ,:) + grid % dx ( i ,:) enddo ! Compute y using dy provided as input argument grid % y (:, 1 ) = 0 do j = grid % lb ( 2 ) + 1 , grid % ub ( 2 ) grid % y (:, j ) = grid % y (:, j - 1 ) + grid % dy (:, j ) enddo endif endfunction constructor_2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getLowerBounds ( self ) result ( lb ) !! Returns the lower bounds of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance integer ( kind = intkind ), dimension ( 2 ) :: lb !! Upper bound indices lb = self % lb endfunction getLowerBounds !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getUpperBounds ( self ) result ( ub ) !! Returns the upper bounds of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance integer ( kind = intkind ), dimension ( 2 ) :: ub !! Lower bound indices ub = self % ub endfunction getUpperBounds !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getAxisX ( self ) result ( x ) !! Returns the x-coordinate of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: x !! x-coordinate [m] x = self % x endfunction getAxisX !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getAxisY ( self ) result ( y ) !! Returns the y-coordinate [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: y !! y-coordinate [m] y = self % y endfunction getAxisY !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGridSpacingX ( self ) result ( dx ) !! Returns the grid spacing in x [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: dx !! Grid spacing in x [m] dx = self % dx endfunction getGridSpacingX !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGridSpacingY ( self ) result ( dy ) !! Returns the grid spacing in y [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: dy !! Grid spacing in y [m] dy = self % dy endfunction getGridSpacingY !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGridRotation ( self ) result ( alpha ) !! Returns the grid rotation angle [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: alpha !! Grid rotation [rad] alpha = self % alpha endfunction getGridRotation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getLongitude ( self ) result ( lon ) !! Returns the longitude array [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: lon !! Longitude [rad] lon = self % lon endfunction getLongitude !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getLatitude ( self ) result ( lat ) !! Returns the latitude array [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: lat !! Latitude [rad] lat = self % lat endfunction getLatitude !------------------------------------------------------------------------------- endmodule mod_grid","tags":"","loc":"sourcefile/mod_grid.f90.html","title":"mod_grid.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_const.f90~~EfferentGraph sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_const.f90~~AfferentGraph sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_spectral_shapes.f90 mod_spectral_shapes.f90 sourcefile~mod_const.f90->sourcefile~mod_spectral_shapes.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_const.f90->sourcefile~mod_domain.f90 sourcefile~mod_source_functions.f90 mod_source_functions.f90 sourcefile~mod_const.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_const Source Code mod_const.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_const use mod_precision , only : ik => intkind , rk => realkind implicit none private integer ( kind = ik ), dimension ( 1 ), parameter , public :: WAVY_OMNIDIRECTIONAL = [ 1 ] integer ( kind = ik ), dimension ( 1 , 1 ), parameter , public :: WAVY_DIRECTIONAL = reshape ([ 1 ],[ 1 , 1 ]) integer ( kind = ik ), dimension ( 1 , 1 , 1 ), parameter , public :: WAVY_DIRECTIONAL_2D = reshape ([ 1 ],[ 1 , 1 , 1 ]) real ( kind = rk ), parameter , public :: WAVY_REAL = 1._rk integer ( kind = ik ), parameter , public :: WAVY_INT = 1 integer ( kind = ik ), parameter , public :: huge_int = huge ( 1_ik ) real ( kind = rk ), parameter , public :: tiny_real = tiny ( 1 e0_rk ) real ( kind = rk ), parameter , public :: huge_real = huge ( 1 e0_rk ) real ( kind = rk ), parameter , public :: eps = tiny ( 1 e0_rk ) real ( kind = rk ), parameter , public :: pi = 3.14159265358979323846264338327950_rk real ( kind = rk ), parameter , public :: twopi = 2 * pi integer ( kind = ik ), parameter , public :: stdout = 6 integer ( kind = ik ), parameter , public :: stderr = 0 endmodule mod_const","tags":"","loc":"sourcefile/mod_const.f90.html","title":"mod_const.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_io.f90~~EfferentGraph sourcefile~mod_io.f90 mod_io.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_io Source Code mod_io.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3-clause license. See LICENSE for details. module mod_io use mod_precision , only : ik => intkind , rk => realkind implicit none private contains !------------------------------------------------------------------------------- endmodule mod_io","tags":"","loc":"sourcefile/mod_io.f90.html","title":"mod_io.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_linear_wave_theory.f90~~EfferentGraph sourcefile~mod_linear_wave_theory.f90 mod_linear_wave_theory.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_linear_wave_theory.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_linear_wave_theory Source Code mod_linear_wave_theory.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. ! !=============================================================================== module mod_linear_wave_theory use mod_precision , only : intkind , realkind implicit none private public :: elevation public :: pressure public :: horizontalAcceleration public :: horizontalVelocity public :: verticalAcceleration public :: verticalVelocity !=============================================================================== contains !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function elevation ( x , t , a , k , omega ) !! Returns the elevation [m] of a sinusoid wave given its amplitude [m], !! wavenumber [rad/m], and frequency [Hz]. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] elevation = a * sin ( k * x - omega * t ) endfunction elevation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function pressure ( x , z , t , a , k , omega , rho , grav ) !! Returns the pressure [Pa] at depth z (negative downward) for a sinusoid !! wave given its amplitude [m], wavenumber [rad/m], and frequency [Hz]. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical displacement [m] from the surface, negative downward real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] real ( kind = realkind ), intent ( in ) :: rho !! Water density [kg/m&#94;3] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] pressure = - rho * grav * ( elevation ( x , t , a , k , omega ) - z ) endfunction pressure !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function horizontalAcceleration ( x , z , t , a , k , omega ) !! Returns the horizontal acceleration of a water particle under a sinusoid wave, !! given its amplitude, wavenumber, and frequency. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical space, negative downward [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] horizontalAcceleration = - a * omega ** 2 * cos ( k * x - omega * t ) * exp ( k * z ) endfunction horizontalAcceleration !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function horizontalVelocity ( x , z , t , a , k , omega ) !! Returns the horizontal velocity of a water particle under a sinusoid wave, !! given its amplitude, wavenumber, and frequency. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical space, negative downward [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] horizontalVelocity = a * omega * sin ( k * x - omega * t ) * exp ( k * z ) endfunction horizontalVelocity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind )& function verticalAcceleration ( x , z , t , a , k , omega ) !! Returns the vertical acceleration of a water particle under a sinusoid wave, !! given its amplitude, wavenumber, and frequency. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical space, negative downward [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] verticalAcceleration = - a * omega ** 2 * sin ( k * x - omega * t ) * exp ( k * z ) endfunction verticalAcceleration !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function verticalVelocity ( x , z , t , a , k , omega ) !! Returns the vertical velocity of a water particle under a sinusoid wave, !! given its amplitude, wavenumber, and frequency. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical space, negative downward [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] verticalVelocity = - a * omega * cos ( k * x - omega * t ) * exp ( k * z ) endfunction verticalVelocity !------------------------------------------------------------------------------- endmodule mod_linear_wave_theory","tags":"","loc":"sourcefile/mod_linear_wave_theory.f90.html","title":"mod_linear_wave_theory.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_stokes.f90~~EfferentGraph sourcefile~mod_stokes.f90 mod_stokes.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_stokes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_stokes Source Code mod_stokes.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_stokes use mod_precision , only : realkind implicit none private contains endmodule mod_stokes","tags":"","loc":"sourcefile/mod_stokes.f90.html","title":"mod_stokes.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_domain.f90~~EfferentGraph sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_domain.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_precision.f90->sourcefile~mod_grid.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 sourcefile~mod_const.f90->sourcefile~mod_domain.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_grid.f90->sourcefile~mod_domain.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_utility.f90->sourcefile~mod_grid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_domain.f90~~AfferentGraph sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_domain Source Code mod_domain.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_domain use mod_precision , only : ik => intkind , rk => realkind use mod_spectrum , only : spectrum_type use mod_grid , only : grid_type use mod_const use datetime_module , only : datetime , timedelta use json_module , only : json_core , json_file , json_value implicit none private public :: domain_type type :: domain_type private character ( len = :), allocatable :: type_name type ( grid_type ) :: grid type ( spectrum_type ), dimension (:,:), allocatable :: spectrum logical :: shallow_water_mode type ( datetime ) :: start_time !! Simulation start time type ( datetime ) :: end_time !! Simulation end time type ( timedelta ) :: time_step !! Time step [s] real ( kind = rk ), dimension (:,:), allocatable :: dx ! grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dy ! grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: u ! x-component of velocity [m/s] real ( kind = rk ), dimension (:,:), allocatable :: v ! y-component of velocity [m/s] real ( kind = rk ), dimension (:,:), allocatable :: eta ! surface elevation [m] real ( kind = rk ), dimension (:,:), allocatable :: depth ! mean water depth [m] integer ( kind = ik ), dimension ( 2 ) :: lb ! lower bounds in geographical space integer ( kind = ik ), dimension ( 2 ) :: ub ! upper bounds in geographical space integer ( kind = ik ) :: nfreqs ! number of frequencies integer ( kind = ik ) :: ndirs ! number of directions contains ! Public type-bound methods procedure , public , pass ( self ) :: frequencyMoment procedure , public , pass ( self ) :: getCurrent_u procedure , public , pass ( self ) :: getCurrent_v procedure , public , pass ( self ) :: getGravity procedure , public , pass ( self ) :: getGrid procedure , public , pass ( self ) :: getGridSpacingXWithHalo procedure , public , pass ( self ) :: getGridSpacingYWithHalo procedure , public , pass ( self ) :: getDepth procedure , public , pass ( self ) :: getElevation procedure , public , pass ( self ) :: getFrequency procedure , public , pass ( self ) :: getDirections procedure , public , pass ( self ) :: getLowerBounds procedure , public , pass ( self ) :: getUpperBounds procedure , public , pass ( self ) :: getSpectrum procedure , public , pass ( self ) :: getSpectrumArray procedure , public , pass ( self ) :: getPhaseSpeed procedure , public , pass ( self ) :: getGroupSpeed procedure , public , pass ( self ) :: getSurfaceTension procedure , public , pass ( self ) :: getAirDensity procedure , public , pass ( self ) :: getWaterDensity procedure , public , pass ( self ) :: isAllocated procedure , public , pass ( self ) :: meanPeriod procedure , public , pass ( self ) :: meanPeriodZeroCrossing procedure , public , pass ( self ) :: setDepth procedure , public , pass ( self ) :: setElevation procedure , public , pass ( self ) :: setGravity procedure , public , pass ( self ) :: setSurfaceTension procedure , public , pass ( self ) :: setAirDensity procedure , public , pass ( self ) :: setWaterDensity procedure , public , pass ( self ) :: significantWaveHeight procedure , public , pass ( self ) :: wavenumberMoment procedure , public , pass ( self ) :: writeJSON ! Specific procedures overloaded by generic procedures and operators procedure , private , pass ( self ) :: advect1dRank1 procedure , private , pass ( self ) :: advect1dRank2 procedure , private , pass ( self ) :: advect2dRank2 procedure , private , pass ( self ) :: assign_spectrum_array_1d procedure , private , pass ( self ) :: assign_spectrum_array_2d procedure , private , pass ( self ) :: domain_add_domain procedure , private , pass ( self ) :: domain_add_real procedure , private , pass ( self ) :: domain_sub_domain procedure , private , pass ( self ) :: domain_sub_real procedure , private , pass ( self ) :: domain_mult_domain procedure , private , pass ( self ) :: domain_mult_real procedure , private , pass ( self ) :: domain_div_domain procedure , private , pass ( self ) :: domain_div_real procedure , private , pass ( self ) :: domain_unary_minus procedure , private , pass ( self ) :: real_add_domain procedure , private , pass ( self ) :: real_sub_domain procedure , private , pass ( self ) :: real_mult_domain procedure , private , pass ( self ) :: real_div_domain procedure , private , pass ( self ) :: eq procedure , private , pass ( self ) :: neq procedure , private , pass ( self ) :: setSpectrum1d procedure , private , pass ( self ) :: setSpectrum2d procedure , private , pass ( self ) :: setSpectrumArray1d1d procedure , private , pass ( self ) :: setSpectrumArray1d2d procedure , private , pass ( self ) :: setSpectrumArray2d2d ! Generic procedures generic , public :: advect => advect1dRank1 ,& advect1dRank2 ,& advect2dRank2 generic , public :: setSpectrum => setSpectrum1d ,& setSpectrum2d generic , public :: setSpectrumArray => setSpectrumArray1d1d ,& setSpectrumArray1d2d ,& setSpectrumArray2d2d ! Generic operators generic :: assignment ( = ) => assign_spectrum_array_1d ,& assign_spectrum_array_2d generic :: operator ( + ) => domain_add_domain ,& domain_add_real ,& real_add_domain generic :: operator ( - ) => domain_sub_domain ,& domain_sub_real ,& domain_unary_minus ,& real_sub_domain generic :: operator ( * ) => domain_mult_domain ,& domain_mult_real ,& real_mult_domain generic :: operator ( / ) => domain_div_domain ,& domain_div_real ,& real_div_domain generic :: operator ( == ) => eq generic :: operator ( /= ) => neq endtype domain_type interface domain_type module procedure :: constructor endinterface domain_type contains !------------------------------------------------------------------------------- type ( domain_type ) function constructor ( grid , spectrum , shallow_water_mode ) result ( domain ) !! Constructor function for the domain object. type ( grid_type ), intent ( in ) :: grid !! Input `grid` instance type ( spectrum_type ), intent ( in ) :: spectrum !! Input `spectrum` instance logical , intent ( in ), optional :: shallow_water_mode !! Logical switch to enable shallow water solver integer ( kind = ik ) :: i , j if ( present ( shallow_water_mode )) then domain % shallow_water_mode = shallow_water_mode else domain % shallow_water_mode = . false . endif domain % type_name = 'domain_type' domain % grid = grid domain % lb = grid % getLowerBounds () domain % ub = grid % getUpperBounds () domain % dx = grid % getGridSpacingX () domain % dy = grid % getGridSpacingY () allocate ( domain % spectrum ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) do concurrent ( i = domain % lb ( 1 ): domain % ub ( 1 ),& j = domain % lb ( 2 ): domain % ub ( 2 )) domain % spectrum ( i , j ) = spectrum enddo allocate ( domain % u ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % u = 0 allocate ( domain % v ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % v = 0 allocate ( domain % eta ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % eta = 0 allocate ( domain % depth ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % nfreqs = size ( spectrum % getFrequency ()) domain % ndirs = size ( spectrum % getDirections ()) endfunction constructor !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( domain_type ) function advect1dRank1 ( self , advection_method , halowidth ,& directional_type ) result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works only in cases where `ndirs == 1`. !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 1 (omnidirectional) in 1-dimensional space: !! !!   * advectUpwind1stOrder1dRank1 !!   * advectCentered2ndOrder1dRank1 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , dx ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:), intent ( in ) :: u real ( kind = rk ), dimension (:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ), dimension (:), intent ( in ) :: directional_type !! A global constant that helps resolve the interface of this specific !! prodedure integer ( kind = ik ) :: idm real ( kind = rk ), dimension (:,:), allocatable :: f real ( kind = rk ), dimension (:,:), allocatable :: cg real ( kind = rk ), dimension (:), allocatable :: dx associate ( lb => self % lb , ub => self % ub , hw => halowidth ) adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw f = reshape ( self % getSpectrumArray ([ hw , 0 ],. true .),[ self % nfreqs , idm ]) cg = reshape ( self % getGroupSpeed ([ hw , 0 ],. true .),[ self % nfreqs , idm ]) dx = reshape ( self % getGridSpacingXWithHalo ([ hw , 0 ],. true .),[ idm ]) call adv % setSpectrumArray ( advection_method ( f , cg , dx )) endassociate endfunction advect1dRank1 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( domain_type ) function advect1dRank2 ( self , advection_method , halowidth ,& directional_type ) result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works both when `ndirs == 1` (omnidirectional) and when !! `ndirs > 1` (directional). !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 2 (directional) in 1-dimensional space: !! !!   * advectUpwind1stOrder1dRank2 !!   * advectCentered2ndOrder1dRank2 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , dx ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u real ( kind = rk ), dimension (:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ), dimension (:,:), intent ( in ) :: directional_type !! A global constant that helps resolve the interface of this specific !! prodedure integer ( kind = ik ) :: idm real ( kind = rk ), dimension (:,:,:), allocatable :: f real ( kind = rk ), dimension (:,:,:), allocatable :: cg real ( kind = rk ), dimension (:), allocatable :: dx associate ( lb => self % lb , ub => self % ub , hw => halowidth ) adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw f = reshape ( self % getSpectrumArray ([ hw , 0 ],. true .),[ self % nfreqs , self % ndirs , idm ]) cg = reshape ( self % getGroupSpeed ([ hw , 0 ],. true .),[ self % nfreqs , self % ndirs , idm ]) dx = reshape ( self % getGridSpacingXWithHalo ([ hw , 0 ],. true .),[ idm ]) call adv % setSpectrumArray ( advection_method ( f , cg , dx )) endassociate endfunction advect1dRank2 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( domain_type ) function advect2dRank2 ( self , advection_method , halowidth )& result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works both when `ndirs == 1` (omnidirectional) and when !! `ndirs > 1` (directional). !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 2 (directional) in 2-dimensional space: !! !!   * advectUpwind1stOrder2dRank2 !!   * advectCentered2ndOrder2dRank2 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , v , dx , dy ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v real ( kind = rk ), dimension (:,:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:), intent ( in ) :: dy real ( kind = rk ), dimension (:,:,:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), dimension (:), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ) :: idm , jdm , n real ( kind = rk ), dimension (:,:,:,:), allocatable :: f real ( kind = rk ), dimension (:,:,:), allocatable :: cg real ( kind = rk ), dimension (:,:,:,:), allocatable :: cgx real ( kind = rk ), dimension (:,:,:,:), allocatable :: cgy real ( kind = rk ), dimension (:,:), allocatable :: dx real ( kind = rk ), dimension (:,:), allocatable :: dy real ( kind = rk ), dimension (:), allocatable :: theta associate ( lb => self % lb , ub => self % ub , hw => halowidth ) theta = self % getDirections () adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw ( 1 ) jdm = ub ( 2 ) - lb ( 2 ) + 1 + 2 * hw ( 2 ) f = reshape ( self % getSpectrumArray ( hw ,. true .),[ self % nfreqs , self % ndirs ,[ idm , jdm ]]) allocate ( cgx ( self % nfreqs , self % ndirs , idm , jdm )) allocate ( cgy ( self % nfreqs , self % ndirs , idm , jdm )) cg = self % getGroupSpeed ( hw ,. true .) do concurrent ( n = 1 : self % ndirs ) cgx (:, n ,:,:) = cos ( theta ( n )) * cg cgy (:, n ,:,:) = sin ( theta ( n )) * cg enddo dx = self % getGridSpacingXWithHalo ( hw ,. true .) dy = self % getGridSpacingYWithHalo ( hw ,. true .) call adv % setSpectrumArray ( advection_method ( f , cgx , cgy , dx , dy )) deallocate ( cgx , cgy ) endassociate endfunction advect2dRank2 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function isAllocated ( self ) !! Returns the allocation status of the domains sub-components. class ( domain_type ), intent ( in ) :: self !! `domain` instance isAllocated = allocated ( self % spectrum ) endfunction isAllocated !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine assign_spectrum_array_1d ( self , spectrum_array ) !! Assigns a 1-d array of `spectrum` instances to a `domain` instance. This !! procedure overloads the assignment ('=') operator. class ( domain_type ), intent ( inout ) :: self !! l.h.s. `domain` instance class ( spectrum_type ), dimension (:), intent ( in ) :: spectrum_array !! r.h.s. array of `spectrum` instances call self % setSpectrum ( spectrum_array ) endsubroutine assign_spectrum_array_1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine assign_spectrum_array_2d ( self , spectrum_array ) !! Assigns a 2-d array of `spectrum` instances to a `domain` instance. This !! procedure overloads the assignment ('=') operator. class ( domain_type ), intent ( inout ) :: self !! l.h.s. `domain` instance class ( spectrum_type ), dimension (:,:), intent ( in ) :: spectrum_array !! r.h.s. array of `spectrum` instances call self % setSpectrum ( spectrum_array ) endsubroutine assign_spectrum_array_2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function eq ( self , d2 ) !! Logical equality comparison function. Overloads the `/=` operator. class ( domain_type ), intent ( in ) :: self !! l.h.s. `domain` instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. `domain` instance eq = all ( self % getSpectrum () == d2 % getSpectrum ()) endfunction eq !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function neq ( self , d2 ) !! Logical inequality comparison function. Overloads the `/=` operator. class ( domain_type ), intent ( in ) :: self !! l.h.s. `domain` instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. `domain` instance neq = . not . self == d2 endfunction neq !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_add_domain ( self , d2 )& result ( domain ) !! Returns a sum of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () + d2 % getSpectrum () endfunction domain_add_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_sub_domain ( self , d2 )& result ( domain ) !! Returns a difference between two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () - d2 % getSpectrum () endfunction domain_sub_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_unary_minus ( self ) result ( domain ) !! Returns a negative domain instances. class ( domain_type ), intent ( in ) :: self !! domain instance domain = self domain = - self % getSpectrum () endfunction domain_unary_minus !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_mult_domain ( self , d2 )& result ( domain ) !! Returns a product of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () * d2 % getSpectrum () endfunction domain_mult_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_div_domain ( self , d2 )& result ( domain ) !! Returns a division of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () / d2 % getSpectrum () endfunction domain_div_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_add_real ( self , a )& result ( domain ) !! Returns a sum of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () + a endfunction domain_add_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_sub_real ( self , a ) result ( domain ) !! Returns a difference between a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () - a endfunction domain_sub_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_mult_real ( self , a )& result ( domain ) !! Returns a product of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () * a endfunction domain_mult_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function domain_div_real ( self , a ) result ( domain ) !! Returns a division of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () / a endfunction domain_div_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function real_add_domain ( a , self ) result ( domain ) !! Returns a sum of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = self % getSpectrum () + a endfunction real_add_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function real_sub_domain ( a , self ) result ( domain ) !! Returns a difference between a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = a - self % getSpectrum () endfunction real_sub_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function real_mult_domain ( a , self )& result ( domain ) !! Returns a product of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = self % getSpectrum () * a endfunction real_mult_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function real_div_domain ( a , self ) result ( domain ) !! Returns a product of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = a / self % getSpectrum () endfunction real_div_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getCurrent_u ( self ) result ( u ) !! Returns the 3-d array with values of Eulerian velocity (mean current) in !! x-direction [m/s]. !! !! Note: this implementation assumes that all u and v velocity arrays in !! the domain instance are of same length in depth, such that the resulting !! u and v arrays are regular 3-d arrays. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: u !! Eulerian u-velocity [m/s] integer ( kind = ik ) :: i , j integer ( kind = ik ) :: kdm associate ( lb => self % lb , ub => self % ub ) kdm = size ( self % spectrum ( 1 , 1 ) % getCurrent_u ()) allocate ( u ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ), kdm )) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) u ( i , j ,:) = self % spectrum ( i , j ) % getCurrent_u () enddo endassociate endfunction getCurrent_u !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getCurrent_v ( self ) result ( v ) !! Returns the 3-d array with values of Eulerian velocity (mean current) in !! y-direction [m/s]. !! !! Note: this implementation assumes that all u and v velocity arrays in !! the domain instance are of same length in depth, such that the resulting !! u and v arrays are regular 3-d arrays. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: v !! Eulerian v-velocity [m/s] integer ( kind = ik ) :: i , j integer ( kind = ik ) :: kdm associate ( lb => self % lb , ub => self % ub ) kdm = size ( self % spectrum ( 1 , 1 ) % getCurrent_v ()) allocate ( v ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ), kdm )) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) v ( i , j ,:) = self % spectrum ( i , j ) % getCurrent_v () enddo endassociate endfunction getCurrent_v !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getDepth ( self ) result ( depth ) !! Returns the mean water depth [m] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: depth !! Mean water depth [m] depth = self % spectrum % getDepth () endfunction getDepth !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getElevation ( self ) result ( elevation ) !! Returns the mean water elevation [m] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: elevation !! Mean water elevation [m] elevation = self % spectrum % getElevation () endfunction getElevation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getFrequency ( self ) result ( frequency ) !! Returns the frequency [Hz] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:), allocatable :: frequency !! Frequency [Hz] frequency = self % spectrum ( 1 , 1 ) % getFrequency () endfunction getFrequency !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getDirections ( self ) result ( directions ) !! Returns the spectral direction bins [rad]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:), allocatable :: directions !! Directions [rad] directions = self % spectrum ( 1 , 1 ) % getDirections () endfunction getDirections !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGravity ( self ) result ( grav ) !! Returns the gravitational acceleration [m/s&#94;2] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: grav !! Gravitational acceleration [m/s&#94;2] grav = self % spectrum % getGravity () endfunction getGravity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGrid ( self ) result ( grid ) !! Returns the grid instance that is the component of the domain. class ( domain_type ), intent ( in ) :: self !! Domain instance type ( grid_type ) :: grid !! Grid instance component grid = self % grid endfunction getGrid !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getLowerBounds ( self ) result ( lb ) !! Returns the lower bounds of the domain instance. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ) :: lb !! Lower bound indices lb = self % lb endfunction getLowerBounds !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getUpperBounds ( self ) result ( ub ) !! Returns the upper bounds of the domain instance. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ) :: ub !! Upper bound indices ub = self % ub endfunction getUpperBounds !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getSpectrum ( self ) result ( spectrum ) !! Returns the array of spectrum instances. class ( domain_type ), intent ( in ) :: self !! Domain instance type ( spectrum_type ), dimension (:,:), allocatable :: spectrum !! Array of spectrum instances spectrum = self % spectrum endfunction getSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getSpectrumArray ( self , halowidth , periodic ) result ( spectrum_array ) !! Returns a 4-dimensional spectrum array, where the first two dimensions are !! frequency and directional dimensions and the second two are spatial x and y !! dimensions. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:,:), allocatable :: spectrum_array !! Spectrum array integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integers indicating how many cells to allocate for halo points logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions integer ( kind = ik ) :: i , j integer ( kind = ik ) :: ndirs , nfreqs associate ( lb => self % lb , ub => self % ub , hw => halowidth ) nfreqs = size ( self % spectrum ( 1 , 1 ) % getSpectrum (), dim = 1 ) ndirs = size ( self % spectrum ( 1 , 1 ) % getSpectrum (), dim = 2 ) allocate ( spectrum_array ( nfreqs , ndirs , lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ),& lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) spectrum_array (:,:, i , j ) = self % spectrum ( i , j ) % getSpectrum () enddo ! Set halo values for periodic boundary conditions if ( periodic ) then spectrum_array (:,:, lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:)& = spectrum_array (:,:, ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) spectrum_array (:,:, ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:)& = spectrum_array (:,:, lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) spectrum_array (:,:,:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 )& = spectrum_array (:,:,:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) spectrum_array (:,:,:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 ))& = spectrum_array (:,:,:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getSpectrumArray !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getPhaseSpeed ( self ) result ( cp ) !! Returns a 3-d array with phase speed values [m/s]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: cp !! Phase speed [m/s] array integer ( kind = ik ) :: i , j integer ( kind = ik ) :: ndirs associate ( lb => self % lb , ub => self % ub ) allocate ( cp ( self % nfreqs , lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) cp (:, i , j ) = self % spectrum ( i , j ) % getPhaseSpeed () enddo endassociate endfunction getPhaseSpeed !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGroupSpeed ( self , halowidth , periodic ) result ( cg ) !! Returns a 3-d array with group speed values [m/s]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: cg !! Group speed [m/s] array integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integers indicating how many cells to allocate for halo points logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( cg ( self % nfreqs , lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) cg (:, i , j ) = self % spectrum ( i , j ) % getGroupSpeed () enddo ! Set halo values for periodic boundary conditions if ( periodic ) then cg (:, lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = cg (:, ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) cg (:, ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = cg (:, lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) cg (:,:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = cg (:,:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) cg (:,:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = cg (:,:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGroupSpeed !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGridSpacingXWithHalo ( self , halowidth , periodic ) result ( dx ) !! Returns grid spacing array in x-direction including halo cells. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integer width of halo region logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions real ( kind = rk ), dimension (:,:), allocatable :: dx !! Grid spacing in x [m] associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( dx ( lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) dx = 0 dx ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 )) = self % dx ! Set halo values for periodic boundary conditions if ( periodic ) then dx ( lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = dx ( ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) dx ( ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = dx ( lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) dx (:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = dx (:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) dx (:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = dx (:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGridSpacingXWithHalo !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGridSpacingYWithHalo ( self , halowidth , periodic ) result ( dy ) !! Returns grid spacing array in y-direction including halo cells. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integer width of halo region logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions real ( kind = rk ), dimension (:,:), allocatable :: dy !! Grid spacing in y [m] associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( dy ( lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) dy = 0 dy ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 )) = self % dy ! Set halo values for periodic boundary conditions if ( periodic ) then dy ( lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = dy ( ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) dy ( ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = dy ( lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) dy (:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = dy (:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) dy (:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = dy (:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGridSpacingYWithHalo !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getSurfaceTension ( self ) result ( surface_tension ) !! Returns the surface tension [N/m]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: surface_tension !! Surface tension [N/m] surface_tension = self % spectrum % getSurfaceTension () endfunction getSurfaceTension !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getAirDensity ( self ) result ( air_density ) !! Returns the air density [kg/m&#94;3]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: air_density !! Air density [kg/m&#94;3] air_density = self % spectrum % getAirDensity () endfunction getAirDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWaterDensity ( self ) result ( water_density ) !! Returns the water density [kg/m&#94;3]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: water_density !! Water density [kg/m&#94;3] water_density = self % spectrum % getWaterDensity () endfunction getWaterDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setDepth ( self , depth ) !! Sets the mean water depth [m]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: depth !! Mean water depth [m] call self % spectrum % setDepth ( depth ) endsubroutine setDepth !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setElevation ( self , elevation ) !! Sets the mean water elevation [m]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: elevation !! Mean water elevation [m] call self % spectrum % setElevation ( elevation ) endsubroutine setElevation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setGravity ( self , grav ) !! Sets the gravitational acceleration [m/s&#94;2]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] call self % spectrum % setGravity ( grav ) endsubroutine setGravity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSurfaceTension ( self , surface_tension ) !! Sets the surface tension [N/m&#94;2]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: surface_tension !! Surface tension [N/m&#94;2] call self % spectrum % setSurfaceTension ( surface_tension ) endsubroutine setSurfaceTension !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setAirDensity ( self , air_density ) !! Sets the air density [kg/m&#94;3]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: air_density !! Air density [kg/m&#94;3] call self % spectrum % setAirDensity ( air_density ) endsubroutine setAirDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setWaterDensity ( self , water_density ) !! Sets the water density [kg/m&#94;3]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: water_density !! Water density [kg/m&#94;3] call self % spectrum % setWaterDensity ( water_density ) endsubroutine setWaterDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrum1d ( self , spectrum ) !! Sets the 1-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( domain_type ), intent ( inout ) :: self !! Domain instance type ( spectrum_type ), dimension (:), intent ( in ) :: spectrum !! Input 1-d array of spectrum object instances integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) self % spectrum ( i , j ) = spectrum ( i ) enddo endassociate endsubroutine setSpectrum1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrum2d ( self , spectrum ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( domain_type ), intent ( inout ) :: self !! Domain instance type ( spectrum_type ), dimension (:,:), intent ( in ) :: spectrum !! Input 2-d array of spectrum object instances integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) self % spectrum ( i , j ) = spectrum ( i , j ) enddo endassociate endsubroutine setSpectrum2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrumArray1d1d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for omnidirectional spectrum in 1-d space (1d-1d) class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:, i )) enddo endassociate endsubroutine setSpectrumArray1d1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrumArray1d2d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for setting 1-d spectrum into 2-d physical space !! of 2-d spectrum into 1-d physical space. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) if ( lb ( 2 ) == ub ( 2 )) then ! Setting 2-d spectrum into 1-d physical space do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:,:, i )) enddo else ! Setting 1-d spectrum into 2-d physical space do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:, i , j )) enddo endif endassociate endsubroutine setSpectrumArray1d2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrumArray2d2d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for directional spectrum in 2-d space (2d-2d) class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:,:, i , j )) enddo endassociate endsubroutine setSpectrumArray2d2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function frequencyMoment ( self , n ) result ( moment ) !! Returns the spectral frequency moment of order n. class ( domain_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ), intent ( in ) :: n !! Order real ( kind = rk ), dimension (:,:), allocatable :: moment moment = self % spectrum % frequencyMoment ( n ) endfunction frequencyMoment !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function wavenumberMoment ( self , n ) result ( moment ) !! Returns the spectral frequency moment of order n. class ( domain_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ), intent ( in ) :: n !! Order real ( kind = rk ), dimension (:,:), allocatable :: moment moment = self % spectrum % wavenumberMoment ( n ) endfunction wavenumberMoment !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function meanPeriod ( self ) !! Returns the mean wave period [s] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: meanPeriod !! Mean period [s] array meanPeriod = self % spectrum % meanPeriod () endfunction meanPeriod !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function meanPeriodZeroCrossing ( self ) !! Returns the zero-crossing mean wave period [s] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: meanPeriodZeroCrossing !! Mean period [s] array meanPeriodZeroCrossing = self % spectrum % meanPeriodZeroCrossing () endfunction meanPeriodZeroCrossing !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function significantWaveHeight ( self ) result ( hs ) !! Returns the significant wave height [m] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: hs !! Significant wave height [m] array hs = self % spectrum % significantWaveHeight () endfunction significantWaveHeight !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- subroutine writeJSON ( self , filename , minify ) !! Writes a spectrum instance to a JSON file. class ( domain_type ), intent ( in ) :: self !! `domain` instance character ( len =* ), intent ( in ) :: filename !! JSON file name logical , intent ( in ) :: minify !! Logical switch to minify the JSON file type ( json_core ) :: json type ( json_value ), pointer :: ptr call json % initialize ( no_whitespace = minify , real_format = 'ES' ) call json % create_object ( ptr , '' ) call json % add ( ptr , 'lb' , self % grid % getLowerBounds ()) call json % add ( ptr , 'ub' , self % grid % getUpperBounds ()) call json % add ( ptr , 'x' , pack ( self % grid % getAxisX (),. true .)) call json % add ( ptr , 'y' , pack ( self % grid % getAxisY (),. true .)) !call json % add(ptr,'lon',pack(self % grid % getLongitude(),.true.)) !call json % add(ptr,'lat',pack(self % grid % getLatitude(),.true.)) call json % add ( ptr , 'u' , pack ( self % u ,. true .)) call json % add ( ptr , 'v' , pack ( self % v ,. true .)) call json % add ( ptr , 'eta' , pack ( self % eta ,. true .)) call json % add ( ptr , 'depth' , pack ( self % depth ,. true .)) call json % add ( ptr , 'frequency' , self % getFrequency ()) call json % add ( ptr , 'directions' , self % getDirections ()) call json % add ( ptr , 'spectrum' ,& pack ( self % getSpectrumArray ([ 0 , 0 ],. false .),. true .)) call json % print ( ptr , trim ( filename )) call json % destroy ( ptr ) endsubroutine writeJSON !------------------------------------------------------------------------------- endmodule mod_domain","tags":"","loc":"sourcefile/mod_domain.f90.html","title":"mod_domain.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_advection.f90~~EfferentGraph sourcefile~mod_advection.f90 mod_advection.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_advection.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_advection Source Code mod_advection.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. ! !=============================================================================== module mod_advection use mod_precision , only : ik => intkind , rk => realkind implicit none private ! Generic procedures public :: advectUpwind1stOrder public :: advectCentered2ndOrder ! Specific procedures public :: advectUpwind1stOrder1dRank1 public :: advectUpwind1stOrder1dRank2 public :: advectUpwind1stOrder2dRank1 public :: advectUpwind1stOrder2dRank2 public :: advectCentered2ndOrder1dRank1 public :: advectCentered2ndOrder1dRank2 interface advectUpwind1stOrder module procedure :: advectUpwind1stOrder1dRank0 module procedure :: advectUpwind1stOrder1dRank1 module procedure :: advectUpwind1stOrder1dRank2 module procedure :: advectUpwind1stOrder2dRank0 module procedure :: advectUpwind1stOrder2dRank1 module procedure :: advectUpwind1stOrder2dRank2 endinterface advectUpwind1stOrder interface advectCentered2ndOrder module procedure :: advectCentered2ndOrder1dRank0 module procedure :: advectCentered2ndOrder1dRank1 module procedure :: advectCentered2ndOrder1dRank2 module procedure :: advectCentered2ndOrder2dRank0 module procedure :: advectCentered2ndOrder2dRank1 module procedure :: advectCentered2ndOrder2dRank2 endinterface advectCentered2ndOrder !TODO 3rd order upwind !TODO Smolarkiewitz anti-diffusion !TODO Smolarkiewitz MPDATA !TODO Zalesak FCT !=============================================================================== contains !------------------------------------------------------------------------------- pure function advectUpwind1stOrder1dRank0 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i integer ( kind = ik ) :: idm idm = size ( f ) allocate ( dfdt ( 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 ) dfdt ( i ) = - 0.5_rk * (( u ( i + 1 ) + abs ( u ( i + 1 ))) * f ( i ) & + ( u ( i + 1 ) - abs ( u ( i + 1 ))) * f ( i + 1 )& - ( u ( i ) + abs ( u ( i ))) * f ( i - 1 ) & - ( u ( i ) - abs ( u ( i ))) * f ( i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank0 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectUpwind1stOrder1dRank1 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 2-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m integer ( kind = ik ) :: idm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) allocate ( dfdt ( mdm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm ) dfdt ( m , i ) = - 0.5_rk * (( u ( m , i + 1 ) + abs ( u ( m , i + 1 ))) * f ( m , i ) & + ( u ( m , i + 1 ) - abs ( u ( m , i + 1 ))) * f ( m , i + 1 )& - ( u ( m , i ) + abs ( u ( m , i ))) * f ( m , i - 1 ) & - ( u ( m , i ) - abs ( u ( m , i ))) * f ( m , i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank1 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectUpwind1stOrder1dRank2 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! This function is for 3-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m , n integer ( kind = ik ) :: idm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i ) = - 0.5_rk * (( u ( m , n , i + 1 ) + abs ( u ( m , n , i + 1 ))) * f ( m , n , i ) & + ( u ( m , n , i + 1 ) - abs ( u ( m , n , i + 1 ))) * f ( m , n , i + 1 )& - ( u ( m , n , i ) + abs ( u ( m , n , i ))) * f ( m , n , i - 1 ) & - ( u ( m , n , i ) - abs ( u ( m , n , i ))) * f ( m , n , i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank2 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectUpwind1stOrder2dRank0 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j integer ( kind = ik ) :: idm , jdm idm = size ( f , dim = 1 ) jdm = size ( f , dim = 2 ) allocate ( dfdt ( 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 ) dfdt ( i , j ) = - 0.25_rk & * (( u ( i + 1 , j ) + abs ( u ( i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( i , j ) & + ( u ( i + 1 , j ) - abs ( u ( i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( i + 1 , j )& - ( u ( i , j ) + abs ( u ( i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( i - 1 , j ) & - ( u ( i , j ) - abs ( u ( i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( i , j ) & + ( v ( i , j ) + abs ( v ( i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( i , j ) & + ( v ( i , j ) - abs ( v ( i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( i + 1 , j ) & - ( v ( i , j - 1 ) + abs ( v ( i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( i - 1 , j )& - ( v ( i , j - 1 ) - abs ( v ( i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank0 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectUpwind1stOrder2dRank1 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m integer ( kind = ik ) :: idm , jdm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) jdm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm ) dfdt ( m , i , j ) = - 0.25_rk & * (( u ( m , i + 1 , j ) + abs ( u ( m , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , i , j ) & + ( u ( m , i + 1 , j ) - abs ( u ( m , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , i + 1 , j )& - ( u ( m , i , j ) + abs ( u ( m , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , i - 1 , j ) & - ( u ( m , i , j ) - abs ( u ( m , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , i , j ) & + ( v ( m , i , j ) + abs ( v ( m , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , i , j ) & + ( v ( m , i , j ) - abs ( v ( m , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , i + 1 , j ) & - ( v ( m , i , j - 1 ) + abs ( v ( m , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , i - 1 , j )& - ( v ( m , i , j - 1 ) - abs ( v ( m , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank1 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectUpwind1stOrder2dRank2 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m , n integer ( kind = ik ) :: idm , jdm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) jdm = size ( f , dim = 4 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i , j ) = - 0.25_rk & * (( u ( m , n , i + 1 , j ) + abs ( u ( m , n , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , n , i , j ) & + ( u ( m , n , i + 1 , j ) - abs ( u ( m , n , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , n , i + 1 , j )& - ( u ( m , n , i , j ) + abs ( u ( m , n , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , n , i - 1 , j ) & - ( u ( m , n , i , j ) - abs ( u ( m , n , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , n , i , j ) & + ( v ( m , n , i , j ) + abs ( v ( m , n , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , n , i , j ) & + ( v ( m , n , i , j ) - abs ( v ( m , n , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , n , i + 1 , j ) & - ( v ( m , n , i , j - 1 ) + abs ( v ( m , n , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , n , i - 1 , j )& - ( v ( m , n , i , j - 1 ) - abs ( v ( m , n , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , n , i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank2 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder1dRank0 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i integer ( kind = ik ) :: idm idm = size ( f ) allocate ( dfdt ( 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 ) dfdt ( i ) = - 0.5_rk * ( u ( i + 1 ) * ( f ( i ) + f ( i + 1 ))& - u ( i ) * ( f ( i - 1 ) + f ( i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank0 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder1dRank1 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 2-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m integer ( kind = ik ) :: idm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) allocate ( dfdt ( mdm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm ) dfdt ( m , i ) = - 0.5_rk * ( u ( m , i + 1 ) * ( f ( m , i ) + f ( m , i + 1 ))& - u ( m , i ) * ( f ( m , i - 1 ) + f ( m , i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank1 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder1dRank2 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 3-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m , n integer ( kind = ik ) :: idm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i ) = - 0.5_rk * ( u ( m , n , i + 1 ) * ( f ( m , n , i ) + f ( m , n , i + 1 ))& - u ( m , n , i ) * ( f ( m , n , i - 1 ) + f ( m , n , i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank2 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder2dRank0 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j integer ( kind = ik ) :: idm , jdm idm = size ( f , dim = 1 ) jdm = size ( f , dim = 2 ) allocate ( dfdt ( 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 ) dfdt ( i , j ) = - 0.25_rk * ( u ( i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( i , j ) + f ( i + 1 , j )) & - u ( i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( i - 1 , j ) + f ( i , j )) & + v ( i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( i , j ) + f ( i , j + 1 )) & - v ( i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( i , j - 1 ) + f ( i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank0 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder2dRank1 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m integer ( kind = ik ) :: idm , jdm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) jdm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm ) dfdt ( m , i , j ) = - 0.25_rk & * ( u ( m , i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( m , i , j ) + f ( m , i + 1 , j )) & - u ( m , i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( m , i - 1 , j ) + f ( m , i , j )) & + v ( m , i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( m , i , j ) + f ( m , i , j + 1 )) & - v ( m , i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( m , i , j - 1 ) + f ( m , i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank1 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function advectCentered2ndOrder2dRank2 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m , n integer ( kind = ik ) :: idm , jdm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) jdm = size ( f , dim = 4 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i , j ) = - 0.25_rk & * ( u ( m , n , i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( m , n , i , j ) + f ( m , n , i + 1 , j )) & - u ( m , n , i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( m , n , i - 1 , j ) + f ( m , n , i , j )) & + v ( m , n , i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( m , n , i , j ) + f ( m , n , i , j + 1 )) & - v ( m , n , i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( m , n , i , j - 1 ) + f ( m , n , i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank2 !------------------------------------------------------------------------------- endmodule mod_advection","tags":"","loc":"sourcefile/mod_advection.f90.html","title":"mod_advection.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_utility.f90~~EfferentGraph sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_utility.f90~~AfferentGraph sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_utility.f90->sourcefile~mod_grid.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_grid.f90->sourcefile~mod_domain.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_source_functions.f90 mod_source_functions.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_utility Source Code mod_utility.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. ! module mod_utility use mod_precision , only : ik => intkind , rk => realkind implicit none private public :: diff public :: diff_periodic public :: ones public :: range public :: tile public :: zeros interface diff module procedure :: diff_1d module procedure :: diff_2d endinterface diff interface diff_periodic module procedure :: diff_periodic_1d module procedure :: diff_periodic_2d endinterface diff_periodic interface ones module procedure :: ones_int module procedure :: ones_real endinterface ones interface range module procedure :: range_int module procedure :: range_real endinterface range interface tile module procedure :: tile_1d_int module procedure :: tile_1d_real module procedure :: tile_2d_int module procedure :: tile_2d_real module procedure :: tile_3d_int module procedure :: tile_3d_real endinterface tile interface zeros module procedure :: zeros_int module procedure :: zeros_real endinterface zeros !=============================================================================== contains !------------------------------------------------------------------------------- pure function diff_1d ( x ) result ( dx ) !! Returns a centered-difference of a 1-d array, with first order !! differencing applied for the boundary points. This procedure is overloaded !! by the generic procedure `diff`. real ( kind = rk ), dimension (:), intent ( in ) :: x !! Input array real ( kind = rk ), dimension (:), allocatable :: dx integer ( kind = ik ) :: idm idm = size ( x ) allocate ( dx ( idm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif dx ( 2 : idm - 1 ) = 0.5_rk * ( x ( 3 : idm ) - x ( 1 : idm - 2 )) dx ( 1 ) = x ( 2 ) - x ( 1 ) dx ( idm ) = x ( idm ) - x ( idm - 1 ) endfunction diff_1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function diff_2d ( x , dim ) result ( dx ) !! Returns a centered-difference of a 2-d array along dimension dim, with !! first order differencing applied for the boundary points. This procedure is !! overloaded by the generic procedure `diff`. real ( kind = rk ), dimension (:,:), intent ( in ) :: x !! Input array integer ( kind = ik ), intent ( in ) :: dim !! Dimension along which to differentiate real ( kind = rk ), dimension (:,:), allocatable :: dx integer ( kind = ik ) :: idm , jdm idm = size ( x , dim = 1 ) jdm = size ( x , dim = 2 ) allocate ( dx ( idm , jdm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif if ( dim == 1 ) then dx ( 2 : idm - 1 ,:) = 0.5_rk * ( x ( 3 : idm ,:) - x ( 1 : idm - 2 ,:)) dx ( 1 ,:) = x ( 2 ,:) - x ( 1 ,:) dx ( idm ,:) = x ( idm ,:) - x ( idm - 1 ,:) elseif ( dim == 2 ) then dx (:, 2 : idm - 1 ) = 0.5_rk * ( x (:, 3 : idm ) - x (:, 1 : idm - 2 )) dx (:, 1 ) = x ( 2 ,:) - x (:, 1 ) dx (:, idm ) = x (:, idm ) - x (:, idm - 1 ) else dx = 0 endif endfunction diff_2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function diff_periodic_1d ( x ) result ( dx ) !! Returns a centered-difference of a 1-d array with periodic boundary !! conditions. This procedure is overloaded by the generic procedure `diff`. real ( kind = rk ), dimension (:), intent ( in ) :: x !! Input array real ( kind = rk ), dimension (:), allocatable :: dx integer ( kind = ik ) :: idm idm = size ( x ) allocate ( dx ( idm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif dx ( 2 : idm - 1 ) = 0.5_rk * ( x ( 3 : idm ) - x ( 1 : idm - 2 )) dx ( 1 ) = 0.5_rk * ( x ( 2 ) - x ( idm )) dx ( idm ) = 0.5_rk * ( x ( 1 ) - x ( idm - 1 )) endfunction diff_periodic_1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function diff_periodic_2d ( x , dim ) result ( dx ) !! Returns a centered-difference of a 2-d array along dimension dim, with !! periodic boundary conditions. This procedure is overloaded by the generic !! procedure `diff`. real ( kind = rk ), dimension (:,:), intent ( in ) :: x !! Input array integer ( kind = ik ), intent ( in ) :: dim !! Dimension along which to differentiate real ( kind = rk ), dimension (:,:), allocatable :: dx integer ( kind = ik ) :: idm , jdm idm = size ( x , dim = 1 ) jdm = size ( x , dim = 2 ) allocate ( dx ( idm , jdm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif if ( dim == 1 ) then dx ( 2 : idm - 1 ,:) = 0.5_rk * ( x ( 3 : idm ,:) - x ( 1 : idm - 2 ,:)) dx ( 1 ,:) = 0.5_rk * ( x ( 2 ,:) - x ( idm ,:)) dx ( idm ,:) = 0.5_rk * ( x ( 1 ,:) - x ( idm - 1 ,:)) elseif ( dim == 2 ) then dx (:, 2 : idm - 1 ) = 0.5_rk * ( x (:, 3 : idm ) - x (:, 1 : idm - 2 )) dx (:, 1 ) = 0.5_rk * ( x (:, 2 ) - x (:, idm )) dx (:, idm ) = 0.5_rk * ( x (:, 1 ) - x (:, idm - 1 )) else dx = 0 endif endfunction diff_periodic_2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function ones_int ( length , kindflag ) result ( ones ) !! Returns a 1-d array of integer ones. This procedure is overloaded by the !! generic procedure `ones`. integer ( kind = ik ), intent ( in ) :: length !! Array length integer ( kind = ik ), intent ( in ) :: kindflag !! Array type integer ( kind = ik ), dimension (:), allocatable :: ones allocate ( ones ( length )) ones = 1 endfunction ones_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function ones_real ( length , kindflag ) result ( ones ) !! Returns a 1-d array of floating-point ones. This procedure is overloaded by !! the generic procedure `ones`. integer ( kind = ik ), intent ( in ) :: length !! Array length real ( kind = rk ), intent ( in ) :: kindflag !! Array type real ( kind = rk ), dimension (:), allocatable :: ones allocate ( ones ( length )) ones = 1._rk endfunction ones_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function range_int ( start , end , increment ) result ( range ) !! Returns an array of integers given start, end, and increment values. If the !! increment argument is not passed, default increment is 1. This procedure is !! overloaded by the generic procedure `range`. integer ( kind = ik ), intent ( in ) :: start !! Start value of the array integer ( kind = ik ), intent ( in ) :: end !! End value of the array integer ( kind = ik ), intent ( in ), optional :: increment !! Array increment integer ( kind = ik ), dimension (:), allocatable :: range integer ( kind = ik ) :: i integer ( kind = ik ) :: increment_ integer ( kind = ik ) :: length if ( present ( increment )) then increment_ = increment else increment_ = 1 endif length = ( end - start ) / increment_ + 1 allocate ( range ( length )) do concurrent ( i = 1 : length ) range ( i ) = start + ( i - 1 ) * increment_ enddo endfunction range_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function range_real ( start , end , increment ) result ( range ) !! Returns an array of reals given start, end, and increment values. If the !! increment argument is not passed, default increment is 1. This procedure is !! overloaded by the generic procedure `range`. real ( kind = rk ), intent ( in ) :: start !! Start value of the array real ( kind = rk ), intent ( in ) :: end !! End value of the array real ( kind = rk ), intent ( in ), optional :: increment !! Array increment real ( kind = rk ), dimension (:), allocatable :: range real ( kind = rk ) :: increment_ integer ( kind = ik ) :: i integer ( kind = ik ) :: length if ( present ( increment )) then increment_ = increment else increment_ = 1 endif length = int (( end - start ) / increment_ ) + 1 allocate ( range ( length )) do concurrent ( i = 1 : length ) range ( i ) = start + ( i - 1 ) * increment_ enddo endfunction range_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_1d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 1-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array ), n )) do concurrent ( i = 1 : n ) tiled_array (:, i ) = array (:) enddo endfunction tile_1d_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_1d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 1-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array ), n )) do concurrent ( i = 1 : n ) tiled_array (:, i ) = array (:) enddo endfunction tile_1d_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_2d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 2-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:, i ) = array (:,:) enddo endfunction tile_2d_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_2d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 2-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:, i ) = array (:,:) enddo endfunction tile_2d_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_3d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 3-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:,:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:,:, i ) = array (:,:,:) enddo endfunction tile_3d_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function tile_3d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 3-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:,:, i ) = array (:,:,:) enddo endfunction tile_3d_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function zeros_int ( length , kindflag ) result ( zeros ) !! Returns a 1-d array of integer zeros. This procedure is overloaded by the !! generic procedure `zeros`. integer ( kind = ik ), intent ( in ) :: length !! Array length integer ( kind = ik ), intent ( in ) :: kindflag !! Array type integer ( kind = ik ), dimension (:), allocatable :: zeros allocate ( zeros ( length )) zeros = 0 endfunction zeros_int !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function zeros_real ( length , kindflag ) result ( zeros ) !! Returns a 1-d array of floating-point zeros. This procedure is overloaded by !! the generic procedure `zeros`. integer ( kind = ik ), intent ( in ) :: length !! Array length real ( kind = rk ), intent ( in ) :: kindflag !! Array type real ( kind = rk ), dimension (:), allocatable :: zeros allocate ( zeros ( length )) zeros = 0._rk endfunction zeros_real !------------------------------------------------------------------------------- endmodule mod_utility","tags":"","loc":"sourcefile/mod_utility.f90.html","title":"mod_utility.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_source_functions.f90~~EfferentGraph sourcefile~mod_source_functions.f90 mod_source_functions.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 sourcefile~mod_const.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_source_functions Source Code mod_source_functions.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_source_functions use mod_precision , only : ik => intkind , rk => realkind implicit none private public :: sin_DCCM2012 public :: sds_DCCM2012 public :: sdt_DCCM2012 public :: sbf_DCCM2012 public :: sbf_JONSWAP public :: snl_DCCM2012 contains !------------------------------------------------------------------------------- pure elemental function sin_DCCM2012 ( spectrum , wspd , wdir , input_height , ustar ,& vonkarman ) result ( tendency ) !! TODO implement currents averaged over the effective depth layer for !! modulation of phase speed. !! Returns a spectrum instance with the wave growth ($S_{in}$) tendency !! formulated by Donelan et al. (2012) and based on the sheltering hypothesis !! by Jeffreys (1924, 1925). !! !! The result instance has the units of 1/s. This source function must be !! re-evaluated if any of the input parameters change. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. !! !! Jeffreys, H., 1924: On the formation of waves by wind, *Proc. R. Soc. A*, !! **107**, 189–206. !! !! Jeffreys, H., 1925: On the formation of waves by wind, II, *Proc. R. Soc. !! A*, **110**, 341–347. use mod_spectrum , only : spectrum_type use mod_aerodynamic_drag , only : windAtReferenceHeight use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Input spectrum instance real ( kind = rk ), intent ( in ) :: wspd !! Input wind speed [m/s] real ( kind = rk ), intent ( in ) :: wdir !! Input wind direction [rad], mathematical convention real ( kind = rk ), intent ( in ) :: input_height !! Height of input wind speed [m/s] real ( kind = rk ), intent ( in ) :: ustar !! Air-side friction velocity [m/s] real ( kind = rk ), intent ( in ) :: vonkarman !! Von Karman constant type ( spectrum_type ) :: tendency real ( kind = rk ), dimension (:,:), allocatable :: s_in real ( kind = rk ), dimension (:), allocatable :: f real ( kind = rk ), dimension (:), allocatable :: th real ( kind = rk ), dimension (:), allocatable :: k real ( kind = rk ), dimension (:), allocatable :: cp real ( kind = rk ), dimension (:), allocatable :: omega real ( kind = rk ), dimension (:), allocatable :: half_wavelength real ( kind = rk ), dimension (:), allocatable :: wspd_input real ( kind = rk ) :: grav real ( kind = rk ) :: rho_air real ( kind = rk ) :: rho_water real ( kind = rk ), parameter :: a1_windsea = 0.11_rk real ( kind = rk ), parameter :: a1_swell = 0.01_rk real ( kind = rk ), parameter :: a1_opposed = 0.10_rk real ( kind = rk ), parameter :: field_scale_negative = a1_opposed / a1_windsea real ( kind = rk ), parameter :: field_scale_swell = a1_swell / a1_opposed real ( kind = rk ), dimension (:,:), allocatable :: sheltering_coefficient integer :: nfreq , nfreqs integer :: ndir , ndirs tendency = spectrum grav = spectrum % getGravity () rho_air = spectrum % getAirDensity () rho_water = spectrum % getWaterDensity () f = spectrum % getFrequency () th = spectrum % getDirections () k = spectrum % getWavenumber () cp = spectrum % getPhaseSpeed () half_wavelength = 0.5_rk * spectrum % getWavelength () omega = twopi * f nfreqs = size ( f ) ndirs = size ( th ) ! Evaluate wind speed at height of half-wavelength of each wave component wspd_input = windAtReferenceHeight ( wspd , input_height , half_wavelength , ustar ,& vonkarman ) allocate ( s_in ( nfreqs , ndirs )) allocate ( sheltering_coefficient ( nfreqs , ndirs )) ! Set the initial sheltering coefficient to a1_windsea everywhere sheltering_coefficient = a1_windsea do concurrent ( nfreq = 1 : nfreqs , ndir = 1 : ndirs ) ! If input is negative, adjust the sheltering coefficient to a1_opposed if ( wspd_input ( nfreq ) * cos ( wdir - th ( ndir )) - cp ( nfreq ) < 0 ) then sheltering_coefficient ( nfreq , ndir ) = sheltering_coefficient ( nfreq , ndir )& * field_scale_negative ! If input is negative but has positive misalignment, adjust the ! sheltering coefficient to a1_swell if ( cos ( wdir - th ( ndir )) > 0 ) then sheltering_coefficient ( nfreq , ndir ) = sheltering_coefficient ( nfreq , ndir )& * field_scale_swell endif endif enddo do concurrent ( ndir = 1 : ndirs ) s_in (:, ndir ) = sheltering_coefficient (:, ndir ) * rho_air / rho_water & * ( wspd_input * cos ( wdir - th ( ndir )) - cp ) * abs ( wspd_input * cos ( wdir - th ( ndir )) - cp )& * omega * k / grav enddo tendency = s_in deallocate ( s_in , sheltering_coefficient ) endfunction sin_DCCM2012 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function sds_DCCM2012 ( spectrum , sds_coefficient , sds_power ,& mss_coefficient ) result ( tendency ) !! Returns a spectrum instance with the wave dissipation ($S_{ds}$) tendency !! formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. This source function must be !! re-evaluated every time the spectrum is updated. !! !! References: !! !! Donelan, M. A., B. K. Haus, W. J. Plant, and O. Troianowski, 2010: !! Modulation of short wind waves by long waves, *J. Geophys. Res. Oceans*, !! **115**, C10003, doi:10.1029/2009JC005794. !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Linear coefficient of the dissipation function real ( kind = rk ), intent ( in ) :: sds_coefficient !! Linear coefficient of the dissipation function real ( kind = rk ), intent ( in ) :: sds_power !! The exponent of the saturation spectrum real ( kind = rk ), intent ( in ) :: mss_coefficient !! Linear coefficient of the mean square slope adjustment to Sds type ( spectrum_type ) :: tendency !! Result tendency instance tendency = sds_coefficient * twopi * spectrum % getFrequency2d ()& * spectrum % saturationSpectrum () ** sds_power & * ( 1 + mss_coefficient * spectrum % meanSquareSlopeDirectional ()) ** 2 endfunction sds_DCCM2012 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function sdt_DCCM2012 ( spectrum , sdt_coefficient , ustar )& result ( tendency ) !! Returns a spectrum instance with the wave dissipation due to turbulence !! ($S_{dt}$) tendency formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. This source function can be !! evaluated once and stored if wavenumber array, air and water densities, and !! friction velocity are held constant. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: sdt_coefficient !! Linear coefficient of the turbulent dissipation function real ( kind = rk ), intent ( in ) :: ustar !! Air-side friction velocity [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance tendency = sdt_coefficient * sqrt ( spectrum % getAirDensity ()& / spectrum % getWaterDensity ()) * ustar * spectrum % getWavenumber2d () endfunction sdt_DCCM2012 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function sbf_DCCM2012 ( spectrum , friction_coefficient ,& percolation_coefficient ) result ( tendency ) !! Returns a spectrum instance with the wave dissipation tendency due to !! bottom friction and percolation, formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. If the mean water depth and !! wavenumber arrays are constant, this source function can be evaluated once !! and stored. Otherwise, the function must be re-evaluated if the mean water !! depth or wavenumber array change. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. !! !! Shemdin, P., K. Hasselmann, S. V. Hsiao, and K. Herterich, 1978: Non-linear !! and linear bottom interaction effects in shallow water, p347-372 in: !! Turbulent fluxes through the sea surface, wave dynamics and prediction, A. !! Favre and K. Hasselmann (eds), Plenum, New York, 677p. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: friction_coefficient !! Bottom friction coefficient [m/s] real ( kind = rk ), intent ( in ) :: percolation_coefficient !! Bottom permeability coefficient [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance real ( kind = rk ) :: d real ( kind = rk ), dimension (:,:), allocatable :: k d = spectrum % getDepth () k = spectrum % getWavenumber2d () tendency = friction_coefficient * k / sinh ( 2 * k * d )& + percolation_coefficient / cosh ( k * d ) ** 2 endfunction sbf_DCCM2012 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function sbf_JONSWAP ( spectrum , friction_coefficient )& result ( tendency ) !! Returns a spectrum instance with the bottom friction ($S_{bot}$) tendency !! based on JONSWAP field data (Hasselmann et al., 1973). It is also the !! default parameterization scheme used in the WAM model (WAMDIG, 1988). !! !! References: !! !! Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell !! decay during the Joint North Sea Wave Project (JONSWAP). *Dtsch. Hydrogh. !! Z.*, Suppl. A, **8**, 12, 95pp. !! !! WAMDI Group, 1988. The WAM model – a third generation ocean wave prediction !!  model. *J. Phys. Oceanogr.*, **18**, 1775–1810. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: friction_coefficient !! Bottom friction coefficient [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance tendency = 2 * friction_coefficient & * ( spectrum % getPhaseSpeed2d () / spectrum % getGroupSpeed2d () - 0.5_rk )& / ( spectrum % getGravity () * spectrum % getDepth ()) endfunction sbf_JONSWAP !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function snl_DCCM2012 ( spectrum , sds_tendency , snl_coefficient )& result ( tendency ) !! Returns a spectrum instance with the non-linear wave-wave energy transfer !! ($S_{nl}$) tendency formulated by Donelan et al. (2012). !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance type ( spectrum_type ), intent ( in ) :: sds_tendency !! Spectral dissipation tendency instance real ( kind = rk ), intent ( in ) :: snl_coefficient !! Linear coefficient of the dissipation function type ( spectrum_type ) :: tendency !! Result tendency instance real ( kind = rk ), dimension (:,:), allocatable :: sds_spectrum real ( kind = rk ), dimension (:,:), allocatable :: s_nl real ( kind = rk ), dimension (:), allocatable :: f real ( kind = rk ), dimension (:), allocatable :: th real ( kind = rk ), dimension (:), allocatable :: k real ( kind = rk ), dimension (:), allocatable :: dk real ( kind = rk ), dimension (:), allocatable :: w1 , w2 real ( kind = rk ) :: bf1 , bf1a , bf2 , dlnf integer :: nfreq , nfreqs integer :: ndir , ndirs f = spectrum % getFrequency () k = spectrum % getWavenumber () dk = spectrum % getWavenumberSpacing () th = spectrum % getDirections () nfreqs = size ( f ) ndirs = size ( th ) tendency = spectrum sds_spectrum = sds_tendency % getSpectrum () * spectrum % getSpectrum () allocate ( s_nl ( nfreqs , ndirs )) s_nl = 0 allocate ( w1 ( nfreqs ), w2 ( nfreqs )) w1 = 0 w2 = 0 dlnf = ( log ( f ( size ( f ))) - log ( f ( 1 ))) / float ( nfreqs - 1 ) bf1 = exp ( - 16 * dlnf ** 2 ) bf2 = exp ( - 64 * dlnf ** 2 ) bf1a = bf1 / ( bf1 + bf2 ) bf2 = bf2 / ( bf1 + bf2 ) bf1 = bf1a do nfreq = 1 , nfreqs - 2 w1 ( nfreq ) = snl_coefficient * bf1 * k ( nfreq + 1 ) * dk ( nfreq + 1 ) / ( k ( nfreq ) * dk ( nfreq )) w2 ( nfreq ) = snl_coefficient * bf2 * k ( nfreq + 2 ) * dk ( nfreq + 2 ) / ( k ( nfreq ) * dk ( nfreq )) enddo do concurrent ( ndir = 1 : ndirs ) do nfreq = 1 , nfreqs - 2 s_nl ( nfreq , ndir ) = w1 ( nfreq ) * sds_spectrum ( nfreq + 1 , ndir )& + w2 ( nfreq ) * sds_spectrum ( nfreq + 2 , ndir )& - snl_coefficient * sds_spectrum ( nfreq , ndir ) enddo enddo tendency = s_nl deallocate ( w1 , w2 , s_nl , sds_spectrum ) endfunction snl_DCCM2012 !------------------------------------------------------------------------------- endmodule mod_source_functions","tags":"","loc":"sourcefile/mod_source_functions.f90.html","title":"mod_source_functions.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_gravity.f90~~EfferentGraph sourcefile~mod_gravity.f90 mod_gravity.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_gravity.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_gravity Source Code mod_gravity.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_gravity use mod_precision , only : rk => realkind implicit none private public :: gravityClairaut public :: gravitational_constant real ( kind = rk ), parameter :: gravitational_constant = 6.67408e-11_rk !=============================================================================== contains !------------------------------------------------------------------------------- pure elemental real ( kind = rk )& function gravityClairaut ( latitude ) result ( grav ) !! Returns the gravitational acceleration at the Earth's surface as function !! of latitude, based on Clairaut's formula. !! !! TODO Reference real ( kind = rk ), intent ( in ) :: latitude !! Latitude [rad] grav = 9.780327_rk * ( 1.0026454_rk & - 0.0026512_rk * cos ( 2 * latitude )& + 0.0000058_rk * cos ( 2 * latitude ) ** 2 ) endfunction gravityClairaut !------------------------------------------------------------------------------- endmodule mod_gravity","tags":"","loc":"sourcefile/mod_gravity.f90.html","title":"mod_gravity.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_time_integration.f90~~EfferentGraph sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_precision.f90->sourcefile~mod_domain.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_precision.f90->sourcefile~mod_grid.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_utility.f90->sourcefile~mod_grid.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_const.f90->sourcefile~mod_domain.f90 sourcefile~mod_grid.f90->sourcefile~mod_domain.f90 var pansourcefilemod_time_integrationf90EfferentGraph = svgPanZoom('#sourcefilemod_time_integrationf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_time_integration Source Code mod_time_integration.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD 3-clause license. See LICENSE for details. module mod_time_integration use mod_precision , only : rk => realkind use mod_spectrum , only : spectrum_type use mod_domain , only : domain_type implicit none private public :: backward_euler public :: exact_exponential public :: forward_euler public :: integrate interface integrate module procedure :: integrate_spectrum module procedure :: integrate_domain endinterface integrate interface exact_exponential module procedure :: exact_exponential_spectrum module procedure :: exact_exponential_domain endinterface exact_exponential interface backward_euler module procedure :: backward_euler_spectrum module procedure :: backward_euler_domain endinterface backward_euler interface forward_euler module procedure :: forward_euler_spectrum module procedure :: forward_euler_domain endinterface forward_euler contains !------------------------------------------------------------------------------- pure type ( spectrum_type ) function integrate_spectrum ( func , initial , tendency , dt ) !! Integrates spectrum forward in time using a time integration method !! provided as the argument `func`. interface pure type ( spectrum_type ) function func ( initial , tendency , dt ) import :: spectrum_type , rk type ( spectrum_type ), intent ( in ) :: initial type ( spectrum_type ), intent ( in ) :: tendency real ( kind = rk ), intent ( in ) :: dt endfunction func endinterface type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] integrate_spectrum = func ( initial , tendency , dt ) endfunction integrate_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( domain_type ) function integrate_domain ( func , initial , tendency , dt ) !! Integrates domain forward in time using a time integration method !! provided as the argument `func`. interface pure type ( domain_type ) function func ( initial , tendency , dt ) import :: domain_type , rk type ( domain_type ), intent ( in ) :: initial type ( domain_type ), intent ( in ) :: tendency real ( kind = rk ), intent ( in ) :: dt endfunction func endinterface type ( domain_type ), intent ( in ) :: initial !! Initial domain instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum domain instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] integrate_domain = func ( initial , tendency , dt ) endfunction integrate_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function backward_euler_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum forward in time using a 1st order implicit backward !! Euler integration scheme. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial / ( - tendency * dt + 1._rk ) endfunction backward_euler_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function backward_euler_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using a 1st order implicit !! backward Euler integration scheme. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial call domain % setSpectrum ( backward_euler ( initial % getSpectrum (),& tendency % getSpectrum (), dt )) endfunction backward_euler_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function exact_exponential_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum instance forward in time using the exact exponential. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial call spec % setSpectrum ( exp ( tendency % getSpectrum () * dt )) !spec = (initial * exp(tendency % getSpectrum() * dt)) spec = initial * spec endfunction exact_exponential_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function exact_exponential_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using the exact exponential. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial domain = exact_exponential ( initial % getSpectrum (),& tendency % getSpectrum (), dt ) endfunction exact_exponential_domain !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function forward_euler_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum forward in time using a 1st order Euler integration !! scheme. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial + tendency * dt endfunction forward_euler_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( domain_type ) function forward_euler_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using a 1st order Euler !! integration scheme. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial domain = forward_euler ( initial % getSpectrum (), tendency % getSpectrum (), dt ) endfunction forward_euler_domain !------------------------------------------------------------------------------- endmodule mod_time_integration","tags":"","loc":"sourcefile/mod_time_integration.f90.html","title":"mod_time_integration.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_nondimensional.f90~~EfferentGraph sourcefile~mod_nondimensional.f90 mod_nondimensional.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_nondimensional.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_nondimensional.f90~~AfferentGraph sourcefile~mod_nondimensional.f90 mod_nondimensional.f90 sourcefile~mod_spectral_shapes.f90 mod_spectral_shapes.f90 sourcefile~mod_nondimensional.f90->sourcefile~mod_spectral_shapes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_nondimensional Source Code mod_nondimensional.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_nondimensional use mod_precision , only : realkind implicit none private public :: nondimensionalDepth public :: nondimensionalEnergy public :: nondimensionalFetch public :: nondimensionalFrequency public :: nondimensionalRoughness_S1974 public :: nondimensionalRoughness_H1986 public :: nondimensionalTime public :: waveAge contains !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function waveAge ( cp , u ) !! Returns wave age, the ratio of phase speed and friction velocity or wind !! speed, depending on the caller's definition of wave age. real ( kind = realkind ), intent ( in ) :: cp !! Phase speed [m/s] real ( kind = realkind ), intent ( in ) :: u !! Friction velocity or wind speed [m/s] waveAge = cp / u endfunction waveAge !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalDepth ( wspd , depth , grav ) !! Returns nondimensional depth based on input wind speed [m/s], mean water !! depth [m], and gravitational acceleration [m/s&#94;2]. real ( kind = realkind ), intent ( in ) :: wspd !! Wind speed at reference height [m/s] real ( kind = realkind ), intent ( in ) :: depth !! Mean water depth [m] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalDepth = grav * depth / wspd ** 2 endfunction nondimensionalDepth !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalEnergy ( wspd , sigma ,& grav ) !! Returns nondimensional energy based on input wind speed, RMS of wave !! variance, and gravitational acceleration. real ( kind = realkind ), intent ( in ) :: wspd !! Wind speed at reference height [m/s] real ( kind = realkind ), intent ( in ) :: sigma !! Root mean square of wave variance real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalEnergy = sigma ** 2 * grav ** 2 / wspd ** 4 endfunction nondimensionalEnergy !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalFetch ( wspd , fetch , grav ) !! Returns nondimensional energy based on input wind speed, RMS of wave !! variance, and gravitational acceleration. real ( kind = realkind ), intent ( in ) :: wspd !! Wind speed at reference height [m/s] real ( kind = realkind ), intent ( in ) :: fetch !! Fetch [m] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalFetch = grav * fetch / wspd ** 2 endfunction nondimensionalFetch !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalFrequency ( wspd , fpeak ,& grav ) !! Returns nondimensional frequency based on input wind speed, peak frequency, !! and gravitational acceleration. real ( kind = realkind ), intent ( in ) :: wspd !! Wind speed at reference height [m/s] real ( kind = realkind ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalFrequency = fpeak * wspd / grav endfunction nondimensionalFrequency !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalRoughness_S1974 ( z0 ,& ustar , grav ) !! Returns the aerodynamic roughness length scaled by friction velocity !! squared and gravitational acceleration, after Stewart (1974). !! !! References: !! !! TODO reference real ( kind = realkind ), intent ( in ) :: z0 !! Roughness length [m] real ( kind = realkind ), intent ( in ) :: ustar !! Friction velocity [m/s] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalRoughness_S1974 = grav * z0 / ustar ** 2 endfunction nondimensionalRoughness_S1974 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalRoughness_H1986 ( z0 , hs ) !! Returns the aerodynamic roughness length scaled by significant wave height, !! after Huang (1986). !! !! TODO reference real ( kind = realkind ), intent ( in ) :: z0 !! Roughness length [m] real ( kind = realkind ), intent ( in ) :: hs !! Significant wave height [m] nondimensionalRoughness_H1986 = z0 / hs endfunction nondimensionalRoughness_H1986 !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = realkind ) function nondimensionalTime ( wspd , time , grav ) !! Returns nondimensional time (duration) based on input wind speed, duration, !! and gravitational acceleration. real ( kind = realkind ), intent ( in ) :: wspd !! Wind speed at reference height [m/s] real ( kind = realkind ), intent ( in ) :: time !! Time [s] real ( kind = realkind ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] nondimensionalTime = grav * time / wspd endfunction nondimensionalTime !------------------------------------------------------------------------------- endmodule mod_nondimensional","tags":"","loc":"sourcefile/mod_nondimensional.f90.html","title":"mod_nondimensional.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_spectrum.f90~~EfferentGraph sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mod_spectrum.f90~~AfferentGraph sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_source_functions.f90 mod_source_functions.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_spectrum Source Code mod_spectrum.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. ! module mod_spectrum use , intrinsic :: iso_c_binding , only : c_int , c_float use mod_precision , only : ik => intkind , rk => realkind use mod_utility , only : diff , diff_periodic use mod_const , only : eps , pi , twopi , stderr , stdout use datetime_module , only : datetime , timedelta use json_module , only : json_core , json_file , json_value implicit none private public :: spectrum_type type :: spectrum_type !! Spectrum class. private type ( datetime ) :: start_time !! Simulation start time type ( datetime ) :: end_time !! Simulation end time type ( timedelta ) :: time_step !! Time step [s] real ( kind = rk ), dimension (:,:), allocatable :: spec !! 2-d spectrum real ( kind = rk ), dimension (:), allocatable :: f !! Frequency [Hz] real ( kind = rk ), dimension (:), allocatable :: df !! Frequency spacing [Hz] real ( kind = rk ), dimension (:), allocatable :: k !! Wavenumber [rad/m] real ( kind = rk ), dimension (:), allocatable :: dk !! Wavenumber spacing [rad/m] real ( kind = rk ), dimension (:), allocatable :: th !! Direction [rad] real ( kind = rk ), dimension (:), allocatable :: dth !! Directional spacing [rad] real ( kind = rk ), dimension (:), allocatable :: cp !! Phase speed [m/s] real ( kind = rk ), dimension (:), allocatable :: cg !! Group speed [m/s] real ( kind = rk ), dimension (:), allocatable :: u !! Mean current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), allocatable :: v !! Mean current velocity in y-direction [m/s] real ( kind = rk ), dimension (:), allocatable :: z !! Depth levels for current array [m] real ( kind = rk ) :: air_density !! Air density [kg/m&#94;3] real ( kind = rk ) :: depth !! Mean water depth [m] real ( kind = rk ) :: elevation !! Mean surface elevation [m] real ( kind = rk ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ) :: surface_tension !! Surface tension [N/m] real ( kind = rk ) :: water_density !! Water density [kg/m&#94;3] contains ! Public type-bound methods procedure , public , pass ( self ) :: frequencyMoment procedure , public , pass ( self ) :: getAirDensity procedure , public , pass ( self ) :: getAmplitude procedure , public , pass ( self ) :: getCurrent_u procedure , public , pass ( self ) :: getCurrent_v procedure , public , pass ( self ) :: getDepth procedure , public , pass ( self ) :: getDepthLevels procedure , public , pass ( self ) :: getDirections procedure , public , pass ( self ) :: getDirections2d procedure , public , pass ( self ) :: getElevation procedure , public , pass ( self ) :: getFrequency procedure , public , pass ( self ) :: getFrequency2d procedure , public , pass ( self ) :: getGravity procedure , public , pass ( self ) :: getGroupSpeed procedure , public , pass ( self ) :: getGroupSpeed2d procedure , public , pass ( self ) :: getWaveAction procedure , public , pass ( self ) :: getWavelength procedure , public , pass ( self ) :: getWavenumber procedure , public , pass ( self ) :: getWavenumberSpacing procedure , public , pass ( self ) :: getWavenumber2d procedure , public , pass ( self ) :: getPhaseSpeed procedure , public , pass ( self ) :: getPhaseSpeed2d procedure , public , pass ( self ) :: getSpectrum procedure , public , pass ( self ) :: getSurfaceTension procedure , public , pass ( self ) :: getWaterDensity procedure , public , pass ( self ) :: isAllocated procedure , public , pass ( self ) :: isMonochromatic procedure , public , pass ( self ) :: isOmnidirectional procedure , public , pass ( self ) :: meanPeriod procedure , public , pass ( self ) :: meanPeriodZeroCrossing procedure , public , pass ( self ) :: meanSquareSlope procedure , public , pass ( self ) :: meanSquareSlopeDirectional procedure , public , pass ( self ) :: momentum_x procedure , public , pass ( self ) :: momentum_y procedure , public , pass ( self ) :: momentumFlux_xx procedure , public , pass ( self ) :: momentumFlux_xy procedure , public , pass ( self ) :: momentumFlux_yy procedure , public , pass ( self ) :: omnidirectionalSpectrum procedure , public , pass ( self ) :: peakedness procedure , public , pass ( self ) :: peakFrequency procedure , public , pass ( self ) :: peakFrequencyDiscrete procedure , public , pass ( self ) :: saturationSpectrum procedure , public , pass ( self ) :: setAirDensity procedure , public , pass ( self ) :: setCurrent1d procedure , public , pass ( self ) :: setCurrent2d procedure , public , pass ( self ) :: setDepth procedure , public , pass ( self ) :: setElevation procedure , public , pass ( self ) :: setGravity procedure , public , pass ( self ) :: setSurfaceTension procedure , public , pass ( self ) :: setWaterDensity procedure , public , pass ( self ) :: setSpectrum1d procedure , public , pass ( self ) :: setSpectrum2d procedure , public , pass ( self ) :: significantWaveHeight procedure , public , pass ( self ) :: significantSurfaceOrbitalVelocity procedure , public , pass ( self ) :: stokesDrift procedure , public , pass ( self ) :: stokesDrift2d procedure , public , pass ( self ) :: ursellNumber procedure , public , pass ( self ) :: wavenumberMoment procedure , public , pass ( self ) :: wavenumberSpectrum procedure , public , pass ( self ) :: readJSON procedure , public , pass ( self ) :: writeJSON ! Private methods used to overload arithmetic operators procedure , private , pass ( self ) :: assign_array_1d procedure , private , pass ( self ) :: assign_array_2d procedure , private , pass ( self ) :: real_add_spectrum procedure , private , pass ( self ) :: real_sub_spectrum procedure , private , pass ( self ) :: real_mult_spectrum procedure , private , pass ( self ) :: real_div_spectrum procedure , private , pass ( self ) :: real2d_mult_spectrum procedure , private , pass ( self ) :: spectrum_add_spectrum procedure , private , pass ( self ) :: spectrum_add_real procedure , private , pass ( self ) :: spectrum_sub_spectrum procedure , private , pass ( self ) :: spectrum_sub_real procedure , private , pass ( self ) :: spectrum_mult_spectrum procedure , private , pass ( self ) :: spectrum_mult_real procedure , private , pass ( self ) :: spectrum_mult_real2d procedure , private , pass ( self ) :: spectrum_div_spectrum procedure , private , pass ( self ) :: spectrum_div_real procedure , private , pass ( self ) :: spectrum_unary_minus procedure , private , pass ( self ) :: eq procedure , private , pass ( self ) :: neq procedure , private , pass ( self ) :: gt procedure , private , pass ( self ) :: ge procedure , private , pass ( self ) :: lt procedure , private , pass ( self ) :: le ! Generic procedures generic , public :: setCurrent => setCurrent1d , setCurrent2d generic , public :: setSpectrum => setSpectrum1d , setSpectrum2d ! Generic operators generic :: assignment ( = ) => assign_array_1d ,& assign_array_2d generic :: operator ( + ) => spectrum_add_spectrum ,& spectrum_add_real ,& real_add_spectrum generic :: operator ( - ) => spectrum_sub_spectrum ,& spectrum_sub_real ,& real_sub_spectrum ,& spectrum_unary_minus generic :: operator ( * ) => spectrum_mult_spectrum ,& spectrum_mult_real ,& spectrum_mult_real2d ,& real_mult_spectrum ,& real2d_mult_spectrum generic :: operator ( / ) => spectrum_div_spectrum ,& spectrum_div_real ,& real_div_spectrum generic :: operator ( == ) => eq generic :: operator ( /= ) => neq generic :: operator ( > ) => gt generic :: operator ( >= ) => ge generic :: operator ( < ) => lt generic :: operator ( <= ) => le endtype spectrum_type interface spectrum_type module procedure :: constructor endinterface spectrum_type contains !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function constructor ( fmin , fmax , df , ndirs ,& depth , grav , air_density , water_density , surface_tension ) result ( spectrum ) !! Constructor function for the spectrum object. real ( kind = rk ), intent ( in ) :: fmin !! Minimum frequency bin [Hz] real ( kind = rk ), intent ( in ) :: fmax !! Maximum frequency bin [Hz] real ( kind = rk ), intent ( in ) :: df !! Frequency increment, df = f(n+1)/f(n) integer , intent ( in ) :: ndirs !! Number of directional bins real ( kind = rk ), intent ( in ) :: depth !! Mean water depth [m] real ( kind = rk ), intent ( in ), optional :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), intent ( in ), optional :: air_density !! Air density [kg/m&#94;3] real ( kind = rk ), intent ( in ), optional :: water_density !! Water density [kg/m&#94;3] real ( kind = rk ), intent ( in ), optional :: surface_tension !! Surface tension [N/m] integer :: n integer :: nfreqs if ( present ( grav )) then spectrum % grav = grav else spectrum % grav = 9.8_rk endif if ( present ( air_density )) then spectrum % air_density = air_density else spectrum % air_density = 1.2_rk endif if ( present ( water_density )) then spectrum % water_density = water_density else spectrum % water_density = 1 e3_rk endif if ( present ( surface_tension )) then spectrum % surface_tension = surface_tension else spectrum % surface_tension = 0.07_rk endif spectrum % depth = depth if ( fmin == fmax ) then !! monochromatic nfreqs = 1 else nfreqs = int (( log ( fmax ) - log ( fmin )) / log ( df )) endif allocate ( spectrum % spec ( nfreqs , ndirs )) spectrum % spec = 0 allocate ( spectrum % f ( nfreqs )) allocate ( spectrum % df ( nfreqs )) allocate ( spectrum % k ( nfreqs )) allocate ( spectrum % dk ( nfreqs )) allocate ( spectrum % cp ( nfreqs )) allocate ( spectrum % cg ( nfreqs )) allocate ( spectrum % th ( ndirs )) if ( nfreqs == 1 ) then spectrum % f ( n ) = fmin else do concurrent ( n = 1 : nfreqs ) spectrum % f ( n ) = exp ( log ( fmin ) + ( n - 1 ) * log ( df )) enddo endif do concurrent ( n = 1 : nfreqs ) spectrum % k ( n ) = wavenumber ( spectrum % f ( n ), & spectrum % depth , & spectrum % water_density ,& spectrum % grav , & spectrum % surface_tension ) enddo spectrum % cp = twopi * spectrum % f / spectrum % k spectrum % cg = twopi * diff ( spectrum % f ) / diff ( spectrum % k ) do concurrent ( n = 1 : ndirs ) spectrum % th ( n ) = ( n - 0.5 * ( ndirs + 1 )) * twopi / ndirs enddo spectrum % df = diff ( spectrum % f ) spectrum % dk = diff ( spectrum % k ) if ( ndirs > 1 ) then spectrum % dth = diff_periodic ( spectrum % th ) spectrum % dth ( 1 ) = spectrum % dth ( 2 ) spectrum % dth ( ndirs ) = spectrum % dth ( ndirs - 1 ) else spectrum % dth = [ 1 ] endif call spectrum % setCurrent2d ([ 0._rk ],[ 0._rk ],[ 0._rk ]) endfunction constructor !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getAirDensity ( self ) result ( air_density ) !! Returns the air_density [kg/m&#94;3] of the `spectrum` instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: air_density !! Air density [kg/m&#94;3] air_density = self % air_density endfunction getAirDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function isAllocated ( self ) !! Returns the allocation status of the spectrum array. class ( spectrum_type ), intent ( in ) :: self !! `domain` instance isAllocated = allocated ( self % spec ) endfunction isAllocated !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function isMonochromatic ( self ) !! Returns `.true.` if only one frequency bin is allocated, !! and `.false.` otherwise. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance logical :: isMonochromatic !! return value (boolean) if ( size ( self % f ) == 1 ) then isMonochromatic = . true . else isMonochromatic = . false . endif endfunction isMonochromatic !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function isOmnidirectional ( self ) !! Returns `.true.` if only one direction bin is allocated, !! and `.false.` otherwise. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance logical :: isOmnidirectional !! return value (boolean) if ( size ( self % th ) == 1 ) then isOmnidirectional = . true . else isOmnidirectional = . false . endif endfunction isOmnidirectional !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getFrequency ( self ) result ( f ) !! Returns the frequency [Hz] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: f !! Frequency [Hz] f = self % f endfunction getFrequency !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getFrequency2d ( self ) result ( f ) !! Returns the frequency [Hz] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: f !! Frequency [Hz] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( f ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) f (:, ndir ) = self % f enddo endfunction getFrequency2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWavenumber ( self ) result ( k ) !! Returns the wavenumber [rad/m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: k !! Wavenumber [rad/m] k = self % k endfunction getWavenumber !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWavenumberSpacing ( self ) result ( dk ) !! Returns the wavenumber spacing [rad/m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: dk !! Wavenumber spacing [rad/m] dk = self % dk endfunction getWavenumberSpacing !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWavenumber2d ( self ) result ( k ) !! Returns the wavenumber [rad/m] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: k !! Wavenumber [rad/m] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( k ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) k (:, ndir ) = self % k enddo endfunction getWavenumber2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWavelength ( self ) result ( lambda ) !! Returns the wavelength [m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: lambda !! Wavelength [m] lambda = twopi / self % k endfunction getWavelength !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getDirections ( self ) result ( th ) !! Returns the directions [rad] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: th !! Directions [rad] th = self % th endfunction getDirections !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getDirections2d ( self ) result ( th ) !! Returns the directions [rad] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: th !! Directions [rad] integer :: ndirs , nfreqs integer :: nfreq nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( th ( nfreqs , ndirs )) do concurrent ( nfreq = 1 : nfreqs ) th ( nfreq ,:) = self % th enddo endfunction getDirections2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getPhaseSpeed ( self ) result ( cp ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: cp !! Phase speed [m/s] cp = self % cp endfunction getPhaseSpeed !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getPhaseSpeed2d ( self ) result ( cp ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: cp !! Phase speed [m/s] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( cp ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) cp (:, ndir ) = self % cp enddo endfunction getPhaseSpeed2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGroupSpeed ( self ) result ( cg ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: cg !! Group speed [m/s] cg = self % cg endfunction getGroupSpeed !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getGroupSpeed2d ( self ) result ( cg ) !! Returns the group speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: cg !! Group speed [m/s] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( cg ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) cg (:, ndir ) = self % cg enddo endfunction getGroupSpeed2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getSpectrum ( self ) result ( spec ) !! Returns the spectrum array. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: spec !! Spectrum array spec = self % spec endfunction getSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getWaveAction ( self ) result ( wave_action ) !! Returns the wave action spectrum, which corresponds to the the wave !! variance spectrum normalized by the intrinsic frequency. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: wave_action !! Wave action array wave_action = self % spec / self % getFrequency2d () endfunction getWaveAction !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getAmplitude ( self ) result ( a ) !! Returns the amplitude array. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: a !! Amplitude [m] integer :: ndir , ndirs if ( self % isMonochromatic ()) then a = sqrt ( 2 * self % spec ) else ndirs = size ( self % getDirections ()) do concurrent ( ndir = 1 : ndirs ) a (:, ndir ) = sqrt ( 2 * self % spec (:, ndir ) * self % df ) enddo endif endfunction getAmplitude !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getCurrent_u ( self ) result ( u ) !! Returns the current velocity in x-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: u !! Mean current velocity in x-direction [m/s] u = self % u endfunction getCurrent_u !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getCurrent_v ( self ) result ( v ) !! Returns the current velocity in y-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: v !! Mean current velocity in y-direction [m/s] v = self % v endfunction getCurrent_v !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function getDepthLevels ( self ) result ( z ) !! Returns the depth levels at which the current arrays are defined. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: z !! Depth levels of current fields [m] z = self % z endfunction getDepthLevels !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getDepth ( self ) result ( depth ) !! Returns the mean water depth [m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: depth !! Mean water depth [m] depth = self % depth endfunction getDepth !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getElevation ( self ) result ( elevation ) !! Returns the mean surface elevation anomaly [m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: elevation !! Mean surface elevation anomaly [m] elevation = self % elevation endfunction getElevation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getGravity ( self ) result ( grav ) !! Returns the gravitational acceleration [m/s&#94;2]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: grav !! Gravitational acceleration [m/s&#94;2] grav = self % grav endfunction getGravity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getSurfaceTension ( self ) result ( surface_tension ) !! Returns the surface tension [N/m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: surface_tension !! Surface tension [N/m] surface_tension = self % surface_tension endfunction getSurfaceTension !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function getWaterDensity ( self ) result ( water_density ) !! Returns the water density [kg/m&#94;3]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: water_density !! Water density [kg/m&#94;3] water_density = self % water_density endfunction getWaterDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function omnidirectionalSpectrum ( self ) result ( spec ) !! Returns the omnidirectional spectrum that corresponds to the input !! directional spectrum, integrated over all directions. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: spec !! Spectrum array integer ( kind = ik ) :: ndir , ndirs , nfreqs nfreqs = size ( self % spec , dim = 1 ) ndirs = size ( self % spec , dim = 2 ) allocate ( spec ( nfreqs )) spec = 0 do ndir = 1 , ndirs spec (:) = spec (:) + self % spec (:, ndir ) * self % dth ( ndir ) enddo endfunction omnidirectionalSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrum1d ( self , spec ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: spec !! Input 1-d spectrum array self % spec (:, 1 ) = spec endsubroutine setSpectrum1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setSpectrum2d ( self , spec ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), intent ( in ) :: spec !! Input 2-d spectrum array self % spec = spec endsubroutine setSpectrum2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setCurrent1d ( self , u , z ) !! Sets the 1-d current velocity field. This procedure is overloaded by the !! generic procedure setCurrent. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: u !! Current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: z !! Depth levels for the velocity array [m] self % u = u self % z = z allocate ( self % v ( size ( u ))) self % v = 0 endsubroutine setCurrent1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine setCurrent2d ( self , u , v , z ) !! Sets the 2-d current velocity field. This procedure is overloaded by the !! generic procedure setCurrent. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: u !! Current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: v !! Current velocity in y-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: z !! Depth levels for the velocity array [m] self % u = u self % v = v self % z = z endsubroutine setCurrent2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setDepth ( self , depth ) !! Sets the mean surface elevation value. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: depth !! Mean water depth [m] self % depth = depth endsubroutine setDepth !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setElevation ( self , elevation ) !! Sets the mean surface elevation value. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: elevation !! Mean surface elevation anomaly [m] self % elevation = elevation endsubroutine setElevation !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setGravity ( self , grav ) !! Sets the gravitational acceleration [m/s&#94;2]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] self % grav = grav endsubroutine setGravity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setSurfaceTension ( self , surface_tension ) !! Sets the surface tension [N/m]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: surface_tension !! Surface tension [N/m] self % surface_tension = surface_tension endsubroutine setSurfaceTension !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setAirDensity ( self , air_density ) !! Sets the air density [kg/m&#94;3]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: air_density !! Air density [kg/m&#94;3] self % air_density = air_density endsubroutine setAirDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental subroutine setWaterDensity ( self , water_density ) !! Sets the water density [kg/m&#94;3]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: water_density !! Water density [kg/m&#94;3] self % water_density = water_density endsubroutine setWaterDensity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function meanSquareSlope ( self ) !! Returns the mean square slope of the spectrum, which is the second !! moment of the wavenumber spectrum. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance meanSquareSlope = self % wavenumberMoment ( 2 ) endfunction meanSquareSlope !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function meanSquareSlopeDirectional ( self ) result ( mss ) !! For each directional frequency bin, computes the mean square slope of all !! all waves longer than that bin, projected to the direction of that bin. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: mss !! Directional mean square slope real ( kind = rk ), dimension (:,:), allocatable :: wavenumber_spectrum real ( kind = rk ), dimension (:,:), allocatable :: dir_projection integer :: nfreq , nfreqs integer :: ndir , ndirs nfreqs = size ( self % f ) ndirs = size ( self % th ) wavenumber_spectrum = self % wavenumberSpectrum () ! Compute projection of each wave direction onto every other direction allocate ( dir_projection ( ndirs , ndirs )) do concurrent ( ndir = 1 : ndirs ) dir_projection (:, ndir ) = abs ( cos ( self % th ( ndir ) - self % th (:))) enddo allocate ( mss ( nfreqs , ndirs )) mss = 0 do ndir = 1 , ndirs do nfreq = 2 , nfreqs mss ( nfreq , ndir ) = mss ( nfreq - 1 , ndir ) & + sum ( wavenumber_spectrum ( nfreq - 1 ,:) * dir_projection (:, ndir ))& * self % k ( nfreq - 1 ) ** 2 * self % dk ( nfreq - 1 ) enddo enddo deallocate ( dir_projection , wavenumber_spectrum ) endfunction meanSquareSlopeDirectional !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function momentum_x ( self ) !! Returns total wave momentum [kg/m/s] in x-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ) :: n integer ( kind = ik ) :: nfreqs nfreqs = size ( self % f ) momentum_x = 0 do n = 1 , nfreqs momentum_x = momentum_x + sum ( self % spec ( n ,:) * self % dth * cos ( self % th ))& * self % df ( n ) / self % cp ( n ) enddo momentum_x = momentum_x * self % water_density * self % grav endfunction momentum_x !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function momentum_y ( self ) !! Returns total wave momentum [kg/m/s] in y-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ) :: n integer ( kind = ik ) :: nfreqs nfreqs = size ( self % f ) momentum_y = 0 do n = 1 , nfreqs momentum_y = momentum_y + sum ( self % spec ( n ,:) * self % dth * sin ( self % th ))& * self % df ( n ) / self % cp ( n ) enddo momentum_y = momentum_y * self % water_density * self % grav endfunction momentum_y !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function momentumFlux_xx ( self ) !! Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in !! y-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ) :: n integer ( kind = ik ) :: nfreqs nfreqs = size ( self % f ) momentumFlux_xx = 0 do n = 1 , nfreqs momentumFlux_xx = momentumFlux_xx & + sum ( self % spec ( n ,:) * self % dth * cos ( self % th ) ** 2 )& * self % df ( n ) * self % cg ( n ) / self % cp ( n ) enddo momentumFlux_xx = momentumFlux_xx * self % water_density * self % grav endfunction momentumFlux_xx !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function momentumFlux_xy ( self ) !! Returns total advective flux [kg/m&#94;2/s&#94;2] in x-direction of momentum in !! y-direction and vice versa (flux in y-direction of momentum in !! y-direction), because \\int{Cgx*My} == \\int{Cgy*Mx}. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ) :: n integer ( kind = ik ) :: nfreqs nfreqs = size ( self % f ) momentumFlux_xy = 0 do n = 1 , nfreqs momentumFlux_xy = momentumFlux_xy & + sum ( self % spec ( n ,:) * self % dth * cos ( self % th ) * sin ( self % th ))& * self % df ( n ) * self % cg ( n ) / self % cp ( n ) enddo momentumFlux_xy = momentumFlux_xy * self % water_density * self % grav endfunction momentumFlux_xy !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function momentumFlux_yy ( self ) !! Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in !! y-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ) :: n integer ( kind = ik ) :: nfreqs nfreqs = size ( self % f ) momentumFlux_yy = 0 do n = 1 , nfreqs momentumFlux_yy = momentumFlux_yy & + sum ( self % spec ( n ,:) * self % dth * sin ( self % th ) ** 2 )& * self % df ( n ) * self % cg ( n ) / self % cp ( n ) enddo momentumFlux_yy = momentumFlux_yy * self % water_density * self % grav endfunction momentumFlux_yy !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function frequencyMoment ( self , n ) !! Returns the spectral frequency moment of order n. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer , intent ( in ) :: n !! Moment order !frequencyMoment = sum(self % f**n*sum(self % spec,dim=2)*self % df) frequencyMoment = sum ( self % f ** n * self % omnidirectionalSpectrum () * self % df ) endfunction frequencyMoment !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function peakedness ( self ) !! Returns the peakedness parameter that quantifies the sharpness of the !! spectral peak, following Goda (1970). !! !! References: !! !! Goda, Y., 1970. Numerical experiments on waves statistics with spectral !! simulation. *Report. Port and Harbour Research Institute*, Japan, **9**, !! 3-57. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance peakedness = 2 * sum ( self % f * self % omnidirectionalSpectrum () ** 2 * self % df )& / ( self % frequencyMoment ( 0 ) ** 2 + eps ) endfunction peakedness !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function peakFrequency ( self ) !! Returns the peak frequency based on Young (1995). !! !! References: !! !! Young, I, 1995. The determination of confidence limits associated with !! estimates of the spectral peak frequency. *Ocean Engng.*, **22**, 669-686. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance peakFrequency = sum ( self % f * self % omnidirectionalSpectrum () ** 4 * self % df )& / ( sum ( self % omnidirectionalSpectrum () ** 4 * self % df ) + eps ) endfunction peakFrequency !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function peakFrequencyDiscrete ( self ) !! Returns the peak frequency based on simple discrete maximum location of !! the spectrum array. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance peakFrequencyDiscrete = & self % f ( maxloc ( self % omnidirectionalSpectrum (), dim = 1 )) endfunction peakFrequencyDiscrete !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function wavenumberMoment ( self , n ) !! Returns the spectral wavenumber moment of order n. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance integer , intent ( in ) :: n !! Moment order wavenumberMoment = sum ( self % k ** n * sum ( self % wavenumberSpectrum (), dim = 2 )& * self % dk ) endfunction wavenumberMoment !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function wavenumberSpectrum ( self ) result ( spec ) !! Returns the wavenumber spectrum array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: spec !! Spectrum array integer :: nfreq , nfreqs integer :: ndirs nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( spec ( nfreqs , ndirs )) do concurrent ( nfreq = 1 : nfreqs ) spec ( nfreq ,:) = self % spec ( nfreq ,:) * self % cg ( nfreq ) / twopi enddo endfunction wavenumberSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function saturationSpectrum ( self ) !! Returns the saturation spectrum B(k) = F(k)k&#94;4. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: saturationSpectrum !! Saturation spectrum result real ( kind = rk ), dimension (:,:), allocatable :: wavenumber_spectrum integer :: nfreqs , ndirs integer :: n nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( saturationSpectrum ( nfreqs , ndirs )) wavenumber_spectrum = self % wavenumberSpectrum () do concurrent ( n = 1 : ndirs ) saturationSpectrum (:, n ) = wavenumber_spectrum (:, n ) * self % k ** 4 enddo endfunction saturationSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function significantWaveHeight ( self ) !! Returns the significant wave height [m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance significantWaveHeight = 4 * sqrt ( self % frequencyMoment ( 0 )) endfunction significantWaveHeight !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function & significantSurfaceOrbitalVelocity ( self ) result ( uorb ) !! Returns the significant surface orbital velocity [m/s]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance uorb = 2 * sqrt ( sum (( twopi * self % f ) ** 2 * sum ( self % spec , dim = 2 ) * self % df )) endfunction significantSurfaceOrbitalVelocity !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function stokesDrift ( self , z ) !! Exact solution of Stokes drift based on linear wave theory, given input !! omnidirectional spectrum and distance from surface `z` [m], negative !! downward. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: z !! Distance from surface [m], negative downward real ( kind = rk ), dimension (:), allocatable :: stokesDrift !! Stokes drift array [m/s] integer ( kind = ik ) :: n allocate ( stokesDrift ( size ( z ))) do concurrent ( n = 1 : size ( z )) stokesDrift ( n ) = sum ( self % omnidirectionalSpectrum () * self % k & * exp ( 2 * self % k * z ( n )) * self % df ) enddo endfunction stokesDrift !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function stokesDrift2d ( self , z ) !! Exact solution of Stokes drift based on linear wave theory, given input !! directional spectrum and distance from surface `z` [m], negative downward. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: z !! Distance from surface [m], negative downward real ( kind = rk ), dimension (:,:), allocatable :: stokesDrift2d !! Stokes drift array [m/s] integer ( kind = ik ) :: n , ndir , ndirs ndirs = size ( self % getDirections ()) allocate ( stokesDrift2d ( size ( z ), 2 )) stokesDrift2d = 0 do n = 1 , size ( z ) stokesDrift2d ( n ,:) = 0 do ndir = 1 , ndirs ! x-component of Stokes drift stokesDrift2d ( n , 1 ) = stokesDrift2d ( n , 1 )& + sum ( self % spec (:, ndir ) * cos ( self % th ( ndir ))& * self % k * exp ( 2 * self % k * z ( n ))& * self % df * self % dth ( ndir )) ! y-component of Stokes drift stokesDrift2d ( n , 2 ) = stokesDrift2d ( n , 2 )& + sum ( self % spec (:, ndir ) * sin ( self % th ( ndir ))& * self % k * exp ( 2 * self % k * z ( n ))& * self % df * self % dth ( ndir )) enddo enddo endfunction stokesDrift2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function meanPeriod ( self ) !! Returns the mean wave period [s]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance meanPeriod = self % frequencyMoment ( 0 ) / ( self % frequencyMoment ( 1 ) + eps ) endfunction meanPeriod !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function meanPeriodZeroCrossing ( self ) !! Returns the zero-crossing mean wave period [s]: !! !! Tm02 = \\sqrt(m_0 / m_2) class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance meanPeriodZeroCrossing = sqrt ( self % frequencyMoment ( 0 )& / ( self % frequencyMoment ( 2 ) + eps )) endfunction meanPeriodZeroCrossing !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function ursellNumber ( self ) !! Returns the Ursell number. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance ursellNumber = self % grav / ( 8 * sqrt ( 2._rk ) * pi ** 2 ) & * self % significantWaveHeight () * self % meanPeriod () ** 2 & / self % depth ** 2 endfunction ursellNumber !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine assign_array_1d ( self , array ) !! Assigns a 1-d array of reals to a `spectrum` instance. This procedure !! overloads the assignment ('=') operator. class ( spectrum_type ), intent ( inout ) :: self !! l.h.s. `spectrum` instance real ( kind = rk ), dimension (:), intent ( in ) :: array !! r.h.s. array of reals call self % setSpectrum ( array ) endsubroutine assign_array_1d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure subroutine assign_array_2d ( self , array ) !! Assigns a 2-d array of reals to a `spectrum` instance. This procedure !! overloads the assignment ('=') operator. class ( spectrum_type ), intent ( inout ) :: self !! l.h.s. `spectrum` instance real ( kind = rk ), dimension (:,:), intent ( in ) :: array !! r.h.s. array of reals call self % setSpectrum ( array ) endsubroutine assign_array_2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function eq ( self , s2 ) !! Logical equality comparison function. Overloads the `==` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance eq = all ( self % getSpectrum () == s2 % getSpectrum ()) endfunction eq !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function neq ( self , s2 ) !! Logical inequality comparison function. Overloads the `/=` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance neq = . not . self == s2 endfunction neq !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function gt ( self , s2 ) !! Logical greater than comparison function. Overloads the `>` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance gt = all ( self % getSpectrum () > s2 % getSpectrum ()) endfunction gt !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function lt ( self , s2 ) !! Logical less than comparison function. Overloads the `<` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance lt = all ( self % getSpectrum () < s2 % getSpectrum ()) endfunction lt !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function ge ( self , s2 ) !! Logical greater than or equal comparison function. Overloads the `>=` !! operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance ge = all ( self % getSpectrum () >= s2 % getSpectrum ()) endfunction ge !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental logical function le ( self , s2 ) !! Logical less than or equal comparison function. Overloads the `<=` !! operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance le = all ( self % getSpectrum () <= s2 % getSpectrum ()) endfunction le !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_add_spectrum ( self , s2 )& result ( spec ) !! Returns a spectrum instance with the spectrum array values being the sum of !! the two input spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () + s2 % getSpectrum () endfunction spectrum_add_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_sub_spectrum ( self , s2 )& result ( spec ) !! Subtracts one spectrum instance from another and returns the resulting !! spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () - s2 % getSpectrum () endfunction spectrum_sub_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_mult_spectrum ( self , s2 )& result ( spec ) !! Returns a product of two spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * s2 % getSpectrum () endfunction spectrum_mult_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_div_spectrum ( self , s2 )& result ( spec ) !! Returns a division of two spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () / s2 % getSpectrum () endfunction spectrum_div_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_add_real ( self , a )& result ( spec ) !! Returns a sum of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () + a endfunction spectrum_add_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_sub_real ( self , a )& result ( spec ) !! Returns a difference of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () - a endfunction spectrum_sub_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_mult_real ( self , a )& result ( spec ) !! Returns a product of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () * a endfunction spectrum_mult_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( spectrum_type ) function spectrum_mult_real2d ( self , a )& result ( spec ) !! Returns a product of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), dimension (:,:), intent ( in ) :: a !! r.h.s. real 2-d array spec = self spec = self % getSpectrum () * a endfunction spectrum_mult_real2d !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_div_real ( self , a ) result ( spec ) !! Returns a division of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () / a endfunction spectrum_div_real !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function real_add_spectrum ( a , self )& result ( spec ) !! Returns a sum of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () + a endfunction real_add_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function real_sub_spectrum ( a , self )& result ( spec ) !! Returns a difference between a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = a - self % getSpectrum () endfunction real_sub_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function real_mult_spectrum ( a , self )& result ( spec ) !! Returns a product of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * a endfunction real_mult_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure type ( spectrum_type ) function real2d_mult_spectrum ( a , self )& result ( spec ) !! Returns a product of a real number and a spectrum instance. real ( kind = rk ), dimension (:,:), intent ( in ) :: a !! l.h.s. real 2-d array class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * a endfunction real2d_mult_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function real_div_spectrum ( a , self ) result ( spec ) !! Returns a division of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = a / self % getSpectrum () endfunction real_div_spectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental type ( spectrum_type ) function spectrum_unary_minus ( self )& result ( spec ) !! Returns a negative value of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = - self % getSpectrum () endfunction spectrum_unary_minus !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental function wavenumber ( f , depth , water_density , grav , surface_tension ) !! Solves the linear water wave dispersion relationship using a !! Newton-Raphson iteration loop. real ( kind = rk ), intent ( in ) :: f !! Intrinsic frequency [Hz] real ( kind = rk ), optional , intent ( in ) :: depth !! Mean water depth [m] real ( kind = rk ), optional , intent ( in ) :: water_density !! Water density [kg/m&#94;3] real ( kind = rk ), optional , intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), optional , intent ( in ) :: surface_tension !! Surface tension [N/m] real ( kind = rk ) :: wavenumber , dk , b , fnd , t integer :: counter associate ( k => wavenumber ) fnd = twopi * f * sqrt ( depth / grav ) k = fnd ** 2 b = surface_tension / ( water_density * grav * depth ** 2 ) counter = 1 dk = 2 e - 3_rk newton_raphson : do t = tanh ( k ) dk = - ( fnd ** 2 - k * t * ( 1 + b * k ** 2 ))& / ( 3 * b * k ** 2 * t + t + k * ( 1 + b * k ** 2 ) * ( 1 - t ** 2 )) k = k - dk if ( abs ( dk ) < eps . or . counter > 100 ) then exit newton_raphson endif counter = counter + 1 enddo newton_raphson k = k / depth endassociate endfunction wavenumber !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- subroutine readJSON ( self , filename ) !! Read a spectrum instance from a JSON file. class ( spectrum_type ), intent ( inout ) :: self !! `spectrum` instance character ( len =* ), intent ( in ) :: filename !! JSON file name type ( json_file ) :: json logical :: found integer ( kind = ik ) :: nfreqs integer ( kind = ik ) :: ndirs real ( kind = rk ), dimension (:), allocatable :: arr call json % initialize () call json % load_file ( trim ( filename )) call json % get ( 'frequency' , self % f , found ) call json % get ( 'wavenumber' , self % k , found ) call json % get ( 'directions' , self % th , found ) call json % get ( 'spectrum' , arr , found ) nfreqs = size ( self % f ) ndirs = size ( self % th ) self % spec = reshape ( arr ,[ nfreqs , ndirs ]) call json % get ( 'depth' , self % depth , found ) call json % get ( 'elevation' , self % elevation , found ) call json % get ( 'gravity' , self % grav , found ) call json % get ( 'air_density' , self % air_density , found ) call json % get ( 'water_density' , self % water_density , found ) call json % get ( 'surface_tension' , self % surface_tension , found ) call json % get ( 'u-velocity' , self % u , found ) call json % get ( 'v-velocity' , self % v , found ) call json % get ( 'z' , self % z , found ) call json % destroy () self % df = diff ( self % f ) self % dk = diff ( self % k ) if ( ndirs > 1 ) then self % dth = diff_periodic ( self % th ) else self % dth = [ 1 ] endif self % cp = twopi * self % f / self % k self % cg = twopi * self % df / self % dk endsubroutine readJSON !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- subroutine writeJSON ( self , filename , minify ) !! Writes a spectrum instance to a JSON file. class ( spectrum_type ), intent ( in ) :: self !! `spectrum` instance character ( len =* ), intent ( in ) :: filename !! JSON file name logical , intent ( in ) :: minify !! Logical switch to minify the JSON file type ( json_core ) :: json type ( json_value ), pointer :: ptr call json % initialize ( no_whitespace = minify , real_format = 'ES' ) call json % create_object ( ptr , '' ) call json % add ( ptr , 'frequency' , self % getFrequency ()) call json % add ( ptr , 'wavenumber' , self % getWavenumber ()) call json % add ( ptr , 'directions' , self % getDirections ()) call json % add ( ptr , 'spectrum' , pack ( self % getSpectrum (),. true .)) call json % add ( ptr , 'depth' , self % getDepth ()) call json % add ( ptr , 'elevation' , self % getElevation ()) call json % add ( ptr , 'gravity' , self % getGravity ()) call json % add ( ptr , 'air_density' , self % getAirDensity ()) call json % add ( ptr , 'water_density' , self % getWaterDensity ()) call json % add ( ptr , 'surface_tension' , self % getSurfaceTension ()) call json % add ( ptr , 'u-velocity' , self % getCurrent_u ()) call json % add ( ptr , 'v-velocity' , self % getCurrent_v ()) call json % add ( ptr , 'z' , self % getDepthLevels ()) call json % print ( ptr , trim ( filename )) call json % destroy ( ptr ) endsubroutine writeJSON !------------------------------------------------------------------------------- endmodule mod_spectrum","tags":"","loc":"sourcefile/mod_spectrum.f90.html","title":"mod_spectrum.f90 – wavy"},{"text":"This File Depends On sourcefile~~mod_spectral_shapes.f90~~EfferentGraph sourcefile~mod_spectral_shapes.f90 mod_spectral_shapes.f90 sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectral_shapes.f90 sourcefile~mod_nondimensional.f90 mod_nondimensional.f90 sourcefile~mod_precision.f90->sourcefile~mod_nondimensional.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_nondimensional.f90->sourcefile~mod_spectral_shapes.f90 sourcefile~mod_const.f90->sourcefile~mod_spectral_shapes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_spectral_shapes Source Code mod_spectral_shapes.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_spectral_shapes use mod_precision , only : ik => intkind , rk => realkind use mod_const , only : twopi use mod_nondimensional , only : nondimensionalFetch , nondimensionalFrequency implicit none private public :: donelanHamiltonHui public :: donelanHamiltonHuiDirectionalSpreading public :: donelanHamiltonHuiDirectionalSpectrum public :: jonswap public :: jonswapPeakFrequency public :: piersonMoskowitz public :: piersonMoskowitzPeakFrequency public :: phillips !=============================================================================== contains !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function donelanHamiltonHui ( f , fpeak , wspd , grav )& result ( spec ) !! The omnidirectional spectrum function based on the laboratory and field !! measurements by Donelan, Hamilton, and Hui (1985). !! !! References: !! !! Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional !! spectra of wind-generated waves. Phil. Trans. Royal Soc. London A., !! 315, 509-562. real ( kind = rk ), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ) :: beta real ( kind = rk ) :: gamma ! Peak enhancement factor real ( kind = rk ) :: nu ! Nondimensional frequency real ( kind = rk ) :: r ! Exponent in peak enhancement factor real ( kind = rk ) :: omega ! Radian frequency [rad/s] real ( kind = rk ) :: sigma ! Spread of the spectrum peak omega = twopi * f nu = nondimensionalFrequency ( wspd , fpeak , grav ) if ( nu >= 0.159_rk ) then gamma = 6.489_rk + 6 * log10 ( nu ) if ( gamma < 0 ) gamma = 0 else gamma = 1.7_rk endif sigma = 0.08_rk + 1.29e-3_rk * nu ** ( - 3 ) r = exp ( - 0.5_rk * (( f - fpeak ) / ( sigma * fpeak )) ** 2 ) beta = 0.0165_rk * nu ** 0.55_rk spec = twopi * beta * grav ** 2 / omega ** 4 / fpeak * exp ( - ( fpeak / f ) ** 4 ) * gamma ** r endfunction donelanHamiltonHui !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function donelanHamiltonHuiDirectionalSpreading ( f ,& wspd , fpeak , theta , theta_mean ) result ( spreading ) !! Directional spreading function based on the laboratory and field !! measurements by Donelan, Hamilton, and Hui (1985). Includes the !! high-frequency form for beta_s found by Banner (1990). !! !! References: !! !! Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional !! spectra of wind-generated waves. *Phil. Trans. Royal Soc. London A.*, !! **315**, 509-562. !! !! Banner, M. L., 1990. Equilibrium spectra of wind waves. *J. Phys. !! Oceanogr.*, **20**, 966-984. real ( kind = rk ), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = rk ), intent ( in ) :: theta !! Wave direction [rad] real ( kind = rk ), intent ( in ) :: theta_mean !! Mean wave direction [rad] real ( kind = rk ) :: frel ! Frequency relative to peak frequency, f/fpeak real ( kind = rk ) :: nu ! Nondimensional frequency real ( kind = rk ) :: beta frel = f / fpeak if ( frel < 0.56_rk ) then beta = 1.24_rk elseif ( frel >= 0.56_rk . and . frel < 0.95_rk ) then beta = 2.61_rk * frel ** 1.3_rk elseif ( frel >= 0.95_rk . and . frel < 1.6_rk ) then beta = 2.28_rk * frel ** ( - 1.3_rk ) else beta = 10 ** ( - 0.4_rk + 0.8393_rk * exp ( - 0.567_rk * log ( frel ** 2 ))) endif spreading = 0.5_rk * beta / cosh ( beta * ( theta - theta_mean )) ** 2 endfunction donelanHamiltonHuiDirectionalSpreading !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure function donelanHamiltonHuiDirectionalSpectrum ( f , theta , wspd , fpeak ,& theta_mean , grav ) result ( spec ) !! Returns directional frequency spectrum based on the laboratory and field !! measurements by Donelan, Hamilton, and Hui (1985). Includes the high !! frequency form for beta_s found by Banner (1990). This function invokes the !!  DHH omnidirectional spectrum and the directional spreading functions to !! compute directional frequency spectrum: !! !!  !!     F(f,\\theta) = F'(f) * D(f,\\theta) !!  !! !! References: !! !! Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional !! spectra of wind-generated waves. Phil. Trans. Royal Soc. London A., !! 315, 509-562. !! !! Banner, M. L., 1990. Equilibrium spectra of wind waves. J. Phys. Oceanogr., !! 20, 966-984. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), dimension (:), intent ( in ) :: theta !! Wave direction [rad] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = rk ), intent ( in ) :: theta_mean !! Mean wave direction [rad] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), dimension (:,:), allocatable :: spec integer ( kind = ik ) :: ndir allocate ( spec ( size ( f ), size ( theta ))) do concurrent ( ndir = 1 : size ( theta )) spec (:, ndir ) = donelanHamiltonHui ( f , fpeak , wspd , grav )& * donelanHamiltonHuiDirectionalSpreading ( f , wspd , fpeak , theta ( ndir ),& theta_mean ) enddo endfunction donelanHamiltonHuiDirectionalSpectrum !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function jonswap ( f , wspd , fetch , grav ) result ( spec ) !! Computes the JONSWAP equilibrium spectrum (Hasselmann et al. 1973) based on !!  input wind speed at the height of 10 m and fetch. !! !! References: !! !! Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell !! decay during the Joint North Sea Wave Project (JONSWAP). Dtsch. Hydrogh. !! Z., Suppl. A, 8, 12, 95pp. real ( kind = rk ), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: fetch !! Fetch [m] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ) :: alpha ! Phillips' constant real ( kind = rk ) :: sigma ! Spread of the spectrum peak real ( kind = rk ) :: r ! Exponent in peak enhancement factor real ( kind = rk ) :: fpeak ! Peak frequency [Hz] real ( kind = rk ) :: omega ! Radian frequency [rad/s] real ( kind = rk ), parameter :: beta = - 1.25_rk real ( kind = rk ), parameter :: gamma = 3.3_rk ! peak enhancement omega = twopi * f alpha = 0.076_rk * nondimensionalFetch ( wspd , fetch , grav ) ** ( - 0.22_rk ) fpeak = jonswapPeakFrequency ( wspd , fetch , grav ) if ( f > fpeak ) then sigma = 0.09_rk else sigma = 0.07_rk endif r = exp ( - 0.5_rk * (( f - fpeak ) / ( sigma * fpeak )) ** 2 ) spec = twopi * alpha * grav ** 2 / omega ** 5 * exp ( beta * ( fpeak / f ) ** 4 ) * gamma ** r endfunction jonswap !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function jonswapPeakFrequency ( wspd , fetch , grav )& result ( fpeak ) !! Computes the JONSWAP equilibrium peak frequency [Hz] on the input !! based on the 10-m wind speed and fetch [km] (Hasselmann et al., 1973). !! !! References: !! !! Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell !! decay during the Joint North Sea Wave Project (JONSWAP). Dtsch. Hydrogh. !! Z., Suppl. A, 8, 12, 95pp. real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: fetch !! Fetch [m] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), parameter :: a = 3.5_rk real ( kind = rk ), parameter :: b = 1._rk / 3._rk fpeak = a * ( grav ** 2 / ( wspd * fetch )) ** b endfunction jonswapPeakFrequency !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function phillips ( f , fpeak , grav ) result ( spec ) !! Computes the Phillips (1958) equilibrium spectrum based on the input !! peak frequency [Hz]. !! !! References: !! !! Phillips, O.M., 1958. The equilibrium range in the spectrum of !! wind-generated waves. J. Fluid Mech., 4, 426–434. !! doi:10.1017/S0022112058000550. real ( kind = rk ), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), parameter :: alpha = 8.13e-3 !! Phillips' parameter if ( f < fpeak ) then spec = 0 else spec = alpha * grav ** 2 * ( twopi * f ) ** ( - 5 ) endif endfunction phillips !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function piersonMoskowitz ( f , wspd , grav ) result ( spec ) !! Computes the Pierson-Moskowitz (1964) equilibrium spectrum based on input !! wind speed at the height of 10 m. !! !! References: !! !! Pierson Jr., W. J., and L. Moskowitz (1964), A proposed spectral form for !! fully developed wind seas based on the similarity theory of S. A. !! Kitaigorodskii, J. Geophys. Res., 69(24), 5181–5190, !! doi:10.1029/JZ069i024p05181. real ( kind = rk ), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ) :: omega real ( kind = rk ) :: fpeak real ( kind = rk ), parameter :: alpha = 8.1e-3_rk ! Phillips' constant real ( kind = rk ), parameter :: beta = - 1.25_rk omega = twopi * f fpeak = piersonMoskowitzPeakFrequency ( wspd , grav ) spec = twopi * alpha * grav ** 2 / omega ** 5 * exp ( beta * ( fpeak / f ) ** 4 ) endfunction piersonMoskowitz !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- pure elemental real ( kind = rk ) function piersonMoskowitzPeakFrequency ( wspd , grav )& result ( fpeak ) !! Computes the Pierson-Moskowitz (1964) peak frequency based on input wind !! speed at the height of 10 m. !! !! References: !! !! Pierson Jr., W. J., and L. Moskowitz (1964), A proposed spectral form for !! fully developed wind seas based on the similarity theory of S. A. !! Kitaigorodskii, J. Geophys. Res., 69(24), 5181–5190, !! doi:10.1029/JZ069i024p05181. real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), parameter :: const = 0.1325_rk fpeak = const * grav / max ( wspd , 1 e - 2_rk ) endfunction piersonMoskowitzPeakFrequency !------------------------------------------------------------------------------- endmodule mod_spectral_shapes","tags":"","loc":"sourcefile/mod_spectral_shapes.f90.html","title":"mod_spectral_shapes.f90 – wavy"},{"text":"Files Dependent On This One sourcefile~~mod_precision.f90~~AfferentGraph sourcefile~mod_precision.f90 mod_precision.f90 sourcefile~mod_stokes.f90 mod_stokes.f90 sourcefile~mod_precision.f90->sourcefile~mod_stokes.f90 sourcefile~mod_domain.f90 mod_domain.f90 sourcefile~mod_precision.f90->sourcefile~mod_domain.f90 sourcefile~mod_time_integration.f90 mod_time_integration.f90 sourcefile~mod_precision.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_spectrum.f90 mod_spectrum.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_grid.f90 mod_grid.f90 sourcefile~mod_precision.f90->sourcefile~mod_grid.f90 sourcefile~mod_const.f90 mod_const.f90 sourcefile~mod_precision.f90->sourcefile~mod_const.f90 sourcefile~mod_source_functions.f90 mod_source_functions.f90 sourcefile~mod_precision.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_io.f90 mod_io.f90 sourcefile~mod_precision.f90->sourcefile~mod_io.f90 sourcefile~mod_gravity.f90 mod_gravity.f90 sourcefile~mod_precision.f90->sourcefile~mod_gravity.f90 sourcefile~mod_advection.f90 mod_advection.f90 sourcefile~mod_precision.f90->sourcefile~mod_advection.f90 sourcefile~mod_spectral_shapes.f90 mod_spectral_shapes.f90 sourcefile~mod_precision.f90->sourcefile~mod_spectral_shapes.f90 sourcefile~mod_utility.f90 mod_utility.f90 sourcefile~mod_precision.f90->sourcefile~mod_utility.f90 sourcefile~mod_linear_wave_theory.f90 mod_linear_wave_theory.f90 sourcefile~mod_precision.f90->sourcefile~mod_linear_wave_theory.f90 sourcefile~mod_nondimensional.f90 mod_nondimensional.f90 sourcefile~mod_precision.f90->sourcefile~mod_nondimensional.f90 sourcefile~mod_domain.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_domain.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_time_integration.f90 sourcefile~mod_spectrum.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_grid.f90->sourcefile~mod_domain.f90 sourcefile~mod_const.f90->sourcefile~mod_domain.f90 sourcefile~mod_const.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_const.f90->sourcefile~mod_source_functions.f90 sourcefile~mod_const.f90->sourcefile~mod_spectral_shapes.f90 sourcefile~mod_utility.f90->sourcefile~mod_spectrum.f90 sourcefile~mod_utility.f90->sourcefile~mod_grid.f90 sourcefile~mod_nondimensional.f90->sourcefile~mod_spectral_shapes.f90 var pansourcefilemod_precisionf90AfferentGraph = svgPanZoom('#sourcefilemod_precisionf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mod_precision Source Code mod_precision.f90 Source Code ! ! wavy - A spectral ocean wave modeling and development framework ! Copyright (c) 2017, Wavebit Scientific LLC ! All rights reserved. ! ! Licensed under the BSD-3 clause license. See LICENSE for details. module mod_precision use iso_fortran_env , only : int16 , int32 , int64 , real32 , real64 , real128 implicit none private public :: intkind , realkind #ifdef REAL64 integer , parameter :: realkind = real64 #elif REAL128 integer , parameter :: realkind = real128 #else integer , parameter :: realkind = real32 #endif integer , parameter :: intkind = int32 endmodule mod_precision","tags":"","loc":"sourcefile/mod_precision.f90.html","title":"mod_precision.f90 – wavy"},{"text":"type, public :: grid_type Inherited By type~~grid_type~~InheritedByGraph type~grid_type grid_type type~domain_type domain_type type~grid_type->type~domain_type grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables lb ub x y dx dy lon lat alpha Constructor grid_type Type-Bound Procedures getLowerBounds getUpperBounds getAxisX getAxisY getGridSpacingX getGridSpacingY getGridRotation getLongitude getLatitude Source Code grid_type Components Type Visibility Attributes Name Initial integer(kind=intkind), private, dimension(2) :: lb Lower bounds of the grid integer(kind=intkind), private, dimension(2) :: ub Upper bounds of the grid real(kind=realkind), private, dimension(:,:), allocatable :: x Distance in x-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: y Distance in y-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: dx Grid spacing in x-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: dy Grid spacing in y-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: lon Longitude [rad] real(kind=realkind), private, dimension(:,:), allocatable :: lat Latitude [rad] real(kind=realkind), private, dimension(:,:), allocatable :: alpha Grid rotation angle [rad] Constructor public interface grid_type private function constructor_1d (lb, ub, x, dx) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:) :: dx Grid spacing in x-direction [m] Return Value type( grid_type ) private function constructor_2d (lb, ub, x, y, dx, dy, lon, lat) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in), dimension(:) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in), dimension(:) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:,:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: y Distance in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dy Grid spacing in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: lon Longitude [rad] real(kind=realkind), intent(in), optional dimension(:,:) :: lat Latitude [rad] Return Value type( grid_type ) Type-Bound Procedures procedure, public, pass(self) :: getLowerBounds private pure function getLowerBounds (self) result(lb) Returns the lower bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Upper bound indices procedure, public, pass(self) :: getUpperBounds private pure function getUpperBounds (self) result(ub) Returns the upper bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Lower bound indices procedure, public, pass(self) :: getAxisX private pure function getAxisX (self) result(x) Returns the x-coordinate of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable x-coordinate [m] procedure, public, pass(self) :: getAxisY private pure function getAxisY (self) result(y) Returns the y-coordinate [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable y-coordinate [m] procedure, public, pass(self) :: getGridSpacingX private pure function getGridSpacingX (self) result(dx) Returns the grid spacing in x [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid spacing in x [m] procedure, public, pass(self) :: getGridSpacingY private pure function getGridSpacingY (self) result(dy) Returns the grid spacing in y [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid spacing in y [m] procedure, public, pass(self) :: getGridRotation private pure function getGridRotation (self) result(alpha) Returns the grid rotation angle [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid rotation [rad] procedure, public, pass(self) :: getLongitude private pure function getLongitude (self) result(lon) Returns the longitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Longitude [rad] procedure, public, pass(self) :: getLatitude private pure function getLatitude (self) result(lat) Returns the latitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Latitude [rad] Source Code type :: grid_type private integer ( kind = intkind ), dimension ( 2 ) :: lb !! Lower bounds of the grid integer ( kind = intkind ), dimension ( 2 ) :: ub !! Upper bounds of the grid real ( kind = realkind ), dimension (:,:), allocatable :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: y !! Distance in y-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: dx !! Grid spacing in x-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: dy !! Grid spacing in y-direction [m] real ( kind = realkind ), dimension (:,:), allocatable :: lon !! Longitude [rad] real ( kind = realkind ), dimension (:,:), allocatable :: lat !! Latitude [rad] real ( kind = realkind ), dimension (:,:), allocatable :: alpha !! Grid rotation angle [rad] contains procedure , public , pass ( self ) :: getLowerBounds procedure , public , pass ( self ) :: getUpperBounds procedure , public , pass ( self ) :: getAxisX procedure , public , pass ( self ) :: getAxisY procedure , public , pass ( self ) :: getGridSpacingX procedure , public , pass ( self ) :: getGridSpacingY procedure , public , pass ( self ) :: getGridRotation procedure , public , pass ( self ) :: getLongitude procedure , public , pass ( self ) :: getLatitude endtype grid_type","tags":"","loc":"type/grid_type.html","title":"grid_type – wavy "},{"text":"type, public :: domain_type type~~domain_type~~InheritsGraph type~domain_type domain_type type~grid_type grid_type type~grid_type->type~domain_type grid timedelta timedelta timedelta->type~domain_type time_step type~spectrum_type spectrum_type timedelta->type~spectrum_type time_step datetime datetime datetime->type~domain_type start_time, end_time datetime->type~spectrum_type start_time, end_time type~spectrum_type->type~domain_type spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables type_name grid spectrum shallow_water_mode start_time end_time time_step dx dy u v eta depth lb ub nfreqs ndirs Constructor domain_type Type-Bound Procedures frequencyMoment getCurrent_u getCurrent_v getGravity getGrid getGridSpacingXWithHalo getGridSpacingYWithHalo getDepth getElevation getFrequency getDirections getLowerBounds getUpperBounds getSpectrum getSpectrumArray getPhaseSpeed getGroupSpeed getSurfaceTension getAirDensity getWaterDensity isAllocated meanPeriod meanPeriodZeroCrossing setDepth setElevation setGravity setSurfaceTension setAirDensity setWaterDensity significantWaveHeight wavenumberMoment writeJSON advect1dRank1 advect1dRank2 advect2dRank2 assign_spectrum_array_1d assign_spectrum_array_2d domain_add_domain domain_add_real domain_sub_domain domain_sub_real domain_mult_domain domain_mult_real domain_div_domain domain_div_real domain_unary_minus real_add_domain real_sub_domain real_mult_domain real_div_domain eq neq setSpectrum1d setSpectrum2d setSpectrumArray1d1d setSpectrumArray1d2d setSpectrumArray2d2d advect setSpectrum setSpectrumArray assignment(=) operator(+) operator(-) operator(*) operator(/) operator(==) operator(/=) Source Code domain_type Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: type_name type( grid_type ), private :: grid type( spectrum_type ), private, dimension(:,:), allocatable :: spectrum logical, private :: shallow_water_mode type(datetime), private :: start_time Simulation start time type(datetime), private :: end_time Simulation end time type(timedelta), private :: time_step Time step [s] real(kind=rk), private, dimension(:,:), allocatable :: dx real(kind=rk), private, dimension(:,:), allocatable :: dy real(kind=rk), private, dimension(:,:), allocatable :: u real(kind=rk), private, dimension(:,:), allocatable :: v real(kind=rk), private, dimension(:,:), allocatable :: eta real(kind=rk), private, dimension(:,:), allocatable :: depth integer(kind=ik), private, dimension(2) :: lb integer(kind=ik), private, dimension(2) :: ub integer(kind=ik), private :: nfreqs integer(kind=ik), private :: ndirs Constructor public interface domain_type private function constructor (grid, spectrum, shallow_water_mode) result(domain) Constructor function for the domain object. Arguments Type Intent Optional Attributes Name type( grid_type ), intent(in) :: grid Input grid instance type( spectrum_type ), intent(in) :: spectrum Input spectrum instance logical, intent(in), optional :: shallow_water_mode Logical switch to enable shallow water solver Return Value type( domain_type ) Type-Bound Procedures procedure, public, pass(self) :: frequencyMoment private pure function frequencyMoment (self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:), allocatable procedure, public, pass(self) :: getCurrent_u private pure function getCurrent_u (self) result(u) Returns the 3-d array with values of Eulerian velocity (mean current) in \n x-direction [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Eulerian u-velocity [m/s] procedure, public, pass(self) :: getCurrent_v private pure function getCurrent_v (self) result(v) Returns the 3-d array with values of Eulerian velocity (mean current) in \n y-direction [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Eulerian v-velocity [m/s] procedure, public, pass(self) :: getGravity private pure function getGravity (self) result(grav) Returns the gravitational acceleration [m/s&#94;2] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Gravitational acceleration [m/s&#94;2] procedure, public, pass(self) :: getGrid private pure function getGrid (self) result(grid) Returns the grid instance that is the component of the domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( grid_type ) Grid instance component procedure, public, pass(self) :: getGridSpacingXWithHalo private pure function getGridSpacingXWithHalo (self, halowidth, periodic) result(dx) Returns grid spacing array in x-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:), allocatable Grid spacing in x [m] procedure, public, pass(self) :: getGridSpacingYWithHalo private pure function getGridSpacingYWithHalo (self, halowidth, periodic) result(dy) Returns grid spacing array in y-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:), allocatable Grid spacing in y [m] procedure, public, pass(self) :: getDepth private pure function getDepth (self) result(depth) Returns the mean water depth [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean water depth [m] procedure, public, pass(self) :: getElevation private pure function getElevation (self) result(elevation) Returns the mean water elevation [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean water elevation [m] procedure, public, pass(self) :: getFrequency private pure function getFrequency (self) result(frequency) Returns the frequency [Hz] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:), allocatable Frequency [Hz] procedure, public, pass(self) :: getDirections private pure function getDirections (self) result(directions) Returns the spectral direction bins [rad]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:), allocatable Directions [rad] procedure, public, pass(self) :: getLowerBounds private pure function getLowerBounds (self) result(lb) Returns the lower bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Lower bound indices procedure, public, pass(self) :: getUpperBounds private pure function getUpperBounds (self) result(ub) Returns the upper bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Upper bound indices procedure, public, pass(self) :: getSpectrum private pure function getSpectrum (self) result(spectrum) Returns the array of spectrum instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( spectrum_type ),\n  dimension(:,:), allocatable Array of spectrum instances procedure, public, pass(self) :: getSpectrumArray private pure function getSpectrumArray (self, halowidth, periodic) result(spectrum_array) Returns a 4-dimensional spectrum array, where the first two dimensions are\n frequency and directional dimensions and the second two are spatial x and y\n dimensions. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Spectrum array procedure, public, pass(self) :: getPhaseSpeed private pure function getPhaseSpeed (self) result(cp) Returns a 3-d array with phase speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Phase speed [m/s] array procedure, public, pass(self) :: getGroupSpeed private pure function getGroupSpeed (self, halowidth, periodic) result(cg) Returns a 3-d array with group speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Group speed [m/s] array procedure, public, pass(self) :: getSurfaceTension private pure function getSurfaceTension (self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Surface tension [N/m] procedure, public, pass(self) :: getAirDensity private pure function getAirDensity (self) result(air_density) Returns the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Air density [kg/m&#94;3] procedure, public, pass(self) :: getWaterDensity private pure function getWaterDensity (self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Water density [kg/m&#94;3] procedure, public, pass(self) :: isAllocated private pure elemental function isAllocated (self) Returns the allocation status of the domains sub-components. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value logical procedure, public, pass(self) :: meanPeriod private pure function meanPeriod (self) Returns the mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean period [s] array procedure, public, pass(self) :: meanPeriodZeroCrossing private pure function meanPeriodZeroCrossing (self) Returns the zero-crossing mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean period [s] array procedure, public, pass(self) :: setDepth private pure subroutine setDepth (self, depth) Sets the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: depth Mean water depth [m] procedure, public, pass(self) :: setElevation private pure subroutine setElevation (self, elevation) Sets the mean water elevation [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: elevation Mean water elevation [m] procedure, public, pass(self) :: setGravity private pure subroutine setGravity (self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: grav Gravitational acceleration [m/s&#94;2] procedure, public, pass(self) :: setSurfaceTension private pure subroutine setSurfaceTension (self, surface_tension) Sets the surface tension [N/m&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: surface_tension Surface tension [N/m&#94;2] procedure, public, pass(self) :: setAirDensity private pure subroutine setAirDensity (self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: air_density Air density [kg/m&#94;3] procedure, public, pass(self) :: setWaterDensity private pure subroutine setWaterDensity (self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: water_density Water density [kg/m&#94;3] procedure, public, pass(self) :: significantWaveHeight private pure function significantWaveHeight (self) result(hs) Returns the significant wave height [m] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Significant wave height [m] array procedure, public, pass(self) :: wavenumberMoment private pure function wavenumberMoment (self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:), allocatable procedure, public, pass(self) :: writeJSON private subroutine writeJSON (self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file procedure, private, pass(self) :: advect1dRank1 private pure function advect1dRank1 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works only in cases where ndirs == 1 . Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f real(kind=rk), intent(in), dimension(:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) procedure, private, pass(self) :: advect1dRank2 private pure function advect1dRank2 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:,:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) procedure, private, pass(self) :: advect2dRank2 private pure function advect2dRank2 (self, advection_method, halowidth) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, v, dx, dy) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:,:) :: u real(kind=rk), intent(in), dimension(:,:,:,:) :: v real(kind=rk), intent(in), dimension(:,:) :: dx real(kind=rk), intent(in), dimension(:,:) :: dy Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable integer(kind=ik), intent(in), dimension(:) :: halowidth number of halo cells to use in the advection method Return Value type( domain_type ) procedure, private, pass(self) :: assign_spectrum_array_1d private pure subroutine assign_spectrum_array_1d (self, spectrum_array) Assigns a 1-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:) :: spectrum_array r.h.s. array of spectrum instances procedure, private, pass(self) :: assign_spectrum_array_2d private pure subroutine assign_spectrum_array_2d (self, spectrum_array) Assigns a 2-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:,:) :: spectrum_array r.h.s. array of spectrum instances procedure, private, pass(self) :: domain_add_domain private pure elemental function domain_add_domain (self, d2) result(domain) Returns a sum of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: domain_add_real private pure elemental function domain_add_real (self, a) result(domain) Returns a sum of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) procedure, private, pass(self) :: domain_sub_domain private pure elemental function domain_sub_domain (self, d2) result(domain) Returns a difference between two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: domain_sub_real private pure elemental function domain_sub_real (self, a) result(domain) Returns a difference between a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) procedure, private, pass(self) :: domain_mult_domain private pure elemental function domain_mult_domain (self, d2) result(domain) Returns a product of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: domain_mult_real private pure elemental function domain_mult_real (self, a) result(domain) Returns a product of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) procedure, private, pass(self) :: domain_div_domain private pure elemental function domain_div_domain (self, d2) result(domain) Returns a division of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: domain_div_real private pure elemental function domain_div_real (self, a) result(domain) Returns a division of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) procedure, private, pass(self) :: domain_unary_minus private pure elemental function domain_unary_minus (self) result(domain) Returns a negative domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value type( domain_type ) procedure, private, pass(self) :: real_add_domain private pure elemental function real_add_domain (a, self) result(domain) Returns a sum of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: real_sub_domain private pure elemental function real_sub_domain (a, self) result(domain) Returns a difference between a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: real_mult_domain private pure elemental function real_mult_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: real_div_domain private pure elemental function real_div_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) procedure, private, pass(self) :: eq private pure elemental function eq (self, d2) Logical equality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical procedure, private, pass(self) :: neq private pure elemental function neq (self, d2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical procedure, private, pass(self) :: setSpectrum1d private pure subroutine setSpectrum1d (self, spectrum) Sets the 1-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:) :: spectrum Input 1-d array of spectrum object instances procedure, private, pass(self) :: setSpectrum2d private pure subroutine setSpectrum2d (self, spectrum) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:,:) :: spectrum Input 2-d array of spectrum object instances procedure, private, pass(self) :: setSpectrumArray1d1d private pure subroutine setSpectrumArray1d1d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for omnidirectional spectrum in 1-d space (1d-1d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: spectrum_array Spectrum array procedure, private, pass(self) :: setSpectrumArray1d2d private pure subroutine setSpectrumArray1d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for setting 1-d spectrum into 2-d physical space\n of 2-d spectrum into 1-d physical space. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:) :: spectrum_array Spectrum array procedure, private, pass(self) :: setSpectrumArray2d2d private pure subroutine setSpectrumArray2d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for directional spectrum in 2-d space (2d-2d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:,:) :: spectrum_array Spectrum array generic, public :: advect => advect1dRank1 , advect1dRank2 , advect2dRank2 private pure function advect1dRank1 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works only in cases where ndirs == 1 . Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f real(kind=rk), intent(in), dimension(:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) private pure function advect1dRank2 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:,:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) private pure function advect2dRank2 (self, advection_method, halowidth) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, v, dx, dy) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:,:) :: u real(kind=rk), intent(in), dimension(:,:,:,:) :: v real(kind=rk), intent(in), dimension(:,:) :: dx real(kind=rk), intent(in), dimension(:,:) :: dy Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable integer(kind=ik), intent(in), dimension(:) :: halowidth number of halo cells to use in the advection method Return Value type( domain_type ) generic, public :: setSpectrum => setSpectrum1d , setSpectrum2d private pure subroutine setSpectrum1d (self, spectrum) Sets the 1-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:) :: spectrum Input 1-d array of spectrum object instances private pure subroutine setSpectrum2d (self, spectrum) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:,:) :: spectrum Input 2-d array of spectrum object instances generic, public :: setSpectrumArray => setSpectrumArray1d1d , setSpectrumArray1d2d , setSpectrumArray2d2d private pure subroutine setSpectrumArray1d1d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for omnidirectional spectrum in 1-d space (1d-1d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: spectrum_array Spectrum array private pure subroutine setSpectrumArray1d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for setting 1-d spectrum into 2-d physical space\n of 2-d spectrum into 1-d physical space. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:) :: spectrum_array Spectrum array private pure subroutine setSpectrumArray2d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for directional spectrum in 2-d space (2d-2d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:,:) :: spectrum_array Spectrum array generic, public :: assignment(=) => assign_spectrum_array_1d , assign_spectrum_array_2d private pure subroutine assign_spectrum_array_1d (self, spectrum_array) Assigns a 1-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:) :: spectrum_array r.h.s. array of spectrum instances private pure subroutine assign_spectrum_array_2d (self, spectrum_array) Assigns a 2-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:,:) :: spectrum_array r.h.s. array of spectrum instances generic, public :: operator(+) => domain_add_domain , domain_add_real , real_add_domain private pure elemental function domain_add_domain (self, d2) result(domain) Returns a sum of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_add_real (self, a) result(domain) Returns a sum of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function real_add_domain (a, self) result(domain) Returns a sum of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) generic, public :: operator(-) => domain_sub_domain , domain_sub_real , domain_unary_minus , real_sub_domain private pure elemental function domain_sub_domain (self, d2) result(domain) Returns a difference between two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_sub_real (self, a) result(domain) Returns a difference between a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function domain_unary_minus (self) result(domain) Returns a negative domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value type( domain_type ) private pure elemental function real_sub_domain (a, self) result(domain) Returns a difference between a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) generic, public :: operator(*) => domain_mult_domain , domain_mult_real , real_mult_domain private pure elemental function domain_mult_domain (self, d2) result(domain) Returns a product of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_mult_real (self, a) result(domain) Returns a product of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function real_mult_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) generic, public :: operator(/) => domain_div_domain , domain_div_real , real_div_domain private pure elemental function domain_div_domain (self, d2) result(domain) Returns a division of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_div_real (self, a) result(domain) Returns a division of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function real_div_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) generic, public :: operator(==) => eq private pure elemental function eq (self, d2) Logical equality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical generic, public :: operator(/=) => neq private pure elemental function neq (self, d2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical Source Code type :: domain_type private character ( len = :), allocatable :: type_name type ( grid_type ) :: grid type ( spectrum_type ), dimension (:,:), allocatable :: spectrum logical :: shallow_water_mode type ( datetime ) :: start_time !! Simulation start time type ( datetime ) :: end_time !! Simulation end time type ( timedelta ) :: time_step !! Time step [s] real ( kind = rk ), dimension (:,:), allocatable :: dx ! grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dy ! grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: u ! x-component of velocity [m/s] real ( kind = rk ), dimension (:,:), allocatable :: v ! y-component of velocity [m/s] real ( kind = rk ), dimension (:,:), allocatable :: eta ! surface elevation [m] real ( kind = rk ), dimension (:,:), allocatable :: depth ! mean water depth [m] integer ( kind = ik ), dimension ( 2 ) :: lb ! lower bounds in geographical space integer ( kind = ik ), dimension ( 2 ) :: ub ! upper bounds in geographical space integer ( kind = ik ) :: nfreqs ! number of frequencies integer ( kind = ik ) :: ndirs ! number of directions contains ! Public type-bound methods procedure , public , pass ( self ) :: frequencyMoment procedure , public , pass ( self ) :: getCurrent_u procedure , public , pass ( self ) :: getCurrent_v procedure , public , pass ( self ) :: getGravity procedure , public , pass ( self ) :: getGrid procedure , public , pass ( self ) :: getGridSpacingXWithHalo procedure , public , pass ( self ) :: getGridSpacingYWithHalo procedure , public , pass ( self ) :: getDepth procedure , public , pass ( self ) :: getElevation procedure , public , pass ( self ) :: getFrequency procedure , public , pass ( self ) :: getDirections procedure , public , pass ( self ) :: getLowerBounds procedure , public , pass ( self ) :: getUpperBounds procedure , public , pass ( self ) :: getSpectrum procedure , public , pass ( self ) :: getSpectrumArray procedure , public , pass ( self ) :: getPhaseSpeed procedure , public , pass ( self ) :: getGroupSpeed procedure , public , pass ( self ) :: getSurfaceTension procedure , public , pass ( self ) :: getAirDensity procedure , public , pass ( self ) :: getWaterDensity procedure , public , pass ( self ) :: isAllocated procedure , public , pass ( self ) :: meanPeriod procedure , public , pass ( self ) :: meanPeriodZeroCrossing procedure , public , pass ( self ) :: setDepth procedure , public , pass ( self ) :: setElevation procedure , public , pass ( self ) :: setGravity procedure , public , pass ( self ) :: setSurfaceTension procedure , public , pass ( self ) :: setAirDensity procedure , public , pass ( self ) :: setWaterDensity procedure , public , pass ( self ) :: significantWaveHeight procedure , public , pass ( self ) :: wavenumberMoment procedure , public , pass ( self ) :: writeJSON ! Specific procedures overloaded by generic procedures and operators procedure , private , pass ( self ) :: advect1dRank1 procedure , private , pass ( self ) :: advect1dRank2 procedure , private , pass ( self ) :: advect2dRank2 procedure , private , pass ( self ) :: assign_spectrum_array_1d procedure , private , pass ( self ) :: assign_spectrum_array_2d procedure , private , pass ( self ) :: domain_add_domain procedure , private , pass ( self ) :: domain_add_real procedure , private , pass ( self ) :: domain_sub_domain procedure , private , pass ( self ) :: domain_sub_real procedure , private , pass ( self ) :: domain_mult_domain procedure , private , pass ( self ) :: domain_mult_real procedure , private , pass ( self ) :: domain_div_domain procedure , private , pass ( self ) :: domain_div_real procedure , private , pass ( self ) :: domain_unary_minus procedure , private , pass ( self ) :: real_add_domain procedure , private , pass ( self ) :: real_sub_domain procedure , private , pass ( self ) :: real_mult_domain procedure , private , pass ( self ) :: real_div_domain procedure , private , pass ( self ) :: eq procedure , private , pass ( self ) :: neq procedure , private , pass ( self ) :: setSpectrum1d procedure , private , pass ( self ) :: setSpectrum2d procedure , private , pass ( self ) :: setSpectrumArray1d1d procedure , private , pass ( self ) :: setSpectrumArray1d2d procedure , private , pass ( self ) :: setSpectrumArray2d2d ! Generic procedures generic , public :: advect => advect1dRank1 ,& advect1dRank2 ,& advect2dRank2 generic , public :: setSpectrum => setSpectrum1d ,& setSpectrum2d generic , public :: setSpectrumArray => setSpectrumArray1d1d ,& setSpectrumArray1d2d ,& setSpectrumArray2d2d ! Generic operators generic :: assignment ( = ) => assign_spectrum_array_1d ,& assign_spectrum_array_2d generic :: operator ( + ) => domain_add_domain ,& domain_add_real ,& real_add_domain generic :: operator ( - ) => domain_sub_domain ,& domain_sub_real ,& domain_unary_minus ,& real_sub_domain generic :: operator ( * ) => domain_mult_domain ,& domain_mult_real ,& real_mult_domain generic :: operator ( / ) => domain_div_domain ,& domain_div_real ,& real_div_domain generic :: operator ( == ) => eq generic :: operator ( /= ) => neq endtype domain_type","tags":"","loc":"type/domain_type.html","title":"domain_type – wavy "},{"text":"type, public :: spectrum_type type~~spectrum_type~~InheritsGraph type~spectrum_type spectrum_type timedelta timedelta timedelta->type~spectrum_type time_step datetime datetime datetime->type~spectrum_type start_time, end_time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Spectrum class. Inherited By type~~spectrum_type~~InheritedByGraph type~spectrum_type spectrum_type type~domain_type domain_type type~spectrum_type->type~domain_type spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables start_time end_time time_step spec f df k dk th dth cp cg u v z air_density depth elevation grav surface_tension water_density Constructor spectrum_type Type-Bound Procedures frequencyMoment getAirDensity getAmplitude getCurrent_u getCurrent_v getDepth getDepthLevels getDirections getDirections2d getElevation getFrequency getFrequency2d getGravity getGroupSpeed getGroupSpeed2d getWaveAction getWavelength getWavenumber getWavenumberSpacing getWavenumber2d getPhaseSpeed getPhaseSpeed2d getSpectrum getSurfaceTension getWaterDensity isAllocated isMonochromatic isOmnidirectional meanPeriod meanPeriodZeroCrossing meanSquareSlope meanSquareSlopeDirectional momentum_x momentum_y momentumFlux_xx momentumFlux_xy momentumFlux_yy omnidirectionalSpectrum peakedness peakFrequency peakFrequencyDiscrete saturationSpectrum setAirDensity setCurrent1d setCurrent2d setDepth setElevation setGravity setSurfaceTension setWaterDensity setSpectrum1d setSpectrum2d significantWaveHeight significantSurfaceOrbitalVelocity stokesDrift stokesDrift2d ursellNumber wavenumberMoment wavenumberSpectrum readJSON writeJSON assign_array_1d assign_array_2d real_add_spectrum real_sub_spectrum real_mult_spectrum real_div_spectrum real2d_mult_spectrum spectrum_add_spectrum spectrum_add_real spectrum_sub_spectrum spectrum_sub_real spectrum_mult_spectrum spectrum_mult_real spectrum_mult_real2d spectrum_div_spectrum spectrum_div_real spectrum_unary_minus eq neq gt ge lt le setCurrent setSpectrum assignment(=) operator(+) operator(-) operator(*) operator(/) operator(==) operator(/=) operator(>) operator(>=) operator( operator(<=) Source Code spectrum_type Components Type Visibility Attributes Name Initial type(datetime), private :: start_time Simulation start time type(datetime), private :: end_time Simulation end time type(timedelta), private :: time_step Time step [s] real(kind=rk), private, dimension(:,:), allocatable :: spec 2-d spectrum real(kind=rk), private, dimension(:), allocatable :: f Frequency [Hz] real(kind=rk), private, dimension(:), allocatable :: df Frequency spacing [Hz] real(kind=rk), private, dimension(:), allocatable :: k Wavenumber [rad/m] real(kind=rk), private, dimension(:), allocatable :: dk Wavenumber spacing [rad/m] real(kind=rk), private, dimension(:), allocatable :: th Direction [rad] real(kind=rk), private, dimension(:), allocatable :: dth Directional spacing [rad] real(kind=rk), private, dimension(:), allocatable :: cp Phase speed [m/s] real(kind=rk), private, dimension(:), allocatable :: cg Group speed [m/s] real(kind=rk), private, dimension(:), allocatable :: u Mean current velocity in x-direction [m/s] real(kind=rk), private, dimension(:), allocatable :: v Mean current velocity in y-direction [m/s] real(kind=rk), private, dimension(:), allocatable :: z Depth levels for current array [m] real(kind=rk), private :: air_density Air density [kg/m&#94;3] real(kind=rk), private :: depth Mean water depth [m] real(kind=rk), private :: elevation Mean surface elevation [m] real(kind=rk), private :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), private :: surface_tension Surface tension [N/m] real(kind=rk), private :: water_density Water density [kg/m&#94;3] Constructor public interface spectrum_type private pure elemental function constructor (fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) result(spectrum) Constructor function for the spectrum object. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: fmin Minimum frequency bin [Hz] real(kind=rk), intent(in) :: fmax Maximum frequency bin [Hz] real(kind=rk), intent(in) :: df Frequency increment, df = f(n+1)/f(n) integer, intent(in) :: ndirs Number of directional bins real(kind=rk), intent(in) :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: air_density Air density [kg/m&#94;3] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value type( spectrum_type ) Type-Bound Procedures procedure, public, pass(self) :: frequencyMoment private pure elemental function frequencyMoment (self, n) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) procedure, public, pass(self) :: getAirDensity private pure elemental function getAirDensity (self) result(air_density) Returns the air_density [kg/m&#94;3] of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Air density [kg/m&#94;3] procedure, public, pass(self) :: getAmplitude private pure function getAmplitude (self) result(a) Returns the amplitude array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Amplitude [m] procedure, public, pass(self) :: getCurrent_u private pure function getCurrent_u (self) result(u) Returns the current velocity in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Mean current velocity in x-direction [m/s] procedure, public, pass(self) :: getCurrent_v private pure function getCurrent_v (self) result(v) Returns the current velocity in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Mean current velocity in y-direction [m/s] procedure, public, pass(self) :: getDepth private pure elemental function getDepth (self) result(depth) Returns the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean water depth [m] procedure, public, pass(self) :: getDepthLevels private pure function getDepthLevels (self) result(z) Returns the depth levels at which the current arrays are defined. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Depth levels of current fields [m] procedure, public, pass(self) :: getDirections private pure function getDirections (self) result(th) Returns the directions [rad] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Directions [rad] procedure, public, pass(self) :: getDirections2d private pure function getDirections2d (self) result(th) Returns the directions [rad] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Directions [rad] procedure, public, pass(self) :: getElevation private pure elemental function getElevation (self) result(elevation) Returns the mean surface elevation anomaly [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean surface elevation anomaly [m] procedure, public, pass(self) :: getFrequency private pure function getFrequency (self) result(f) Returns the frequency [Hz] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Frequency [Hz] procedure, public, pass(self) :: getFrequency2d private pure function getFrequency2d (self) result(f) Returns the frequency [Hz] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Frequency [Hz] procedure, public, pass(self) :: getGravity private pure elemental function getGravity (self) result(grav) Returns the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Gravitational acceleration [m/s&#94;2] procedure, public, pass(self) :: getGroupSpeed private pure function getGroupSpeed (self) result(cg) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Group speed [m/s] procedure, public, pass(self) :: getGroupSpeed2d private pure function getGroupSpeed2d (self) result(cg) Returns the group speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Group speed [m/s] procedure, public, pass(self) :: getWaveAction private pure function getWaveAction (self) result(wave_action) Returns the wave action spectrum, which corresponds to the the wave\n variance spectrum normalized by the intrinsic frequency. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Wave action array procedure, public, pass(self) :: getWavelength private pure function getWavelength (self) result(lambda) Returns the wavelength [m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavelength [m] procedure, public, pass(self) :: getWavenumber private pure function getWavenumber (self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavenumber [rad/m] procedure, public, pass(self) :: getWavenumberSpacing private pure function getWavenumberSpacing (self) result(dk) Returns the wavenumber spacing [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavenumber spacing [rad/m] procedure, public, pass(self) :: getWavenumber2d private pure function getWavenumber2d (self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Wavenumber [rad/m] procedure, public, pass(self) :: getPhaseSpeed private pure function getPhaseSpeed (self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Phase speed [m/s] procedure, public, pass(self) :: getPhaseSpeed2d private pure function getPhaseSpeed2d (self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Phase speed [m/s] procedure, public, pass(self) :: getSpectrum private pure function getSpectrum (self) result(spec) Returns the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Spectrum array procedure, public, pass(self) :: getSurfaceTension private pure elemental function getSurfaceTension (self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Surface tension [N/m] procedure, public, pass(self) :: getWaterDensity private pure elemental function getWaterDensity (self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Water density [kg/m&#94;3] procedure, public, pass(self) :: isAllocated private pure elemental function isAllocated (self) Returns the allocation status of the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self domain instance Return Value logical procedure, public, pass(self) :: isMonochromatic private pure elemental function isMonochromatic (self) Returns .true. if only one frequency bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) procedure, public, pass(self) :: isOmnidirectional private pure elemental function isOmnidirectional (self) Returns .true. if only one direction bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) procedure, public, pass(self) :: meanPeriod private pure elemental function meanPeriod (self) Returns the mean wave period [s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: meanPeriodZeroCrossing private pure elemental function meanPeriodZeroCrossing (self) Returns the zero-crossing mean wave period [s]: Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: meanSquareSlope private pure elemental function meanSquareSlope (self) Returns the mean square slope of the spectrum, which is the second\n moment of the wavenumber spectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: meanSquareSlopeDirectional private pure function meanSquareSlopeDirectional (self) result(mss) For each directional frequency bin, computes the mean square slope of all\n all waves longer than that bin, projected to the direction of that bin. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Directional mean square slope procedure, public, pass(self) :: momentum_x private pure elemental function momentum_x (self) Returns total wave momentum [kg/m/s] in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: momentum_y private pure elemental function momentum_y (self) Returns total wave momentum [kg/m/s] in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: momentumFlux_xx private pure elemental function momentumFlux_xx (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: momentumFlux_xy private pure elemental function momentumFlux_xy (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in x-direction of momentum in\n y-direction and vice versa (flux in y-direction of momentum in\n y-direction), because \\int{Cgx My} == \\int{Cgy Mx}. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: momentumFlux_yy private pure elemental function momentumFlux_yy (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: omnidirectionalSpectrum private pure function omnidirectionalSpectrum (self) result(spec) Returns the omnidirectional spectrum that corresponds to the input\n directional spectrum, integrated over all directions. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Spectrum array procedure, public, pass(self) :: peakedness private pure elemental function peakedness (self) Returns the peakedness parameter that quantifies the sharpness of the\n spectral peak, following Goda (1970). Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: peakFrequency private pure elemental function peakFrequency (self) Returns the peak frequency based on Young (1995). Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: peakFrequencyDiscrete private pure elemental function peakFrequencyDiscrete (self) Returns the peak frequency based on simple discrete maximum location of\n the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: saturationSpectrum private pure function saturationSpectrum (self) Returns the saturation spectrum B(k) = F(k)k&#94;4. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Saturation spectrum result procedure, public, pass(self) :: setAirDensity private pure elemental subroutine setAirDensity (self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: air_density Air density [kg/m&#94;3] procedure, public, pass(self) :: setCurrent1d private pure subroutine setCurrent1d (self, u, z) Sets the 1-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] procedure, public, pass(self) :: setCurrent2d private pure subroutine setCurrent2d (self, u, v, z) Sets the 2-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: v Current velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] procedure, public, pass(self) :: setDepth private pure elemental subroutine setDepth (self, depth) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: depth Mean water depth [m] procedure, public, pass(self) :: setElevation private pure elemental subroutine setElevation (self, elevation) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: elevation Mean surface elevation anomaly [m] procedure, public, pass(self) :: setGravity private pure elemental subroutine setGravity (self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] procedure, public, pass(self) :: setSurfaceTension private pure elemental subroutine setSurfaceTension (self, surface_tension) Sets the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: surface_tension Surface tension [N/m] procedure, public, pass(self) :: setWaterDensity private pure elemental subroutine setWaterDensity (self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: water_density Water density [kg/m&#94;3] procedure, public, pass(self) :: setSpectrum1d private pure subroutine setSpectrum1d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: spec Input 1-d spectrum array procedure, public, pass(self) :: setSpectrum2d private pure subroutine setSpectrum2d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:,:) :: spec Input 2-d spectrum array procedure, public, pass(self) :: significantWaveHeight private pure elemental function significantWaveHeight (self) Returns the significant wave height [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: significantSurfaceOrbitalVelocity private pure elemental function significantSurfaceOrbitalVelocity (self) result(uorb) Returns the significant surface orbital velocity [m/s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: stokesDrift private pure function stokesDrift (self, z) Exact solution of Stokes drift based on linear wave theory, given input \n omnidirectional spectrum and distance from surface z [m], negative \n downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:), allocatable Stokes drift array [m/s] procedure, public, pass(self) :: stokesDrift2d private pure function stokesDrift2d (self, z) Exact solution of Stokes drift based on linear wave theory, given input \n directional spectrum and distance from surface z [m], negative downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:,:), allocatable Stokes drift array [m/s] procedure, public, pass(self) :: ursellNumber private pure elemental function ursellNumber (self) Returns the Ursell number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) procedure, public, pass(self) :: wavenumberMoment private pure elemental function wavenumberMoment (self, n) Returns the spectral wavenumber moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) procedure, public, pass(self) :: wavenumberSpectrum private pure function wavenumberSpectrum (self) result(spec) Returns the wavenumber spectrum array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Spectrum array procedure, public, pass(self) :: readJSON private subroutine readJSON (self, filename) Read a spectrum instance from a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name procedure, public, pass(self) :: writeJSON private subroutine writeJSON (self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file procedure, private, pass(self) :: assign_array_1d private pure subroutine assign_array_1d (self, array) Assigns a 1-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:) :: array r.h.s. array of reals procedure, private, pass(self) :: assign_array_2d private pure subroutine assign_array_2d (self, array) Assigns a 2-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: array r.h.s. array of reals procedure, private, pass(self) :: real_add_spectrum private pure elemental function real_add_spectrum (a, self) result(spec) Returns a sum of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: real_sub_spectrum private pure elemental function real_sub_spectrum (a, self) result(spec) Returns a difference between a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: real_mult_spectrum private pure elemental function real_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: real_div_spectrum private pure elemental function real_div_spectrum (a, self) result(spec) Returns a division of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: real2d_mult_spectrum private pure function real2d_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: a l.h.s. real 2-d array class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_add_spectrum private pure elemental function spectrum_add_spectrum (self, s2) result(spec) Returns a spectrum instance with the spectrum array values being the sum of\n the two input spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_add_real private pure elemental function spectrum_add_real (self, a) result(spec) Returns a sum of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_sub_spectrum private pure elemental function spectrum_sub_spectrum (self, s2) result(spec) Subtracts one spectrum instance from another and returns the resulting\n spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_sub_real private pure elemental function spectrum_sub_real (self, a) result(spec) Returns a difference of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_mult_spectrum private pure elemental function spectrum_mult_spectrum (self, s2) result(spec) Returns a product of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_mult_real private pure elemental function spectrum_mult_real (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_mult_real2d private pure function spectrum_mult_real2d (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: a r.h.s. real 2-d array Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_div_spectrum private pure elemental function spectrum_div_spectrum (self, s2) result(spec) Returns a division of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_div_real private pure elemental function spectrum_div_real (self, a) result(spec) Returns a division of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) procedure, private, pass(self) :: spectrum_unary_minus private pure elemental function spectrum_unary_minus (self) result(spec) Returns a negative value of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) procedure, private, pass(self) :: eq private pure elemental function eq (self, s2) Logical equality comparison function. Overloads the == operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical procedure, private, pass(self) :: neq private pure elemental function neq (self, s2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical procedure, private, pass(self) :: gt private pure elemental function gt (self, s2) Logical greater than comparison function. Overloads the > operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical procedure, private, pass(self) :: ge private pure elemental function ge (self, s2) Logical greater than or equal comparison function. Overloads the >= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical procedure, private, pass(self) :: lt private pure elemental function lt (self, s2) Logical less than comparison function. Overloads the < operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical procedure, private, pass(self) :: le private pure elemental function le (self, s2) Logical less than or equal comparison function. Overloads the <= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: setCurrent => setCurrent1d , setCurrent2d private pure subroutine setCurrent1d (self, u, z) Sets the 1-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] private pure subroutine setCurrent2d (self, u, v, z) Sets the 2-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: v Current velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] generic, public :: setSpectrum => setSpectrum1d , setSpectrum2d private pure subroutine setSpectrum1d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: spec Input 1-d spectrum array private pure subroutine setSpectrum2d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:,:) :: spec Input 2-d spectrum array generic, public :: assignment(=) => assign_array_1d , assign_array_2d private pure subroutine assign_array_1d (self, array) Assigns a 1-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:) :: array r.h.s. array of reals private pure subroutine assign_array_2d (self, array) Assigns a 2-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: array r.h.s. array of reals generic, public :: operator(+) => spectrum_add_spectrum , spectrum_add_real , real_add_spectrum private pure elemental function spectrum_add_spectrum (self, s2) result(spec) Returns a spectrum instance with the spectrum array values being the sum of\n the two input spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_add_real (self, a) result(spec) Returns a sum of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function real_add_spectrum (a, self) result(spec) Returns a sum of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) generic, public :: operator(-) => spectrum_sub_spectrum , spectrum_sub_real , real_sub_spectrum , spectrum_unary_minus private pure elemental function spectrum_sub_spectrum (self, s2) result(spec) Subtracts one spectrum instance from another and returns the resulting\n spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_sub_real (self, a) result(spec) Returns a difference of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function real_sub_spectrum (a, self) result(spec) Returns a difference between a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_unary_minus (self) result(spec) Returns a negative value of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) generic, public :: operator(*) => spectrum_mult_spectrum , spectrum_mult_real , spectrum_mult_real2d , real_mult_spectrum , real2d_mult_spectrum private pure elemental function spectrum_mult_spectrum (self, s2) result(spec) Returns a product of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_mult_real (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure function spectrum_mult_real2d (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: a r.h.s. real 2-d array Return Value type( spectrum_type ) private pure elemental function real_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure function real2d_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: a l.h.s. real 2-d array class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) generic, public :: operator(/) => spectrum_div_spectrum , spectrum_div_real , real_div_spectrum private pure elemental function spectrum_div_spectrum (self, s2) result(spec) Returns a division of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_div_real (self, a) result(spec) Returns a division of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function real_div_spectrum (a, self) result(spec) Returns a division of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) generic, public :: operator(==) => eq private pure elemental function eq (self, s2) Logical equality comparison function. Overloads the == operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: operator(/=) => neq private pure elemental function neq (self, s2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: operator(>) => gt private pure elemental function gt (self, s2) Logical greater than comparison function. Overloads the > operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: operator(>=) => ge private pure elemental function ge (self, s2) Logical greater than or equal comparison function. Overloads the >= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: operator(  => lt private pure elemental function lt (self, s2) Logical less than comparison function. Overloads the < operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical generic, public :: operator(<=) => le private pure elemental function le (self, s2) Logical less than or equal comparison function. Overloads the <= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Source Code type :: spectrum_type !! Spectrum class. private type ( datetime ) :: start_time !! Simulation start time type ( datetime ) :: end_time !! Simulation end time type ( timedelta ) :: time_step !! Time step [s] real ( kind = rk ), dimension (:,:), allocatable :: spec !! 2-d spectrum real ( kind = rk ), dimension (:), allocatable :: f !! Frequency [Hz] real ( kind = rk ), dimension (:), allocatable :: df !! Frequency spacing [Hz] real ( kind = rk ), dimension (:), allocatable :: k !! Wavenumber [rad/m] real ( kind = rk ), dimension (:), allocatable :: dk !! Wavenumber spacing [rad/m] real ( kind = rk ), dimension (:), allocatable :: th !! Direction [rad] real ( kind = rk ), dimension (:), allocatable :: dth !! Directional spacing [rad] real ( kind = rk ), dimension (:), allocatable :: cp !! Phase speed [m/s] real ( kind = rk ), dimension (:), allocatable :: cg !! Group speed [m/s] real ( kind = rk ), dimension (:), allocatable :: u !! Mean current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), allocatable :: v !! Mean current velocity in y-direction [m/s] real ( kind = rk ), dimension (:), allocatable :: z !! Depth levels for current array [m] real ( kind = rk ) :: air_density !! Air density [kg/m&#94;3] real ( kind = rk ) :: depth !! Mean water depth [m] real ( kind = rk ) :: elevation !! Mean surface elevation [m] real ( kind = rk ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ) :: surface_tension !! Surface tension [N/m] real ( kind = rk ) :: water_density !! Water density [kg/m&#94;3] contains ! Public type-bound methods procedure , public , pass ( self ) :: frequencyMoment procedure , public , pass ( self ) :: getAirDensity procedure , public , pass ( self ) :: getAmplitude procedure , public , pass ( self ) :: getCurrent_u procedure , public , pass ( self ) :: getCurrent_v procedure , public , pass ( self ) :: getDepth procedure , public , pass ( self ) :: getDepthLevels procedure , public , pass ( self ) :: getDirections procedure , public , pass ( self ) :: getDirections2d procedure , public , pass ( self ) :: getElevation procedure , public , pass ( self ) :: getFrequency procedure , public , pass ( self ) :: getFrequency2d procedure , public , pass ( self ) :: getGravity procedure , public , pass ( self ) :: getGroupSpeed procedure , public , pass ( self ) :: getGroupSpeed2d procedure , public , pass ( self ) :: getWaveAction procedure , public , pass ( self ) :: getWavelength procedure , public , pass ( self ) :: getWavenumber procedure , public , pass ( self ) :: getWavenumberSpacing procedure , public , pass ( self ) :: getWavenumber2d procedure , public , pass ( self ) :: getPhaseSpeed procedure , public , pass ( self ) :: getPhaseSpeed2d procedure , public , pass ( self ) :: getSpectrum procedure , public , pass ( self ) :: getSurfaceTension procedure , public , pass ( self ) :: getWaterDensity procedure , public , pass ( self ) :: isAllocated procedure , public , pass ( self ) :: isMonochromatic procedure , public , pass ( self ) :: isOmnidirectional procedure , public , pass ( self ) :: meanPeriod procedure , public , pass ( self ) :: meanPeriodZeroCrossing procedure , public , pass ( self ) :: meanSquareSlope procedure , public , pass ( self ) :: meanSquareSlopeDirectional procedure , public , pass ( self ) :: momentum_x procedure , public , pass ( self ) :: momentum_y procedure , public , pass ( self ) :: momentumFlux_xx procedure , public , pass ( self ) :: momentumFlux_xy procedure , public , pass ( self ) :: momentumFlux_yy procedure , public , pass ( self ) :: omnidirectionalSpectrum procedure , public , pass ( self ) :: peakedness procedure , public , pass ( self ) :: peakFrequency procedure , public , pass ( self ) :: peakFrequencyDiscrete procedure , public , pass ( self ) :: saturationSpectrum procedure , public , pass ( self ) :: setAirDensity procedure , public , pass ( self ) :: setCurrent1d procedure , public , pass ( self ) :: setCurrent2d procedure , public , pass ( self ) :: setDepth procedure , public , pass ( self ) :: setElevation procedure , public , pass ( self ) :: setGravity procedure , public , pass ( self ) :: setSurfaceTension procedure , public , pass ( self ) :: setWaterDensity procedure , public , pass ( self ) :: setSpectrum1d procedure , public , pass ( self ) :: setSpectrum2d procedure , public , pass ( self ) :: significantWaveHeight procedure , public , pass ( self ) :: significantSurfaceOrbitalVelocity procedure , public , pass ( self ) :: stokesDrift procedure , public , pass ( self ) :: stokesDrift2d procedure , public , pass ( self ) :: ursellNumber procedure , public , pass ( self ) :: wavenumberMoment procedure , public , pass ( self ) :: wavenumberSpectrum procedure , public , pass ( self ) :: readJSON procedure , public , pass ( self ) :: writeJSON ! Private methods used to overload arithmetic operators procedure , private , pass ( self ) :: assign_array_1d procedure , private , pass ( self ) :: assign_array_2d procedure , private , pass ( self ) :: real_add_spectrum procedure , private , pass ( self ) :: real_sub_spectrum procedure , private , pass ( self ) :: real_mult_spectrum procedure , private , pass ( self ) :: real_div_spectrum procedure , private , pass ( self ) :: real2d_mult_spectrum procedure , private , pass ( self ) :: spectrum_add_spectrum procedure , private , pass ( self ) :: spectrum_add_real procedure , private , pass ( self ) :: spectrum_sub_spectrum procedure , private , pass ( self ) :: spectrum_sub_real procedure , private , pass ( self ) :: spectrum_mult_spectrum procedure , private , pass ( self ) :: spectrum_mult_real procedure , private , pass ( self ) :: spectrum_mult_real2d procedure , private , pass ( self ) :: spectrum_div_spectrum procedure , private , pass ( self ) :: spectrum_div_real procedure , private , pass ( self ) :: spectrum_unary_minus procedure , private , pass ( self ) :: eq procedure , private , pass ( self ) :: neq procedure , private , pass ( self ) :: gt procedure , private , pass ( self ) :: ge procedure , private , pass ( self ) :: lt procedure , private , pass ( self ) :: le ! Generic procedures generic , public :: setCurrent => setCurrent1d , setCurrent2d generic , public :: setSpectrum => setSpectrum1d , setSpectrum2d ! Generic operators generic :: assignment ( = ) => assign_array_1d ,& assign_array_2d generic :: operator ( + ) => spectrum_add_spectrum ,& spectrum_add_real ,& real_add_spectrum generic :: operator ( - ) => spectrum_sub_spectrum ,& spectrum_sub_real ,& real_sub_spectrum ,& spectrum_unary_minus generic :: operator ( * ) => spectrum_mult_spectrum ,& spectrum_mult_real ,& spectrum_mult_real2d ,& real_mult_spectrum ,& real2d_mult_spectrum generic :: operator ( / ) => spectrum_div_spectrum ,& spectrum_div_real ,& real_div_spectrum generic :: operator ( == ) => eq generic :: operator ( /= ) => neq generic :: operator ( > ) => gt generic :: operator ( >= ) => ge generic :: operator ( < ) => lt generic :: operator ( <= ) => le endtype spectrum_type","tags":"","loc":"type/spectrum_type.html","title":"spectrum_type – wavy "},{"text":"private function constructor_1d(lb, ub, x, dx) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:) :: dx Grid spacing in x-direction [m] Return Value type( grid_type ) Calls proc~~constructor_1d~~CallsGraph proc~constructor_1d constructor_1d y y proc~constructor_1d->y lon lon proc~constructor_1d->lon lat lat proc~constructor_1d->lat interface~diff diff proc~constructor_1d->interface~diff dy dy proc~constructor_1d->dy proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~constructor_1d~~CalledByGraph proc~constructor_1d constructor_1d interface~grid_type grid_type interface~grid_type->proc~constructor_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code constructor_1d Source Code type ( grid_type ) function constructor_1d ( lb , ub , x , dx ) result ( grid ) integer ( kind = intkind ), intent ( in ) :: lb !! Lower bound indices of the grid array integer ( kind = intkind ), intent ( in ) :: ub !! Upper bound indices of the grid array real ( kind = realkind ), dimension (:), intent ( in ), optional :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:), intent ( in ), optional :: dx !! Grid spacing in x-direction [m] integer ( kind = intkind ) :: i grid % lb ( 1 ) = lb grid % ub ( 1 ) = ub grid % lb ( 2 ) = 1 grid % ub ( 2 ) = 1 allocate ( grid % x ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dx ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) if ( present ( x ) . and . . not . present ( dx )) then ! x is given as input argument grid % x (:, 1 ) = x ! Compute dx using centered differences grid % dx (:, 1 ) = diff ( x ) elseif (. not . present ( x ) . and . present ( dx )) then ! dx is given as input argument grid % dx (:, 1 ) = dx ! Compute x using dx provided as input argument grid % x ( 1 , 1 ) = 0 do i = grid % lb ( 1 ) + 1 , grid % ub ( 1 ) grid % x ( i , 1 ) = grid % x ( i - 1 , 1 ) + grid % dx ( i , 1 ) enddo endif allocate ( grid % y ( 0 , 0 )) allocate ( grid % dy ( 0 , 0 )) allocate ( grid % lon ( 0 , 0 )) allocate ( grid % lat ( 0 , 0 )) endfunction constructor_1d","tags":"","loc":"proc/constructor_1d.html","title":"constructor_1d – wavy"},{"text":"private function constructor_2d(lb, ub, x, y, dx, dy, lon, lat) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in), dimension(:) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in), dimension(:) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:,:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: y Distance in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dy Grid spacing in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: lon Longitude [rad] real(kind=realkind), intent(in), optional dimension(:,:) :: lat Latitude [rad] Return Value type( grid_type ) Calls proc~~constructor_2d~~CallsGraph proc~constructor_2d constructor_2d interface~diff diff proc~constructor_2d->interface~diff proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~constructor_2d~~CalledByGraph proc~constructor_2d constructor_2d interface~grid_type grid_type interface~grid_type->proc~constructor_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code constructor_2d Source Code type ( grid_type ) function constructor_2d ( lb , ub , x , y , dx , dy , lon , lat ) result ( grid ) integer ( kind = intkind ), dimension (:), intent ( in ) :: lb !! Lower bound indices of the grid array integer ( kind = intkind ), dimension (:), intent ( in ) :: ub !! Upper bound indices of the grid array real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: x !! Distance in x-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: y !! Distance in y-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: dx !! Grid spacing in x-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: dy !! Grid spacing in y-direction [m] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: lon !! Longitude [rad] real ( kind = realkind ), dimension (:,:), intent ( in ), optional :: lat !! Latitude [rad] integer ( kind = intkind ) :: grid_rank integer ( kind = intkind ) :: idm , jdm integer ( kind = intkind ) :: i , j ! Raise error if lb and ub are not of matching ranks if (. not . size ( lb ) == size ( ub )) then write ( unit = stderr , fmt = '(a)' ) 'Error in grid constructor: size(lb) must == ' & // 'size(ub)' stop 1 endif grid % lb = lb grid % ub = ub allocate ( grid % x ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % y ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dx ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) allocate ( grid % dy ( grid % lb ( 1 ): grid % ub ( 1 ), grid % lb ( 2 ): grid % ub ( 2 ))) if ( present ( x ) . and . present ( y )) then ! x and y are given as input arguments grid % x = x grid % y = y ! Compute dx and dy using centered differences grid % dx = diff ( x , dim = 1 ) grid % dy = diff ( y , dim = 2 ) elseif ( present ( dx ) . and . present ( dy )) then ! dx and dy are given as input arguments grid % dx = dx grid % dy = dy ! Compute x using dx provided as input argument grid % x ( 1 ,:) = 0 do i = grid % lb ( 1 ) + 1 , grid % ub ( 1 ) grid % x ( i ,:) = grid % x ( i - 1 ,:) + grid % dx ( i ,:) enddo ! Compute y using dy provided as input argument grid % y (:, 1 ) = 0 do j = grid % lb ( 2 ) + 1 , grid % ub ( 2 ) grid % y (:, j ) = grid % y (:, j - 1 ) + grid % dy (:, j ) enddo endif endfunction constructor_2d","tags":"","loc":"proc/constructor_2d.html","title":"constructor_2d – wavy"},{"text":"private pure function getLowerBounds(self) result(lb) Returns the lower bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Upper bound indices Source Code getLowerBounds Source Code pure function getLowerBounds ( self ) result ( lb ) !! Returns the lower bounds of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance integer ( kind = intkind ), dimension ( 2 ) :: lb !! Upper bound indices lb = self % lb endfunction getLowerBounds","tags":"","loc":"proc/getlowerbounds.html","title":"getLowerBounds – wavy"},{"text":"private pure function getUpperBounds(self) result(ub) Returns the upper bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Lower bound indices Source Code getUpperBounds Source Code pure function getUpperBounds ( self ) result ( ub ) !! Returns the upper bounds of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance integer ( kind = intkind ), dimension ( 2 ) :: ub !! Lower bound indices ub = self % ub endfunction getUpperBounds","tags":"","loc":"proc/getupperbounds.html","title":"getUpperBounds – wavy"},{"text":"private pure function getAxisX(self) result(x) Returns the x-coordinate of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable x-coordinate [m] Source Code getAxisX Source Code pure function getAxisX ( self ) result ( x ) !! Returns the x-coordinate of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: x !! x-coordinate [m] x = self % x endfunction getAxisX","tags":"","loc":"proc/getaxisx.html","title":"getAxisX – wavy"},{"text":"private pure function getAxisY(self) result(y) Returns the y-coordinate [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable y-coordinate [m] Source Code getAxisY Source Code pure function getAxisY ( self ) result ( y ) !! Returns the y-coordinate [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: y !! y-coordinate [m] y = self % y endfunction getAxisY","tags":"","loc":"proc/getaxisy.html","title":"getAxisY – wavy"},{"text":"private pure function getGridSpacingX(self) result(dx) Returns the grid spacing in x [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable Grid spacing in x [m] Source Code getGridSpacingX Source Code pure function getGridSpacingX ( self ) result ( dx ) !! Returns the grid spacing in x [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: dx !! Grid spacing in x [m] dx = self % dx endfunction getGridSpacingX","tags":"","loc":"proc/getgridspacingx.html","title":"getGridSpacingX – wavy"},{"text":"private pure function getGridSpacingY(self) result(dy) Returns the grid spacing in y [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable Grid spacing in y [m] Source Code getGridSpacingY Source Code pure function getGridSpacingY ( self ) result ( dy ) !! Returns the grid spacing in y [m] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: dy !! Grid spacing in y [m] dy = self % dy endfunction getGridSpacingY","tags":"","loc":"proc/getgridspacingy.html","title":"getGridSpacingY – wavy"},{"text":"private pure function getGridRotation(self) result(alpha) Returns the grid rotation angle [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable Grid rotation [rad] Source Code getGridRotation Source Code pure function getGridRotation ( self ) result ( alpha ) !! Returns the grid rotation angle [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: alpha !! Grid rotation [rad] alpha = self % alpha endfunction getGridRotation","tags":"","loc":"proc/getgridrotation.html","title":"getGridRotation – wavy"},{"text":"private pure function getLongitude(self) result(lon) Returns the longitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable Longitude [rad] Source Code getLongitude Source Code pure function getLongitude ( self ) result ( lon ) !! Returns the longitude array [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: lon !! Longitude [rad] lon = self % lon endfunction getLongitude","tags":"","loc":"proc/getlongitude.html","title":"getLongitude – wavy"},{"text":"private pure function getLatitude(self) result(lat) Returns the latitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:),allocatable Latitude [rad] Source Code getLatitude Source Code pure function getLatitude ( self ) result ( lat ) !! Returns the latitude array [rad] of the grid instance. class ( grid_type ), intent ( in ) :: self !! Grid instance real ( kind = realkind ), dimension (:,:), allocatable :: lat !! Latitude [rad] lat = self % lat endfunction getLatitude","tags":"","loc":"proc/getlatitude.html","title":"getLatitude – wavy"},{"text":"public interface grid_type Calls interface~~grid_type~~CallsGraph interface~grid_type grid_type proc~constructor_1d constructor_1d interface~grid_type->proc~constructor_1d proc~constructor_2d constructor_2d interface~grid_type->proc~constructor_2d y y proc~constructor_1d->y lon lon proc~constructor_1d->lon lat lat proc~constructor_1d->lat interface~diff diff proc~constructor_1d->interface~diff dy dy proc~constructor_1d->dy proc~constructor_2d->interface~diff proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures constructor_1d constructor_2d Module Procedures private function constructor_1d (lb, ub, x, dx) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:) :: dx Grid spacing in x-direction [m] Return Value type( grid_type ) private function constructor_2d (lb, ub, x, y, dx, dy, lon, lat) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in), dimension(:) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in), dimension(:) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:,:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: y Distance in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dy Grid spacing in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: lon Longitude [rad] real(kind=realkind), intent(in), optional dimension(:,:) :: lat Latitude [rad] Return Value type( grid_type )","tags":"","loc":"interface/grid_type.html","title":"grid_type – wavy"},{"text":"public pure elemental function elevation(x, t, a, k, omega) Returns the elevation [m] of a sinusoid wave given its amplitude [m],\n wavenumber [rad/m], and frequency [Hz]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) Called By proc~~elevation~~CalledByGraph proc~elevation elevation proc~pressure pressure proc~pressure->proc~elevation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/elevation.html","title":"elevation – wavy"},{"text":"public pure elemental function pressure(x, z, t, a, k, omega, rho, grav) Returns the pressure [Pa] at depth z (negative downward) for a sinusoid\n wave given its amplitude [m], wavenumber [rad/m], and frequency [Hz]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical displacement [m] from the surface, negative downward real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] real(kind=realkind), intent(in) :: rho Water density [kg/m&#94;3] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) Calls proc~~pressure~~CallsGraph proc~pressure pressure proc~elevation elevation proc~pressure->proc~elevation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pressure.html","title":"pressure – wavy"},{"text":"public pure elemental function horizontalAcceleration(x, z, t, a, k, omega) Returns the horizontal acceleration of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind)","tags":"","loc":"proc/horizontalacceleration.html","title":"horizontalAcceleration – wavy"},{"text":"public pure elemental function horizontalVelocity(x, z, t, a, k, omega) Returns the horizontal velocity of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind)","tags":"","loc":"proc/horizontalvelocity.html","title":"horizontalVelocity – wavy"},{"text":"public pure elemental function verticalAcceleration(x, z, t, a, k, omega) Returns the vertical acceleration of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) Source Code verticalAcceleration Source Code function verticalAcceleration ( x , z , t , a , k , omega ) !! Returns the vertical acceleration of a water particle under a sinusoid wave, !! given its amplitude, wavenumber, and frequency. real ( kind = realkind ), intent ( in ) :: x !! Horizontal space [m] real ( kind = realkind ), intent ( in ) :: z !! Vertical space, negative downward [m] real ( kind = realkind ), intent ( in ) :: t !! Time [s] real ( kind = realkind ), intent ( in ) :: a !! Wave amplitude [m] real ( kind = realkind ), intent ( in ) :: k !! Wavenumber [rad/m] real ( kind = realkind ), intent ( in ) :: omega !! Angular frequency [rad] verticalAcceleration = - a * omega ** 2 * sin ( k * x - omega * t ) * exp ( k * z ) endfunction verticalAcceleration","tags":"","loc":"proc/verticalacceleration.html","title":"verticalAcceleration – wavy"},{"text":"public pure elemental function verticalVelocity(x, z, t, a, k, omega) Returns the vertical velocity of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind)","tags":"","loc":"proc/verticalvelocity.html","title":"verticalVelocity – wavy"},{"text":"private function constructor(grid, spectrum, shallow_water_mode) result(domain) Constructor function for the domain object. Arguments Type Intent Optional Attributes Name type( grid_type ), intent(in) :: grid Input grid instance type( spectrum_type ), intent(in) :: spectrum Input spectrum instance logical, intent(in), optional :: shallow_water_mode Logical switch to enable shallow water solver Return Value type( domain_type ) Calls proc~~constructor~~CallsGraph proc~constructor constructor proc~getfrequency getFrequency proc~constructor->proc~getfrequency depth depth proc~constructor->depth v v proc~constructor->v proc~getdirections getDirections proc~constructor->proc~getdirections lb lb proc~constructor->lb getgridspacingy getgridspacingy proc~constructor->getgridspacingy proc~getupperbounds~2 getUpperBounds proc~constructor->proc~getupperbounds~2 ub ub proc~constructor->ub u u proc~constructor->u getgridspacingx getgridspacingx proc~constructor->getgridspacingx proc~getlowerbounds~2 getLowerBounds proc~constructor->proc~getlowerbounds~2 eta eta proc~constructor->eta proc~getfrequency->proc~getfrequency spectrum spectrum proc~getfrequency->spectrum proc~getdirections->proc~getdirections proc~getdirections->spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~constructor~~CalledByGraph proc~constructor constructor interface~domain_type domain_type interface~domain_type->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code constructor Source Code type ( domain_type ) function constructor ( grid , spectrum , shallow_water_mode ) result ( domain ) !! Constructor function for the domain object. type ( grid_type ), intent ( in ) :: grid !! Input `grid` instance type ( spectrum_type ), intent ( in ) :: spectrum !! Input `spectrum` instance logical , intent ( in ), optional :: shallow_water_mode !! Logical switch to enable shallow water solver integer ( kind = ik ) :: i , j if ( present ( shallow_water_mode )) then domain % shallow_water_mode = shallow_water_mode else domain % shallow_water_mode = . false . endif domain % type_name = 'domain_type' domain % grid = grid domain % lb = grid % getLowerBounds () domain % ub = grid % getUpperBounds () domain % dx = grid % getGridSpacingX () domain % dy = grid % getGridSpacingY () allocate ( domain % spectrum ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) do concurrent ( i = domain % lb ( 1 ): domain % ub ( 1 ),& j = domain % lb ( 2 ): domain % ub ( 2 )) domain % spectrum ( i , j ) = spectrum enddo allocate ( domain % u ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % u = 0 allocate ( domain % v ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % v = 0 allocate ( domain % eta ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % eta = 0 allocate ( domain % depth ( domain % lb ( 1 ): domain % ub ( 1 ),& domain % lb ( 2 ): domain % ub ( 2 ))) domain % nfreqs = size ( spectrum % getFrequency ()) domain % ndirs = size ( spectrum % getDirections ()) endfunction constructor","tags":"","loc":"proc/constructor.html","title":"constructor – wavy"},{"text":"private pure function advect1dRank1(self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works only in cases where ndirs == 1 . This implementation accepts the methods that operate on spectrum arrays\n of rank 1 (omnidirectional) in 1-dimensional space: advectUpwind1stOrder1dRank1 advectCentered2ndOrder1dRank1\n function with the requested advection method Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f real(kind=rk), intent(in), dimension(:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) Calls proc~~advect1drank1~~CallsGraph proc~advect1drank1 advect1dRank1 setspectrumarray setspectrumarray proc~advect1drank1->setspectrumarray proc~getgroupspeed getGroupSpeed proc~advect1drank1->proc~getgroupspeed proc~getspectrumarray getSpectrumArray proc~advect1drank1->proc~getspectrumarray ub ub proc~advect1drank1->ub lb lb proc~advect1drank1->lb proc~getgridspacingxwithhalo getGridSpacingXWithHalo proc~advect1drank1->proc~getgridspacingxwithhalo proc~getgroupspeed->proc~getgroupspeed proc~getgroupspeed->ub proc~getgroupspeed->lb spectrum spectrum proc~getgroupspeed->spectrum hw hw proc~getgroupspeed->hw proc~getspectrumarray->ub proc~getspectrumarray->lb proc~getspectrumarray->spectrum proc~getspectrumarray->hw proc~getspectrum getSpectrum proc~getspectrumarray->proc~getspectrum proc~getgridspacingxwithhalo->ub proc~getgridspacingxwithhalo->lb proc~getgridspacingxwithhalo->hw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advect1dRank1 Source Code pure type ( domain_type ) function advect1dRank1 ( self , advection_method , halowidth ,& directional_type ) result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works only in cases where `ndirs == 1`. !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 1 (omnidirectional) in 1-dimensional space: !! !!   * advectUpwind1stOrder1dRank1 !!   * advectCentered2ndOrder1dRank1 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , dx ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:), intent ( in ) :: u real ( kind = rk ), dimension (:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ), dimension (:), intent ( in ) :: directional_type !! A global constant that helps resolve the interface of this specific !! prodedure integer ( kind = ik ) :: idm real ( kind = rk ), dimension (:,:), allocatable :: f real ( kind = rk ), dimension (:,:), allocatable :: cg real ( kind = rk ), dimension (:), allocatable :: dx associate ( lb => self % lb , ub => self % ub , hw => halowidth ) adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw f = reshape ( self % getSpectrumArray ([ hw , 0 ],. true .),[ self % nfreqs , idm ]) cg = reshape ( self % getGroupSpeed ([ hw , 0 ],. true .),[ self % nfreqs , idm ]) dx = reshape ( self % getGridSpacingXWithHalo ([ hw , 0 ],. true .),[ idm ]) call adv % setSpectrumArray ( advection_method ( f , cg , dx )) endassociate endfunction advect1dRank1","tags":"","loc":"proc/advect1drank1.html","title":"advect1dRank1 – wavy"},{"text":"private pure function advect1dRank2(self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). This implementation accepts the methods that operate on spectrum arrays\n of rank 2 (directional) in 1-dimensional space: advectUpwind1stOrder1dRank2 advectCentered2ndOrder1dRank2\n function with the requested advection method Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:,:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) Calls proc~~advect1drank2~~CallsGraph proc~advect1drank2 advect1dRank2 setspectrumarray setspectrumarray proc~advect1drank2->setspectrumarray proc~getgroupspeed getGroupSpeed proc~advect1drank2->proc~getgroupspeed proc~getspectrumarray getSpectrumArray proc~advect1drank2->proc~getspectrumarray ub ub proc~advect1drank2->ub lb lb proc~advect1drank2->lb proc~getgridspacingxwithhalo getGridSpacingXWithHalo proc~advect1drank2->proc~getgridspacingxwithhalo proc~getgroupspeed->proc~getgroupspeed proc~getgroupspeed->ub proc~getgroupspeed->lb spectrum spectrum proc~getgroupspeed->spectrum hw hw proc~getgroupspeed->hw proc~getspectrumarray->ub proc~getspectrumarray->lb proc~getspectrumarray->spectrum proc~getspectrumarray->hw proc~getspectrum getSpectrum proc~getspectrumarray->proc~getspectrum proc~getgridspacingxwithhalo->ub proc~getgridspacingxwithhalo->lb proc~getgridspacingxwithhalo->hw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advect1dRank2 Source Code pure type ( domain_type ) function advect1dRank2 ( self , advection_method , halowidth ,& directional_type ) result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works both when `ndirs == 1` (omnidirectional) and when !! `ndirs > 1` (directional). !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 2 (directional) in 1-dimensional space: !! !!   * advectUpwind1stOrder1dRank2 !!   * advectCentered2ndOrder1dRank2 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , dx ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u real ( kind = rk ), dimension (:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ), dimension (:,:), intent ( in ) :: directional_type !! A global constant that helps resolve the interface of this specific !! prodedure integer ( kind = ik ) :: idm real ( kind = rk ), dimension (:,:,:), allocatable :: f real ( kind = rk ), dimension (:,:,:), allocatable :: cg real ( kind = rk ), dimension (:), allocatable :: dx associate ( lb => self % lb , ub => self % ub , hw => halowidth ) adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw f = reshape ( self % getSpectrumArray ([ hw , 0 ],. true .),[ self % nfreqs , self % ndirs , idm ]) cg = reshape ( self % getGroupSpeed ([ hw , 0 ],. true .),[ self % nfreqs , self % ndirs , idm ]) dx = reshape ( self % getGridSpacingXWithHalo ([ hw , 0 ],. true .),[ idm ]) call adv % setSpectrumArray ( advection_method ( f , cg , dx )) endassociate endfunction advect1dRank2","tags":"","loc":"proc/advect1drank2.html","title":"advect1dRank2 – wavy"},{"text":"private pure function advect2dRank2(self, advection_method, halowidth) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). This implementation accepts the methods that operate on spectrum arrays\n of rank 2 (directional) in 2-dimensional space: advectUpwind1stOrder2dRank2 advectCentered2ndOrder2dRank2\n function with the requested advection method Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, v, dx, dy) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:,:) :: u real(kind=rk), intent(in), dimension(:,:,:,:) :: v real(kind=rk), intent(in), dimension(:,:) :: dx real(kind=rk), intent(in), dimension(:,:) :: dy Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable integer(kind=ik), intent(in), dimension(:) :: halowidth number of halo cells to use in the advection method Return Value type( domain_type ) Calls proc~~advect2drank2~~CallsGraph proc~advect2drank2 advect2dRank2 ub ub proc~advect2drank2->ub lb lb proc~advect2drank2->lb proc~getspectrumarray getSpectrumArray proc~advect2drank2->proc~getspectrumarray proc~getgroupspeed getGroupSpeed proc~advect2drank2->proc~getgroupspeed proc~getdirections getDirections proc~advect2drank2->proc~getdirections setspectrumarray setspectrumarray proc~advect2drank2->setspectrumarray proc~getgridspacingywithhalo getGridSpacingYWithHalo proc~advect2drank2->proc~getgridspacingywithhalo hw hw proc~advect2drank2->hw proc~getgridspacingxwithhalo getGridSpacingXWithHalo proc~advect2drank2->proc~getgridspacingxwithhalo proc~getspectrumarray->ub proc~getspectrumarray->lb proc~getspectrumarray->hw proc~getspectrum getSpectrum proc~getspectrumarray->proc~getspectrum spectrum spectrum proc~getspectrumarray->spectrum proc~getgroupspeed->ub proc~getgroupspeed->lb proc~getgroupspeed->proc~getgroupspeed proc~getgroupspeed->hw proc~getgroupspeed->spectrum proc~getdirections->proc~getdirections proc~getdirections->spectrum proc~getgridspacingywithhalo->ub proc~getgridspacingywithhalo->lb proc~getgridspacingywithhalo->hw proc~getgridspacingxwithhalo->ub proc~getgridspacingxwithhalo->lb proc~getgridspacingxwithhalo->hw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advect2dRank2 Source Code pure type ( domain_type ) function advect2dRank2 ( self , advection_method , halowidth )& result ( adv ) !! Computes the advective tendency for the domain instance given the desired !! advection method as an input function and the number of halo cells. This !! function works both when `ndirs == 1` (omnidirectional) and when !! `ndirs > 1` (directional). !! !! This implementation accepts the methods that operate on spectrum arrays !! of rank 2 (directional) in 2-dimensional space: !! !!   * advectUpwind1stOrder2dRank2 !!   * advectCentered2ndOrder2dRank2 class ( domain_type ), intent ( in ) :: self !! `domain` instance interface pure function advection_method ( f , u , v , dx , dy ) result ( tendency ) import :: rk real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v real ( kind = rk ), dimension (:,:), intent ( in ) :: dx real ( kind = rk ), dimension (:,:), intent ( in ) :: dy real ( kind = rk ), dimension (:,:,:,:), allocatable :: tendency endfunction advection_method endinterface !! function with the requested advection method integer ( kind = ik ), dimension (:), intent ( in ) :: halowidth !! number of halo cells to use in the advection method integer ( kind = ik ) :: idm , jdm , n real ( kind = rk ), dimension (:,:,:,:), allocatable :: f real ( kind = rk ), dimension (:,:,:), allocatable :: cg real ( kind = rk ), dimension (:,:,:,:), allocatable :: cgx real ( kind = rk ), dimension (:,:,:,:), allocatable :: cgy real ( kind = rk ), dimension (:,:), allocatable :: dx real ( kind = rk ), dimension (:,:), allocatable :: dy real ( kind = rk ), dimension (:), allocatable :: theta associate ( lb => self % lb , ub => self % ub , hw => halowidth ) theta = self % getDirections () adv = self idm = ub ( 1 ) - lb ( 1 ) + 1 + 2 * hw ( 1 ) jdm = ub ( 2 ) - lb ( 2 ) + 1 + 2 * hw ( 2 ) f = reshape ( self % getSpectrumArray ( hw ,. true .),[ self % nfreqs , self % ndirs ,[ idm , jdm ]]) allocate ( cgx ( self % nfreqs , self % ndirs , idm , jdm )) allocate ( cgy ( self % nfreqs , self % ndirs , idm , jdm )) cg = self % getGroupSpeed ( hw ,. true .) do concurrent ( n = 1 : self % ndirs ) cgx (:, n ,:,:) = cos ( theta ( n )) * cg cgy (:, n ,:,:) = sin ( theta ( n )) * cg enddo dx = self % getGridSpacingXWithHalo ( hw ,. true .) dy = self % getGridSpacingYWithHalo ( hw ,. true .) call adv % setSpectrumArray ( advection_method ( f , cgx , cgy , dx , dy )) deallocate ( cgx , cgy ) endassociate endfunction advect2dRank2","tags":"","loc":"proc/advect2drank2.html","title":"advect2dRank2 – wavy"},{"text":"private pure elemental function isAllocated(self) Returns the allocation status of the domains sub-components. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value logical Source Code isAllocated Source Code pure elemental logical function isAllocated ( self ) !! Returns the allocation status of the domains sub-components. class ( domain_type ), intent ( in ) :: self !! `domain` instance isAllocated = allocated ( self % spectrum ) endfunction isAllocated","tags":"","loc":"proc/isallocated.html","title":"isAllocated – wavy"},{"text":"private pure elemental function eq(self, d2) Logical equality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical Calls proc~~eq~~CallsGraph proc~eq eq proc~getspectrum getSpectrum proc~eq->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eq Source Code pure elemental logical function eq ( self , d2 ) !! Logical equality comparison function. Overloads the `/=` operator. class ( domain_type ), intent ( in ) :: self !! l.h.s. `domain` instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. `domain` instance eq = all ( self % getSpectrum () == d2 % getSpectrum ()) endfunction eq","tags":"","loc":"proc/eq.html","title":"eq – wavy"},{"text":"private pure elemental function neq(self, d2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical Source Code neq Source Code pure elemental logical function neq ( self , d2 ) !! Logical inequality comparison function. Overloads the `/=` operator. class ( domain_type ), intent ( in ) :: self !! l.h.s. `domain` instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. `domain` instance neq = . not . self == d2 endfunction neq","tags":"","loc":"proc/neq.html","title":"neq – wavy"},{"text":"private pure elemental function domain_add_domain(self, d2) result(domain) Returns a sum of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) Calls proc~~domain_add_domain~~CallsGraph proc~domain_add_domain domain_add_domain proc~getspectrum getSpectrum proc~domain_add_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_add_domain Source Code pure elemental type ( domain_type ) function domain_add_domain ( self , d2 )& result ( domain ) !! Returns a sum of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () + d2 % getSpectrum () endfunction domain_add_domain","tags":"","loc":"proc/domain_add_domain.html","title":"domain_add_domain – wavy"},{"text":"private pure elemental function domain_sub_domain(self, d2) result(domain) Returns a difference between two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) Calls proc~~domain_sub_domain~~CallsGraph proc~domain_sub_domain domain_sub_domain proc~getspectrum getSpectrum proc~domain_sub_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_sub_domain Source Code pure elemental type ( domain_type ) function domain_sub_domain ( self , d2 )& result ( domain ) !! Returns a difference between two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () - d2 % getSpectrum () endfunction domain_sub_domain","tags":"","loc":"proc/domain_sub_domain.html","title":"domain_sub_domain – wavy"},{"text":"private pure elemental function domain_unary_minus(self) result(domain) Returns a negative domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value type( domain_type ) Calls proc~~domain_unary_minus~~CallsGraph proc~domain_unary_minus domain_unary_minus proc~getspectrum getSpectrum proc~domain_unary_minus->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_unary_minus Source Code pure elemental type ( domain_type ) function domain_unary_minus ( self ) result ( domain ) !! Returns a negative domain instances. class ( domain_type ), intent ( in ) :: self !! domain instance domain = self domain = - self % getSpectrum () endfunction domain_unary_minus","tags":"","loc":"proc/domain_unary_minus.html","title":"domain_unary_minus – wavy"},{"text":"private pure elemental function domain_mult_domain(self, d2) result(domain) Returns a product of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) Calls proc~~domain_mult_domain~~CallsGraph proc~domain_mult_domain domain_mult_domain proc~getspectrum getSpectrum proc~domain_mult_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_mult_domain Source Code pure elemental type ( domain_type ) function domain_mult_domain ( self , d2 )& result ( domain ) !! Returns a product of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () * d2 % getSpectrum () endfunction domain_mult_domain","tags":"","loc":"proc/domain_mult_domain.html","title":"domain_mult_domain – wavy"},{"text":"private pure elemental function domain_div_domain(self, d2) result(domain) Returns a division of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) Calls proc~~domain_div_domain~~CallsGraph proc~domain_div_domain domain_div_domain proc~getspectrum getSpectrum proc~domain_div_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_div_domain Source Code pure elemental type ( domain_type ) function domain_div_domain ( self , d2 )& result ( domain ) !! Returns a division of two domain instances. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance class ( domain_type ), intent ( in ) :: d2 !! r.h.s. domain instance domain = self domain = self % getSpectrum () / d2 % getSpectrum () endfunction domain_div_domain","tags":"","loc":"proc/domain_div_domain.html","title":"domain_div_domain – wavy"},{"text":"private pure elemental function domain_add_real(self, a) result(domain) Returns a sum of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) Calls proc~~domain_add_real~~CallsGraph proc~domain_add_real domain_add_real proc~getspectrum getSpectrum proc~domain_add_real->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_add_real Source Code pure elemental type ( domain_type ) function domain_add_real ( self , a )& result ( domain ) !! Returns a sum of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () + a endfunction domain_add_real","tags":"","loc":"proc/domain_add_real.html","title":"domain_add_real – wavy"},{"text":"private pure elemental function domain_sub_real(self, a) result(domain) Returns a difference between a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) Calls proc~~domain_sub_real~~CallsGraph proc~domain_sub_real domain_sub_real proc~getspectrum getSpectrum proc~domain_sub_real->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_sub_real Source Code pure elemental type ( domain_type ) function domain_sub_real ( self , a ) result ( domain ) !! Returns a difference between a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () - a endfunction domain_sub_real","tags":"","loc":"proc/domain_sub_real.html","title":"domain_sub_real – wavy"},{"text":"private pure elemental function domain_mult_real(self, a) result(domain) Returns a product of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) Calls proc~~domain_mult_real~~CallsGraph proc~domain_mult_real domain_mult_real proc~getspectrum getSpectrum proc~domain_mult_real->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_mult_real Source Code pure elemental type ( domain_type ) function domain_mult_real ( self , a )& result ( domain ) !! Returns a product of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () * a endfunction domain_mult_real","tags":"","loc":"proc/domain_mult_real.html","title":"domain_mult_real – wavy"},{"text":"private pure elemental function domain_div_real(self, a) result(domain) Returns a division of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) Calls proc~~domain_div_real~~CallsGraph proc~domain_div_real domain_div_real proc~getspectrum getSpectrum proc~domain_div_real->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code domain_div_real Source Code pure elemental type ( domain_type ) function domain_div_real ( self , a ) result ( domain ) !! Returns a division of a domain instance and a real number. class ( domain_type ), intent ( in ) :: self !! l.h.s. domain instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number domain = self domain = self % getSpectrum () / a endfunction domain_div_real","tags":"","loc":"proc/domain_div_real.html","title":"domain_div_real – wavy"},{"text":"private pure elemental function real_add_domain(a, self) result(domain) Returns a sum of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) Calls proc~~real_add_domain~~CallsGraph proc~real_add_domain real_add_domain proc~getspectrum getSpectrum proc~real_add_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_add_domain Source Code pure elemental type ( domain_type ) function real_add_domain ( a , self ) result ( domain ) !! Returns a sum of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = self % getSpectrum () + a endfunction real_add_domain","tags":"","loc":"proc/real_add_domain.html","title":"real_add_domain – wavy"},{"text":"private pure elemental function real_sub_domain(a, self) result(domain) Returns a difference between a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) Calls proc~~real_sub_domain~~CallsGraph proc~real_sub_domain real_sub_domain proc~getspectrum getSpectrum proc~real_sub_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_sub_domain Source Code pure elemental type ( domain_type ) function real_sub_domain ( a , self ) result ( domain ) !! Returns a difference between a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = a - self % getSpectrum () endfunction real_sub_domain","tags":"","loc":"proc/real_sub_domain.html","title":"real_sub_domain – wavy"},{"text":"private pure elemental function real_mult_domain(a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) Calls proc~~real_mult_domain~~CallsGraph proc~real_mult_domain real_mult_domain proc~getspectrum getSpectrum proc~real_mult_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_mult_domain Source Code pure elemental type ( domain_type ) function real_mult_domain ( a , self )& result ( domain ) !! Returns a product of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = self % getSpectrum () * a endfunction real_mult_domain","tags":"","loc":"proc/real_mult_domain.html","title":"real_mult_domain – wavy"},{"text":"private pure elemental function real_div_domain(a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) Calls proc~~real_div_domain~~CallsGraph proc~real_div_domain real_div_domain proc~getspectrum getSpectrum proc~real_div_domain->proc~getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_div_domain Source Code pure elemental type ( domain_type ) function real_div_domain ( a , self ) result ( domain ) !! Returns a product of a real number and a domain instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( domain_type ), intent ( in ) :: self !! r.h.s. domain instance domain = self domain = a / self % getSpectrum () endfunction real_div_domain","tags":"","loc":"proc/real_div_domain.html","title":"real_div_domain – wavy"},{"text":"private pure function getCurrent_u(self) result(u) Returns the 3-d array with values of Eulerian velocity (mean current) in \n x-direction [m/s]. Note: this implementation assumes that all u and v velocity arrays in \n the domain instance are of same length in depth, such that the resulting\n u and v arrays are regular 3-d arrays. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Eulerian u-velocity [m/s] Calls proc~~getcurrent_u~~CallsGraph proc~getcurrent_u getCurrent_u proc~getcurrent_u->proc~getcurrent_u lb lb proc~getcurrent_u->lb ub ub proc~getcurrent_u->ub spectrum spectrum proc~getcurrent_u->spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getCurrent_u Source Code pure function getCurrent_u ( self ) result ( u ) !! Returns the 3-d array with values of Eulerian velocity (mean current) in !! x-direction [m/s]. !! !! Note: this implementation assumes that all u and v velocity arrays in !! the domain instance are of same length in depth, such that the resulting !! u and v arrays are regular 3-d arrays. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: u !! Eulerian u-velocity [m/s] integer ( kind = ik ) :: i , j integer ( kind = ik ) :: kdm associate ( lb => self % lb , ub => self % ub ) kdm = size ( self % spectrum ( 1 , 1 ) % getCurrent_u ()) allocate ( u ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ), kdm )) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) u ( i , j ,:) = self % spectrum ( i , j ) % getCurrent_u () enddo endassociate endfunction getCurrent_u","tags":"","loc":"proc/getcurrent_u.html","title":"getCurrent_u – wavy"},{"text":"private pure function getCurrent_v(self) result(v) Returns the 3-d array with values of Eulerian velocity (mean current) in \n y-direction [m/s]. Note: this implementation assumes that all u and v velocity arrays in \n the domain instance are of same length in depth, such that the resulting\n u and v arrays are regular 3-d arrays. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Eulerian v-velocity [m/s] Calls proc~~getcurrent_v~~CallsGraph proc~getcurrent_v getCurrent_v proc~getcurrent_v->proc~getcurrent_v ub ub proc~getcurrent_v->ub spectrum spectrum proc~getcurrent_v->spectrum lb lb proc~getcurrent_v->lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getCurrent_v Source Code pure function getCurrent_v ( self ) result ( v ) !! Returns the 3-d array with values of Eulerian velocity (mean current) in !! y-direction [m/s]. !! !! Note: this implementation assumes that all u and v velocity arrays in !! the domain instance are of same length in depth, such that the resulting !! u and v arrays are regular 3-d arrays. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: v !! Eulerian v-velocity [m/s] integer ( kind = ik ) :: i , j integer ( kind = ik ) :: kdm associate ( lb => self % lb , ub => self % ub ) kdm = size ( self % spectrum ( 1 , 1 ) % getCurrent_v ()) allocate ( v ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ), kdm )) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) v ( i , j ,:) = self % spectrum ( i , j ) % getCurrent_v () enddo endassociate endfunction getCurrent_v","tags":"","loc":"proc/getcurrent_v.html","title":"getCurrent_v – wavy"},{"text":"private pure function getDepth(self) result(depth) Returns the mean water depth [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Mean water depth [m] Source Code getDepth Source Code pure function getDepth ( self ) result ( depth ) !! Returns the mean water depth [m] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: depth !! Mean water depth [m] depth = self % spectrum % getDepth () endfunction getDepth","tags":"","loc":"proc/getdepth.html","title":"getDepth – wavy"},{"text":"private pure function getElevation(self) result(elevation) Returns the mean water elevation [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Mean water elevation [m] Source Code getElevation Source Code pure function getElevation ( self ) result ( elevation ) !! Returns the mean water elevation [m] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: elevation !! Mean water elevation [m] elevation = self % spectrum % getElevation () endfunction getElevation","tags":"","loc":"proc/getelevation.html","title":"getElevation – wavy"},{"text":"private pure function getFrequency(self) result(frequency) Returns the frequency [Hz] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:),allocatable Frequency [Hz] Calls proc~~getfrequency~~CallsGraph proc~getfrequency getFrequency proc~getfrequency->proc~getfrequency spectrum spectrum proc~getfrequency->spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getfrequency~~CalledByGraph proc~getfrequency getFrequency proc~getfrequency->proc~getfrequency proc~writejson writeJSON proc~writejson->proc~getfrequency proc~constructor constructor proc~constructor->proc~getfrequency interface~domain_type domain_type interface~domain_type->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getFrequency Source Code pure function getFrequency ( self ) result ( frequency ) !! Returns the frequency [Hz] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:), allocatable :: frequency !! Frequency [Hz] frequency = self % spectrum ( 1 , 1 ) % getFrequency () endfunction getFrequency","tags":"","loc":"proc/getfrequency.html","title":"getFrequency – wavy"},{"text":"private pure function getDirections(self) result(directions) Returns the spectral direction bins [rad]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:),allocatable Directions [rad] Calls proc~~getdirections~~CallsGraph proc~getdirections getDirections proc~getdirections->proc~getdirections spectrum spectrum proc~getdirections->spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getdirections~~CalledByGraph proc~getdirections getDirections proc~getdirections->proc~getdirections proc~writejson writeJSON proc~writejson->proc~getdirections proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getdirections proc~constructor constructor proc~constructor->proc~getdirections interface~domain_type domain_type interface~domain_type->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getDirections Source Code pure function getDirections ( self ) result ( directions ) !! Returns the spectral direction bins [rad]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:), allocatable :: directions !! Directions [rad] directions = self % spectrum ( 1 , 1 ) % getDirections () endfunction getDirections","tags":"","loc":"proc/getdirections.html","title":"getDirections – wavy"},{"text":"private pure function getGravity(self) result(grav) Returns the gravitational acceleration [m/s&#94;2] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Gravitational acceleration [m/s&#94;2] Source Code getGravity Source Code pure function getGravity ( self ) result ( grav ) !! Returns the gravitational acceleration [m/s&#94;2] array. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: grav !! Gravitational acceleration [m/s&#94;2] grav = self % spectrum % getGravity () endfunction getGravity","tags":"","loc":"proc/getgravity.html","title":"getGravity – wavy"},{"text":"private pure function getGrid(self) result(grid) Returns the grid instance that is the component of the domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( grid_type ) Grid instance component Source Code getGrid Source Code pure function getGrid ( self ) result ( grid ) !! Returns the grid instance that is the component of the domain. class ( domain_type ), intent ( in ) :: self !! Domain instance type ( grid_type ) :: grid !! Grid instance component grid = self % grid endfunction getGrid","tags":"","loc":"proc/getgrid.html","title":"getGrid – wavy"},{"text":"private pure function getLowerBounds(self) result(lb) Returns the lower bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Lower bound indices Called By proc~~getlowerbounds~2~~CalledByGraph proc~getlowerbounds~2 getLowerBounds proc~constructor constructor proc~constructor->proc~getlowerbounds~2 proc~writejson writeJSON proc~writejson->proc~getlowerbounds~2 interface~domain_type domain_type interface~domain_type->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getLowerBounds Source Code pure function getLowerBounds ( self ) result ( lb ) !! Returns the lower bounds of the domain instance. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ) :: lb !! Lower bound indices lb = self % lb endfunction getLowerBounds","tags":"","loc":"proc/getlowerbounds~2.html","title":"getLowerBounds – wavy"},{"text":"private pure function getUpperBounds(self) result(ub) Returns the upper bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Upper bound indices Called By proc~~getupperbounds~2~~CalledByGraph proc~getupperbounds~2 getUpperBounds proc~constructor constructor proc~constructor->proc~getupperbounds~2 proc~writejson writeJSON proc~writejson->proc~getupperbounds~2 interface~domain_type domain_type interface~domain_type->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getUpperBounds Source Code pure function getUpperBounds ( self ) result ( ub ) !! Returns the upper bounds of the domain instance. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ) :: ub !! Upper bound indices ub = self % ub endfunction getUpperBounds","tags":"","loc":"proc/getupperbounds~2.html","title":"getUpperBounds – wavy"},{"text":"private pure function getSpectrum(self) result(spectrum) Returns the array of spectrum instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( spectrum_type ),\n  dimension(:,:),allocatable Array of spectrum instances Called By proc~~getspectrum~~CalledByGraph proc~getspectrum getSpectrum proc~domain_add_real domain_add_real proc~domain_add_real->proc~getspectrum proc~domain_unary_minus domain_unary_minus proc~domain_unary_minus->proc~getspectrum proc~domain_sub_domain domain_sub_domain proc~domain_sub_domain->proc~getspectrum proc~real_add_domain real_add_domain proc~real_add_domain->proc~getspectrum proc~real_sub_domain real_sub_domain proc~real_sub_domain->proc~getspectrum proc~getspectrumarray getSpectrumArray proc~getspectrumarray->proc~getspectrum proc~domain_mult_real domain_mult_real proc~domain_mult_real->proc~getspectrum proc~real_mult_domain real_mult_domain proc~real_mult_domain->proc~getspectrum proc~domain_mult_domain domain_mult_domain proc~domain_mult_domain->proc~getspectrum proc~eq eq proc~eq->proc~getspectrum proc~real_div_domain real_div_domain proc~real_div_domain->proc~getspectrum proc~domain_sub_real domain_sub_real proc~domain_sub_real->proc~getspectrum proc~domain_div_real domain_div_real proc~domain_div_real->proc~getspectrum proc~domain_add_domain domain_add_domain proc~domain_add_domain->proc~getspectrum proc~domain_div_domain domain_div_domain proc~domain_div_domain->proc~getspectrum proc~advect1drank2 advect1dRank2 proc~advect1drank2->proc~getspectrumarray proc~writejson writeJSON proc~writejson->proc~getspectrumarray proc~advect1drank1 advect1dRank1 proc~advect1drank1->proc~getspectrumarray proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getspectrumarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getSpectrum Source Code pure function getSpectrum ( self ) result ( spectrum ) !! Returns the array of spectrum instances. class ( domain_type ), intent ( in ) :: self !! Domain instance type ( spectrum_type ), dimension (:,:), allocatable :: spectrum !! Array of spectrum instances spectrum = self % spectrum endfunction getSpectrum","tags":"","loc":"proc/getspectrum.html","title":"getSpectrum – wavy"},{"text":"private pure function getSpectrumArray(self, halowidth, periodic) result(spectrum_array) Returns a 4-dimensional spectrum array, where the first two dimensions are\n frequency and directional dimensions and the second two are spatial x and y\n dimensions. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:,:),allocatable Spectrum array Calls proc~~getspectrumarray~~CallsGraph proc~getspectrumarray getSpectrumArray proc~getspectrum getSpectrum proc~getspectrumarray->proc~getspectrum ub ub proc~getspectrumarray->ub spectrum spectrum proc~getspectrumarray->spectrum hw hw proc~getspectrumarray->hw lb lb proc~getspectrumarray->lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getspectrumarray~~CalledByGraph proc~getspectrumarray getSpectrumArray proc~advect1drank2 advect1dRank2 proc~advect1drank2->proc~getspectrumarray proc~writejson writeJSON proc~writejson->proc~getspectrumarray proc~advect1drank1 advect1dRank1 proc~advect1drank1->proc~getspectrumarray proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getspectrumarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getSpectrumArray Source Code pure function getSpectrumArray ( self , halowidth , periodic ) result ( spectrum_array ) !! Returns a 4-dimensional spectrum array, where the first two dimensions are !! frequency and directional dimensions and the second two are spatial x and y !! dimensions. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:,:), allocatable :: spectrum_array !! Spectrum array integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integers indicating how many cells to allocate for halo points logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions integer ( kind = ik ) :: i , j integer ( kind = ik ) :: ndirs , nfreqs associate ( lb => self % lb , ub => self % ub , hw => halowidth ) nfreqs = size ( self % spectrum ( 1 , 1 ) % getSpectrum (), dim = 1 ) ndirs = size ( self % spectrum ( 1 , 1 ) % getSpectrum (), dim = 2 ) allocate ( spectrum_array ( nfreqs , ndirs , lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ),& lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) spectrum_array (:,:, i , j ) = self % spectrum ( i , j ) % getSpectrum () enddo ! Set halo values for periodic boundary conditions if ( periodic ) then spectrum_array (:,:, lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:)& = spectrum_array (:,:, ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) spectrum_array (:,:, ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:)& = spectrum_array (:,:, lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) spectrum_array (:,:,:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 )& = spectrum_array (:,:,:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) spectrum_array (:,:,:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 ))& = spectrum_array (:,:,:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getSpectrumArray","tags":"","loc":"proc/getspectrumarray.html","title":"getSpectrumArray – wavy"},{"text":"private pure function getPhaseSpeed(self) result(cp) Returns a 3-d array with phase speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Phase speed [m/s] array Calls proc~~getphasespeed~~CallsGraph proc~getphasespeed getPhaseSpeed proc~getphasespeed->proc~getphasespeed lb lb proc~getphasespeed->lb spectrum spectrum proc~getphasespeed->spectrum ub ub proc~getphasespeed->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getPhaseSpeed Source Code pure function getPhaseSpeed ( self ) result ( cp ) !! Returns a 3-d array with phase speed values [m/s]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: cp !! Phase speed [m/s] array integer ( kind = ik ) :: i , j integer ( kind = ik ) :: ndirs associate ( lb => self % lb , ub => self % ub ) allocate ( cp ( self % nfreqs , lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) cp (:, i , j ) = self % spectrum ( i , j ) % getPhaseSpeed () enddo endassociate endfunction getPhaseSpeed","tags":"","loc":"proc/getphasespeed.html","title":"getPhaseSpeed – wavy"},{"text":"private pure function getGroupSpeed(self, halowidth, periodic) result(cg) Returns a 3-d array with group speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Group speed [m/s] array Calls proc~~getgroupspeed~~CallsGraph proc~getgroupspeed getGroupSpeed proc~getgroupspeed->proc~getgroupspeed lb lb proc~getgroupspeed->lb spectrum spectrum proc~getgroupspeed->spectrum hw hw proc~getgroupspeed->hw ub ub proc~getgroupspeed->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getgroupspeed~~CalledByGraph proc~getgroupspeed getGroupSpeed proc~getgroupspeed->proc~getgroupspeed proc~advect1drank2 advect1dRank2 proc~advect1drank2->proc~getgroupspeed proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getgroupspeed proc~advect1drank1 advect1dRank1 proc~advect1drank1->proc~getgroupspeed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getGroupSpeed Source Code pure function getGroupSpeed ( self , halowidth , periodic ) result ( cg ) !! Returns a 3-d array with group speed values [m/s]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), allocatable :: cg !! Group speed [m/s] array integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integers indicating how many cells to allocate for halo points logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( cg ( self % nfreqs , lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) cg (:, i , j ) = self % spectrum ( i , j ) % getGroupSpeed () enddo ! Set halo values for periodic boundary conditions if ( periodic ) then cg (:, lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = cg (:, ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) cg (:, ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = cg (:, lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) cg (:,:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = cg (:,:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) cg (:,:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = cg (:,:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGroupSpeed","tags":"","loc":"proc/getgroupspeed.html","title":"getGroupSpeed – wavy"},{"text":"private pure function getGridSpacingXWithHalo(self, halowidth, periodic) result(dx) Returns grid spacing array in x-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:),allocatable Grid spacing in x [m] Calls proc~~getgridspacingxwithhalo~~CallsGraph proc~getgridspacingxwithhalo getGridSpacingXWithHalo lb lb proc~getgridspacingxwithhalo->lb hw hw proc~getgridspacingxwithhalo->hw ub ub proc~getgridspacingxwithhalo->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getgridspacingxwithhalo~~CalledByGraph proc~getgridspacingxwithhalo getGridSpacingXWithHalo proc~advect1drank2 advect1dRank2 proc~advect1drank2->proc~getgridspacingxwithhalo proc~advect1drank1 advect1dRank1 proc~advect1drank1->proc~getgridspacingxwithhalo proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getgridspacingxwithhalo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getGridSpacingXWithHalo Source Code pure function getGridSpacingXWithHalo ( self , halowidth , periodic ) result ( dx ) !! Returns grid spacing array in x-direction including halo cells. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integer width of halo region logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions real ( kind = rk ), dimension (:,:), allocatable :: dx !! Grid spacing in x [m] associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( dx ( lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) dx = 0 dx ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 )) = self % dx ! Set halo values for periodic boundary conditions if ( periodic ) then dx ( lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = dx ( ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) dx ( ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = dx ( lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) dx (:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = dx (:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) dx (:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = dx (:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGridSpacingXWithHalo","tags":"","loc":"proc/getgridspacingxwithhalo.html","title":"getGridSpacingXWithHalo – wavy"},{"text":"private pure function getGridSpacingYWithHalo(self, halowidth, periodic) result(dy) Returns grid spacing array in y-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:),allocatable Grid spacing in y [m] Calls proc~~getgridspacingywithhalo~~CallsGraph proc~getgridspacingywithhalo getGridSpacingYWithHalo lb lb proc~getgridspacingywithhalo->lb hw hw proc~getgridspacingywithhalo->hw ub ub proc~getgridspacingywithhalo->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~getgridspacingywithhalo~~CalledByGraph proc~getgridspacingywithhalo getGridSpacingYWithHalo proc~advect2drank2 advect2dRank2 proc~advect2drank2->proc~getgridspacingywithhalo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getGridSpacingYWithHalo Source Code pure function getGridSpacingYWithHalo ( self , halowidth , periodic ) result ( dy ) !! Returns grid spacing array in y-direction including halo cells. class ( domain_type ), intent ( in ) :: self !! Domain instance integer ( kind = ik ), dimension ( 2 ), intent ( in ) :: halowidth !! Integer width of halo region logical , intent ( in ) :: periodic !! If `.true.`, halo cells will be updated with values corresponding to !! periodic boundary conditions real ( kind = rk ), dimension (:,:), allocatable :: dy !! Grid spacing in y [m] associate ( lb => self % lb , ub => self % ub , hw => halowidth ) allocate ( dy ( lb ( 1 ) - hw ( 1 ): ub ( 1 ) + hw ( 1 ), lb ( 2 ) - hw ( 2 ): ub ( 2 ) + hw ( 2 ))) dy = 0 dy ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 )) = self % dy ! Set halo values for periodic boundary conditions if ( periodic ) then dy ( lb ( 1 ) - hw ( 1 ): lb ( 1 ) - 1 ,:) = dy ( ub ( 1 ) - hw ( 1 ) + 1 : ub ( 1 ),:) dy ( ub ( 1 ) + 1 : ub ( 1 ) + hw ( 1 ),:) = dy ( lb ( 1 ): lb ( 1 ) + hw ( 1 ) - 1 ,:) dy (:, lb ( 2 ) - hw ( 2 ): lb ( 2 ) - 1 ) = dy (:, ub ( 2 ) - hw ( 2 ) + 1 : ub ( 2 )) dy (:, ub ( 2 ) + 1 : ub ( 2 ) + hw ( 2 )) = dy (:, lb ( 2 ): lb ( 2 ) + hw ( 2 ) - 1 ) endif endassociate endfunction getGridSpacingYWithHalo","tags":"","loc":"proc/getgridspacingywithhalo.html","title":"getGridSpacingYWithHalo – wavy"},{"text":"private pure function getSurfaceTension(self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Surface tension [N/m] Source Code getSurfaceTension Source Code pure function getSurfaceTension ( self ) result ( surface_tension ) !! Returns the surface tension [N/m]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: surface_tension !! Surface tension [N/m] surface_tension = self % spectrum % getSurfaceTension () endfunction getSurfaceTension","tags":"","loc":"proc/getsurfacetension.html","title":"getSurfaceTension – wavy"},{"text":"private pure function getAirDensity(self) result(air_density) Returns the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Air density [kg/m&#94;3] Source Code getAirDensity Source Code pure function getAirDensity ( self ) result ( air_density ) !! Returns the air density [kg/m&#94;3]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: air_density !! Air density [kg/m&#94;3] air_density = self % spectrum % getAirDensity () endfunction getAirDensity","tags":"","loc":"proc/getairdensity.html","title":"getAirDensity – wavy"},{"text":"private pure function getWaterDensity(self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Water density [kg/m&#94;3] Source Code getWaterDensity Source Code pure function getWaterDensity ( self ) result ( water_density ) !! Returns the water density [kg/m&#94;3]. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: water_density !! Water density [kg/m&#94;3] water_density = self % spectrum % getWaterDensity () endfunction getWaterDensity","tags":"","loc":"proc/getwaterdensity.html","title":"getWaterDensity – wavy"},{"text":"private pure function frequencyMoment(self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:),allocatable Source Code frequencyMoment Source Code pure function frequencyMoment ( self , n ) result ( moment ) !! Returns the spectral frequency moment of order n. class ( domain_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ), intent ( in ) :: n !! Order real ( kind = rk ), dimension (:,:), allocatable :: moment moment = self % spectrum % frequencyMoment ( n ) endfunction frequencyMoment","tags":"","loc":"proc/frequencymoment.html","title":"frequencyMoment – wavy"},{"text":"private pure function wavenumberMoment(self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:),allocatable Source Code wavenumberMoment Source Code pure function wavenumberMoment ( self , n ) result ( moment ) !! Returns the spectral frequency moment of order n. class ( domain_type ), intent ( in ) :: self !! Spectrum instance integer ( kind = ik ), intent ( in ) :: n !! Order real ( kind = rk ), dimension (:,:), allocatable :: moment moment = self % spectrum % wavenumberMoment ( n ) endfunction wavenumberMoment","tags":"","loc":"proc/wavenumbermoment.html","title":"wavenumberMoment – wavy"},{"text":"private pure function meanPeriod(self) Returns the mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Mean period [s] array Source Code meanPeriod Source Code pure function meanPeriod ( self ) !! Returns the mean wave period [s] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: meanPeriod !! Mean period [s] array meanPeriod = self % spectrum % meanPeriod () endfunction meanPeriod","tags":"","loc":"proc/meanperiod.html","title":"meanPeriod – wavy"},{"text":"private pure function meanPeriodZeroCrossing(self) Returns the zero-crossing mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Mean period [s] array Source Code meanPeriodZeroCrossing Source Code pure function meanPeriodZeroCrossing ( self ) !! Returns the zero-crossing mean wave period [s] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: meanPeriodZeroCrossing !! Mean period [s] array meanPeriodZeroCrossing = self % spectrum % meanPeriodZeroCrossing () endfunction meanPeriodZeroCrossing","tags":"","loc":"proc/meanperiodzerocrossing.html","title":"meanPeriodZeroCrossing – wavy"},{"text":"private pure function significantWaveHeight(self) result(hs) Returns the significant wave height [m] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Significant wave height [m] array Source Code significantWaveHeight Source Code pure function significantWaveHeight ( self ) result ( hs ) !! Returns the significant wave height [m] for the whole domain. class ( domain_type ), intent ( in ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), allocatable :: hs !! Significant wave height [m] array hs = self % spectrum % significantWaveHeight () endfunction significantWaveHeight","tags":"","loc":"proc/significantwaveheight.html","title":"significantWaveHeight – wavy"},{"text":"private pure subroutine assign_spectrum_array_1d(self, spectrum_array) Assigns a 1-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:) :: spectrum_array r.h.s. array of spectrum instances Calls proc~~assign_spectrum_array_1d~~CallsGraph proc~assign_spectrum_array_1d assign_spectrum_array_1d setspectrum setspectrum proc~assign_spectrum_array_1d->setspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_spectrum_array_1d Source Code pure subroutine assign_spectrum_array_1d ( self , spectrum_array ) !! Assigns a 1-d array of `spectrum` instances to a `domain` instance. This !! procedure overloads the assignment ('=') operator. class ( domain_type ), intent ( inout ) :: self !! l.h.s. `domain` instance class ( spectrum_type ), dimension (:), intent ( in ) :: spectrum_array !! r.h.s. array of `spectrum` instances call self % setSpectrum ( spectrum_array ) endsubroutine assign_spectrum_array_1d","tags":"","loc":"proc/assign_spectrum_array_1d.html","title":"assign_spectrum_array_1d – wavy"},{"text":"private pure subroutine assign_spectrum_array_2d(self, spectrum_array) Assigns a 2-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:,:) :: spectrum_array r.h.s. array of spectrum instances Calls proc~~assign_spectrum_array_2d~~CallsGraph proc~assign_spectrum_array_2d assign_spectrum_array_2d setspectrum setspectrum proc~assign_spectrum_array_2d->setspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_spectrum_array_2d Source Code pure subroutine assign_spectrum_array_2d ( self , spectrum_array ) !! Assigns a 2-d array of `spectrum` instances to a `domain` instance. This !! procedure overloads the assignment ('=') operator. class ( domain_type ), intent ( inout ) :: self !! l.h.s. `domain` instance class ( spectrum_type ), dimension (:,:), intent ( in ) :: spectrum_array !! r.h.s. array of `spectrum` instances call self % setSpectrum ( spectrum_array ) endsubroutine assign_spectrum_array_2d","tags":"","loc":"proc/assign_spectrum_array_2d.html","title":"assign_spectrum_array_2d – wavy"},{"text":"private pure subroutine setDepth(self, depth) Sets the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: depth Mean water depth [m] Source Code setDepth Source Code pure subroutine setDepth ( self , depth ) !! Sets the mean water depth [m]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: depth !! Mean water depth [m] call self % spectrum % setDepth ( depth ) endsubroutine setDepth","tags":"","loc":"proc/setdepth.html","title":"setDepth – wavy"},{"text":"private pure subroutine setElevation(self, elevation) Sets the mean water elevation [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: elevation Mean water elevation [m] Source Code setElevation Source Code pure subroutine setElevation ( self , elevation ) !! Sets the mean water elevation [m]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: elevation !! Mean water elevation [m] call self % spectrum % setElevation ( elevation ) endsubroutine setElevation","tags":"","loc":"proc/setelevation.html","title":"setElevation – wavy"},{"text":"private pure subroutine setGravity(self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: grav Gravitational acceleration [m/s&#94;2] Source Code setGravity Source Code pure subroutine setGravity ( self , grav ) !! Sets the gravitational acceleration [m/s&#94;2]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] call self % spectrum % setGravity ( grav ) endsubroutine setGravity","tags":"","loc":"proc/setgravity.html","title":"setGravity – wavy"},{"text":"private pure subroutine setSurfaceTension(self, surface_tension) Sets the surface tension [N/m&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: surface_tension Surface tension [N/m&#94;2] Source Code setSurfaceTension Source Code pure subroutine setSurfaceTension ( self , surface_tension ) !! Sets the surface tension [N/m&#94;2]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: surface_tension !! Surface tension [N/m&#94;2] call self % spectrum % setSurfaceTension ( surface_tension ) endsubroutine setSurfaceTension","tags":"","loc":"proc/setsurfacetension.html","title":"setSurfaceTension – wavy"},{"text":"private pure subroutine setAirDensity(self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: air_density Air density [kg/m&#94;3] Source Code setAirDensity Source Code pure subroutine setAirDensity ( self , air_density ) !! Sets the air density [kg/m&#94;3]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: air_density !! Air density [kg/m&#94;3] call self % spectrum % setAirDensity ( air_density ) endsubroutine setAirDensity","tags":"","loc":"proc/setairdensity.html","title":"setAirDensity – wavy"},{"text":"private pure subroutine setWaterDensity(self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: water_density Water density [kg/m&#94;3] Source Code setWaterDensity Source Code pure subroutine setWaterDensity ( self , water_density ) !! Sets the water density [kg/m&#94;3]. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: water_density !! Water density [kg/m&#94;3] call self % spectrum % setWaterDensity ( water_density ) endsubroutine setWaterDensity","tags":"","loc":"proc/setwaterdensity.html","title":"setWaterDensity – wavy"},{"text":"private pure subroutine setSpectrum1d(self, spectrum) Sets the 1-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:) :: spectrum Input 1-d array of spectrum object instances Calls proc~~setspectrum1d~~CallsGraph proc~setspectrum1d setSpectrum1d lb lb proc~setspectrum1d->lb ub ub proc~setspectrum1d->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setSpectrum1d Source Code pure subroutine setSpectrum1d ( self , spectrum ) !! Sets the 1-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( domain_type ), intent ( inout ) :: self !! Domain instance type ( spectrum_type ), dimension (:), intent ( in ) :: spectrum !! Input 1-d array of spectrum object instances integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) self % spectrum ( i , j ) = spectrum ( i ) enddo endassociate endsubroutine setSpectrum1d","tags":"","loc":"proc/setspectrum1d.html","title":"setSpectrum1d – wavy"},{"text":"private pure subroutine setSpectrum2d(self, spectrum) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:,:) :: spectrum Input 2-d array of spectrum object instances Calls proc~~setspectrum2d~~CallsGraph proc~setspectrum2d setSpectrum2d lb lb proc~setspectrum2d->lb ub ub proc~setspectrum2d->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setSpectrum2d Source Code pure subroutine setSpectrum2d ( self , spectrum ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( domain_type ), intent ( inout ) :: self !! Domain instance type ( spectrum_type ), dimension (:,:), intent ( in ) :: spectrum !! Input 2-d array of spectrum object instances integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) self % spectrum ( i , j ) = spectrum ( i , j ) enddo endassociate endsubroutine setSpectrum2d","tags":"","loc":"proc/setspectrum2d.html","title":"setSpectrum2d – wavy"},{"text":"private pure subroutine setSpectrumArray1d1d(self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for omnidirectional spectrum in 1-d space (1d-1d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: spectrum_array Spectrum array Calls proc~~setspectrumarray1d1d~~CallsGraph proc~setspectrumarray1d1d setSpectrumArray1d1d lb lb proc~setspectrumarray1d1d->lb spectrum spectrum proc~setspectrumarray1d1d->spectrum setspectrum setspectrum proc~setspectrumarray1d1d->setspectrum ub ub proc~setspectrumarray1d1d->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setSpectrumArray1d1d Source Code pure subroutine setSpectrumArray1d1d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for omnidirectional spectrum in 1-d space (1d-1d) class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:, i )) enddo endassociate endsubroutine setSpectrumArray1d1d","tags":"","loc":"proc/setspectrumarray1d1d.html","title":"setSpectrumArray1d1d – wavy"},{"text":"private pure subroutine setSpectrumArray1d2d(self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for setting 1-d spectrum into 2-d physical space\n of 2-d spectrum into 1-d physical space. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:) :: spectrum_array Spectrum array Calls proc~~setspectrumarray1d2d~~CallsGraph proc~setspectrumarray1d2d setSpectrumArray1d2d lb lb proc~setspectrumarray1d2d->lb spectrum spectrum proc~setspectrumarray1d2d->spectrum setspectrum setspectrum proc~setspectrumarray1d2d->setspectrum ub ub proc~setspectrumarray1d2d->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setSpectrumArray1d2d Source Code pure subroutine setSpectrumArray1d2d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for setting 1-d spectrum into 2-d physical space !! of 2-d spectrum into 1-d physical space. class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) if ( lb ( 2 ) == ub ( 2 )) then ! Setting 2-d spectrum into 1-d physical space do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:,:, i )) enddo else ! Setting 1-d spectrum into 2-d physical space do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:, i , j )) enddo endif endassociate endsubroutine setSpectrumArray1d2d","tags":"","loc":"proc/setspectrumarray1d2d.html","title":"setSpectrumArray1d2d – wavy"},{"text":"private pure subroutine setSpectrumArray2d2d(self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for directional spectrum in 2-d space (2d-2d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:,:) :: spectrum_array Spectrum array Calls proc~~setspectrumarray2d2d~~CallsGraph proc~setspectrumarray2d2d setSpectrumArray2d2d lb lb proc~setspectrumarray2d2d->lb spectrum spectrum proc~setspectrumarray2d2d->spectrum setspectrum setspectrum proc~setspectrumarray2d2d->setspectrum ub ub proc~setspectrumarray2d2d->ub Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setSpectrumArray2d2d Source Code pure subroutine setSpectrumArray2d2d ( self , spectrum_array ) !! Sets the spectrum instances based on input spectrum array. !! This implementation is for directional spectrum in 2-d space (2d-2d) class ( domain_type ), intent ( inout ) :: self !! Domain instance real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: spectrum_array !! Spectrum array integer ( kind = ik ) :: i , j associate ( lb => self % lb , ub => self % ub ) do concurrent ( i = lb ( 1 ): ub ( 1 ), j = lb ( 2 ): ub ( 2 )) call self % spectrum ( i , j ) % setSpectrum ( spectrum_array (:,:, i , j )) enddo endassociate endsubroutine setSpectrumArray2d2d","tags":"","loc":"proc/setspectrumarray2d2d.html","title":"setSpectrumArray2d2d – wavy"},{"text":"private subroutine writeJSON(self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file Calls proc~~writejson~~CallsGraph proc~writejson writeJSON proc~getfrequency getFrequency proc~writejson->proc~getfrequency destroy destroy proc~writejson->destroy getaxisy getaxisy proc~writejson->getaxisy proc~getdirections getDirections proc~writejson->proc~getdirections initialize initialize proc~writejson->initialize proc~getupperbounds~2 getUpperBounds proc~writejson->proc~getupperbounds~2 proc~getspectrumarray getSpectrumArray proc~writejson->proc~getspectrumarray getaxisx getaxisx proc~writejson->getaxisx add add proc~writejson->add proc~getlowerbounds~2 getLowerBounds proc~writejson->proc~getlowerbounds~2 create_object create_object proc~writejson->create_object proc~getfrequency->proc~getfrequency spectrum spectrum proc~getfrequency->spectrum proc~getdirections->proc~getdirections proc~getdirections->spectrum proc~getspectrumarray->spectrum proc~getspectrum getSpectrum proc~getspectrumarray->proc~getspectrum ub ub proc~getspectrumarray->ub hw hw proc~getspectrumarray->hw lb lb proc~getspectrumarray->lb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code writeJSON Source Code subroutine writeJSON ( self , filename , minify ) !! Writes a spectrum instance to a JSON file. class ( domain_type ), intent ( in ) :: self !! `domain` instance character ( len =* ), intent ( in ) :: filename !! JSON file name logical , intent ( in ) :: minify !! Logical switch to minify the JSON file type ( json_core ) :: json type ( json_value ), pointer :: ptr call json % initialize ( no_whitespace = minify , real_format = 'ES' ) call json % create_object ( ptr , '' ) call json % add ( ptr , 'lb' , self % grid % getLowerBounds ()) call json % add ( ptr , 'ub' , self % grid % getUpperBounds ()) call json % add ( ptr , 'x' , pack ( self % grid % getAxisX (),. true .)) call json % add ( ptr , 'y' , pack ( self % grid % getAxisY (),. true .)) !call json % add(ptr,'lon',pack(self % grid % getLongitude(),.true.)) !call json % add(ptr,'lat',pack(self % grid % getLatitude(),.true.)) call json % add ( ptr , 'u' , pack ( self % u ,. true .)) call json % add ( ptr , 'v' , pack ( self % v ,. true .)) call json % add ( ptr , 'eta' , pack ( self % eta ,. true .)) call json % add ( ptr , 'depth' , pack ( self % depth ,. true .)) call json % add ( ptr , 'frequency' , self % getFrequency ()) call json % add ( ptr , 'directions' , self % getDirections ()) call json % add ( ptr , 'spectrum' ,& pack ( self % getSpectrumArray ([ 0 , 0 ],. false .),. true .)) call json % print ( ptr , trim ( filename )) call json % destroy ( ptr ) endsubroutine writeJSON","tags":"","loc":"proc/writejson.html","title":"writeJSON – wavy"},{"text":"public interface domain_type Calls interface~~domain_type~~CallsGraph interface~domain_type domain_type proc~constructor constructor interface~domain_type->proc~constructor proc~getfrequency getFrequency proc~constructor->proc~getfrequency depth depth proc~constructor->depth v v proc~constructor->v proc~getdirections getDirections proc~constructor->proc~getdirections lb lb proc~constructor->lb getgridspacingy getgridspacingy proc~constructor->getgridspacingy proc~getupperbounds~2 getUpperBounds proc~constructor->proc~getupperbounds~2 ub ub proc~constructor->ub u u proc~constructor->u getgridspacingx getgridspacingx proc~constructor->getgridspacingx proc~getlowerbounds~2 getLowerBounds proc~constructor->proc~getlowerbounds~2 eta eta proc~constructor->eta proc~getfrequency->proc~getfrequency spectrum spectrum proc~getfrequency->spectrum proc~getdirections->proc~getdirections proc~getdirections->spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures constructor Module Procedures private function constructor (grid, spectrum, shallow_water_mode) result(domain) Constructor function for the domain object. Arguments Type Intent Optional Attributes Name type( grid_type ), intent(in) :: grid Input grid instance type( spectrum_type ), intent(in) :: spectrum Input spectrum instance logical, intent(in), optional :: shallow_water_mode Logical switch to enable shallow water solver Return Value type( domain_type )","tags":"","loc":"interface/domain_type.html","title":"domain_type – wavy"},{"text":"private pure function advectUpwind1stOrder1dRank0(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectUpwind1stOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:),allocatable Advective tendency Called By proc~~advectupwind1storder1drank0~~CalledByGraph proc~advectupwind1storder1drank0 advectUpwind1stOrder1dRank0 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder1drank0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder1dRank0 Source Code pure function advectUpwind1stOrder1dRank0 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i integer ( kind = ik ) :: idm idm = size ( f ) allocate ( dfdt ( 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 ) dfdt ( i ) = - 0.5_rk * (( u ( i + 1 ) + abs ( u ( i + 1 ))) * f ( i ) & + ( u ( i + 1 ) - abs ( u ( i + 1 ))) * f ( i + 1 )& - ( u ( i ) + abs ( u ( i ))) * f ( i - 1 ) & - ( u ( i ) - abs ( u ( i ))) * f ( i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank0","tags":"","loc":"proc/advectupwind1storder1drank0.html","title":"advectUpwind1stOrder1dRank0 – wavy"},{"text":"public pure function advectUpwind1stOrder1dRank1(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. This function is for 2-dimensional input arrays. It is overloaded by the advectUpwind1stOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:),allocatable Advective tendency Called By proc~~advectupwind1storder1drank1~~CalledByGraph proc~advectupwind1storder1drank1 advectUpwind1stOrder1dRank1 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder1drank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder1dRank1 Source Code pure function advectUpwind1stOrder1dRank1 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 2-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m integer ( kind = ik ) :: idm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) allocate ( dfdt ( mdm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm ) dfdt ( m , i ) = - 0.5_rk * (( u ( m , i + 1 ) + abs ( u ( m , i + 1 ))) * f ( m , i ) & + ( u ( m , i + 1 ) - abs ( u ( m , i + 1 ))) * f ( m , i + 1 )& - ( u ( m , i ) + abs ( u ( m , i ))) * f ( m , i - 1 ) & - ( u ( m , i ) - abs ( u ( m , i ))) * f ( m , i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank1","tags":"","loc":"proc/advectupwind1storder1drank1.html","title":"advectUpwind1stOrder1dRank1 – wavy"},{"text":"public pure function advectUpwind1stOrder1dRank2(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 This function is for 3-dimensional input arrays. It is overloaded by the advectUpwind1stOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Advective tendency Called By proc~~advectupwind1storder1drank2~~CalledByGraph proc~advectupwind1storder1drank2 advectUpwind1stOrder1dRank2 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder1drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder1dRank2 Source Code pure function advectUpwind1stOrder1dRank2 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a first order, !! positive-definite upwind differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! This function is for 3-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder1d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m , n integer ( kind = ik ) :: idm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i ) = - 0.5_rk * (( u ( m , n , i + 1 ) + abs ( u ( m , n , i + 1 ))) * f ( m , n , i ) & + ( u ( m , n , i + 1 ) - abs ( u ( m , n , i + 1 ))) * f ( m , n , i + 1 )& - ( u ( m , n , i ) + abs ( u ( m , n , i ))) * f ( m , n , i - 1 ) & - ( u ( m , n , i ) - abs ( u ( m , n , i ))) * f ( m , n , i )) & / dx ( i ) enddo endfunction advectUpwind1stOrder1dRank2","tags":"","loc":"proc/advectupwind1storder1drank2.html","title":"advectUpwind1stOrder1dRank2 – wavy"},{"text":"private pure function advectUpwind1stOrder2dRank0(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectUpwind1stOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:),allocatable Advective tendency Called By proc~~advectupwind1storder2drank0~~CalledByGraph proc~advectupwind1storder2drank0 advectUpwind1stOrder2dRank0 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder2drank0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder2dRank0 Source Code pure function advectUpwind1stOrder2dRank0 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j integer ( kind = ik ) :: idm , jdm idm = size ( f , dim = 1 ) jdm = size ( f , dim = 2 ) allocate ( dfdt ( 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 ) dfdt ( i , j ) = - 0.25_rk & * (( u ( i + 1 , j ) + abs ( u ( i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( i , j ) & + ( u ( i + 1 , j ) - abs ( u ( i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( i + 1 , j )& - ( u ( i , j ) + abs ( u ( i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( i - 1 , j ) & - ( u ( i , j ) - abs ( u ( i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( i , j ) & + ( v ( i , j ) + abs ( v ( i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( i , j ) & + ( v ( i , j ) - abs ( v ( i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( i + 1 , j ) & - ( v ( i , j - 1 ) + abs ( v ( i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( i - 1 , j )& - ( v ( i , j - 1 ) - abs ( v ( i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank0","tags":"","loc":"proc/advectupwind1storder2drank0.html","title":"advectUpwind1stOrder2dRank0 – wavy"},{"text":"public pure function advectUpwind1stOrder2dRank1(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectUpwind1stOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Advective tendency Called By proc~~advectupwind1storder2drank1~~CalledByGraph proc~advectupwind1storder2drank1 advectUpwind1stOrder2dRank1 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder2drank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder2dRank1 Source Code pure function advectUpwind1stOrder2dRank1 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m integer ( kind = ik ) :: idm , jdm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) jdm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm ) dfdt ( m , i , j ) = - 0.25_rk & * (( u ( m , i + 1 , j ) + abs ( u ( m , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , i , j ) & + ( u ( m , i + 1 , j ) - abs ( u ( m , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , i + 1 , j )& - ( u ( m , i , j ) + abs ( u ( m , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , i - 1 , j ) & - ( u ( m , i , j ) - abs ( u ( m , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , i , j ) & + ( v ( m , i , j ) + abs ( v ( m , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , i , j ) & + ( v ( m , i , j ) - abs ( v ( m , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , i + 1 , j ) & - ( v ( m , i , j - 1 ) + abs ( v ( m , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , i - 1 , j )& - ( v ( m , i , j - 1 ) - abs ( v ( m , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank1","tags":"","loc":"proc/advectupwind1storder2drank1.html","title":"advectUpwind1stOrder2dRank1 – wavy"},{"text":"public pure function advectUpwind1stOrder2dRank2(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectUpwind1stOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:),allocatable Advective tendency Called By proc~~advectupwind1storder2drank2~~CalledByGraph proc~advectupwind1storder2drank2 advectUpwind1stOrder2dRank2 interface~advectupwind1storder advectUpwind1stOrder interface~advectupwind1storder->proc~advectupwind1storder2drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectUpwind1stOrder2dRank2 Source Code pure function advectUpwind1stOrder2dRank2 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a first !! order, positive-definite upwind differencing. Fields f, u, and v are !! defined on a semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectUpwind1stOrder2d` procedure. real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m , n integer ( kind = ik ) :: idm , jdm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) jdm = size ( f , dim = 4 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i , j ) = - 0.25_rk & * (( u ( m , n , i + 1 , j ) + abs ( u ( m , n , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , n , i , j ) & + ( u ( m , n , i + 1 , j ) - abs ( u ( m , n , i + 1 , j ))) * ( dy ( i , j ) + dy ( i + 1 , j )) * f ( m , n , i + 1 , j )& - ( u ( m , n , i , j ) + abs ( u ( m , n , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , n , i - 1 , j ) & - ( u ( m , n , i , j ) - abs ( u ( m , n , i , j ))) * ( dy ( i - 1 , j ) + dy ( i , j )) * f ( m , n , i , j ) & + ( v ( m , n , i , j ) + abs ( v ( m , n , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , n , i , j ) & + ( v ( m , n , i , j ) - abs ( v ( m , n , i , j ))) * ( dx ( i , j ) + dx ( i , j + 1 )) * f ( m , n , i + 1 , j ) & - ( v ( m , n , i , j - 1 ) + abs ( v ( m , n , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , n , i - 1 , j )& - ( v ( m , n , i , j - 1 ) - abs ( v ( m , n , i , j - 1 ))) * ( dx ( i , j - 1 ) + dx ( i , j )) * f ( m , n , i , j )) & / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectUpwind1stOrder2dRank2","tags":"","loc":"proc/advectupwind1storder2drank2.html","title":"advectUpwind1stOrder2dRank2 – wavy"},{"text":"private pure function advectCentered2ndOrder1dRank0(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectCentered2ndOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:),allocatable Advective tendency Called By proc~~advectcentered2ndorder1drank0~~CalledByGraph proc~advectcentered2ndorder1drank0 advectCentered2ndOrder1dRank0 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder1dRank0 Source Code pure function advectCentered2ndOrder1dRank0 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i integer ( kind = ik ) :: idm idm = size ( f ) allocate ( dfdt ( 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 ) dfdt ( i ) = - 0.5_rk * ( u ( i + 1 ) * ( f ( i ) + f ( i + 1 ))& - u ( i ) * ( f ( i - 1 ) + f ( i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank0","tags":"","loc":"proc/advectcentered2ndorder1drank0.html","title":"advectCentered2ndOrder1dRank0 – wavy"},{"text":"public pure function advectCentered2ndOrder1dRank1(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. This function is for 2-dimensional input arrays. It is overloaded by the advectCentered2ndOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:),allocatable Advective tendency Called By proc~~advectcentered2ndorder1drank1~~CalledByGraph proc~advectcentered2ndorder1drank1 advectCentered2ndOrder1dRank1 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder1dRank1 Source Code pure function advectCentered2ndOrder1dRank1 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 2-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m integer ( kind = ik ) :: idm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) allocate ( dfdt ( mdm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm ) dfdt ( m , i ) = - 0.5_rk * ( u ( m , i + 1 ) * ( f ( m , i ) + f ( m , i + 1 ))& - u ( m , i ) * ( f ( m , i - 1 ) + f ( m , i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank1","tags":"","loc":"proc/advectcentered2ndorder1drank1.html","title":"advectCentered2ndOrder1dRank1 – wavy"},{"text":"public pure function advectCentered2ndOrder1dRank2(f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: --u---f---u---f---u---f--\n   |  i-1  |   i   |  i+1 The differentiation range is [2,size(f)-1], so 1 halo cell on each end\n needs to be set priod to calling this function. This function is for 3-dimensional input arrays. It is overloaded by the advectCentered2ndOrder1d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Advective tendency Called By proc~~advectcentered2ndorder1drank2~~CalledByGraph proc~advectcentered2ndorder1drank2 advectCentered2ndOrder1dRank2 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder1dRank2 Source Code pure function advectCentered2ndOrder1dRank2 ( f , u , dx ) result ( dfdt ) !! Computes the advective tendency of an input field f given the advective !! velocity field u [m/s] and grid spacing dx [m], using a second order !! centered differencing. Fields f and u are defined on a !! semi-staggered Arakawa C-grid: !! !! --u---f---u---f---u---f-- !!   |  i-1  |   i   |  i+1 !! !! The differentiation range is [2,size(f)-1], so 1 halo cell on each end !! needs to be set priod to calling this function. !! !! This function is for 3-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder1d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: dx !! Grid spacing [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , m , n integer ( kind = ik ) :: idm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i ) = - 0.5_rk * ( u ( m , n , i + 1 ) * ( f ( m , n , i ) + f ( m , n , i + 1 ))& - u ( m , n , i ) * ( f ( m , n , i - 1 ) + f ( m , n , i ))) & / dx ( i ) enddo endfunction advectCentered2ndOrder1dRank2","tags":"","loc":"proc/advectcentered2ndorder1drank2.html","title":"advectCentered2ndOrder1dRank2 – wavy"},{"text":"private pure function advectCentered2ndOrder2dRank0(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectCentered2ndOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:),allocatable Advective tendency Called By proc~~advectcentered2ndorder2drank0~~CalledByGraph proc~advectcentered2ndorder2drank0 advectCentered2ndOrder2dRank0 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder2dRank0 Source Code pure function advectCentered2ndOrder2dRank0 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j integer ( kind = ik ) :: idm , jdm idm = size ( f , dim = 1 ) jdm = size ( f , dim = 2 ) allocate ( dfdt ( 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 ) dfdt ( i , j ) = - 0.25_rk * ( u ( i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( i , j ) + f ( i + 1 , j )) & - u ( i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( i - 1 , j ) + f ( i , j )) & + v ( i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( i , j ) + f ( i , j + 1 )) & - v ( i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( i , j - 1 ) + f ( i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank0","tags":"","loc":"proc/advectcentered2ndorder2drank0.html","title":"advectCentered2ndOrder2dRank0 – wavy"},{"text":"private pure function advectCentered2ndOrder2dRank1(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectCentered2ndOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Advective tendency Called By proc~~advectcentered2ndorder2drank1~~CalledByGraph proc~advectcentered2ndorder2drank1 advectCentered2ndOrder2dRank1 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder2dRank1 Source Code pure function advectCentered2ndOrder2dRank1 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m integer ( kind = ik ) :: idm , jdm , mdm mdm = size ( f , dim = 1 ) idm = size ( f , dim = 2 ) jdm = size ( f , dim = 3 ) allocate ( dfdt ( mdm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm ) dfdt ( m , i , j ) = - 0.25_rk & * ( u ( m , i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( m , i , j ) + f ( m , i + 1 , j )) & - u ( m , i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( m , i - 1 , j ) + f ( m , i , j )) & + v ( m , i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( m , i , j ) + f ( m , i , j + 1 )) & - v ( m , i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( m , i , j - 1 ) + f ( m , i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank1","tags":"","loc":"proc/advectcentered2ndorder2drank1.html","title":"advectCentered2ndOrder2dRank1 – wavy"},{"text":"private pure function advectCentered2ndOrder2dRank2(f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: --+---v---+---v---+---v--\n   |       |       | j+1   u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n  j    u   f   u   f   u   f\n       |       |       |\n     --+---v---+---v---+---v--\n       |       |       |\n j-1   u   f   u   f   u   f\n       |  i-1  |   i   |  i+1 The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1\n halo cell on each end needs to be set priod to calling this function. This function is for 1-dimensional input arrays. It is overloaded by the advectCentered2ndOrder2d procedure. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:),allocatable Advective tendency Called By proc~~advectcentered2ndorder2drank2~~CalledByGraph proc~advectcentered2ndorder2drank2 advectCentered2ndOrder2dRank2 interface~advectcentered2ndorder advectCentered2ndOrder interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code advectCentered2ndOrder2dRank2 Source Code pure function advectCentered2ndOrder2dRank2 ( f , u , v , dx , dy ) result ( dfdt ) !! Computes the 2-d advective tendency of an input field f given the advective !! velocity field u and v [m/s] and grid spacing dx and dy [m], using a second !! order centered differencing. Fields f, u, and v are defined on a !! semi-staggered Arakawa C-grid: !! !!     --+---v---+---v---+---v-- !!       |       |       | !! j+1   u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !!  j    u   f   u   f   u   f !!       |       |       | !!     --+---v---+---v---+---v-- !!       |       |       | !! j-1   u   f   u   f   u   f !!       |  i-1  |   i   |  i+1 !! !! The differentiation range is [2:size(f,dim=1)-1,2:size(f,dim=2)-1], so 1 !! halo cell on each end needs to be set priod to calling this function. !! !! This function is for 1-dimensional input arrays. It is overloaded by the !! `advectCentered2ndOrder2d` procedure. real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: f !! Input field to be advected real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: u !! Advective velocity in x-direction [m/s] real ( kind = rk ), dimension (:,:,:,:), intent ( in ) :: v !! Advective velocity in y-direction [m/s] real ( kind = rk ), dimension (:,:), intent ( in ) :: dx !! Grid spacing in x-direction [m] real ( kind = rk ), dimension (:,:), intent ( in ) :: dy !! Grid spacing in y-direction [m] real ( kind = rk ), dimension (:,:,:,:), allocatable :: dfdt !! Advective tendency integer ( kind = ik ) :: i , j , m , n integer ( kind = ik ) :: idm , jdm , mdm , ndm mdm = size ( f , dim = 1 ) ndm = size ( f , dim = 2 ) idm = size ( f , dim = 3 ) jdm = size ( f , dim = 4 ) allocate ( dfdt ( mdm , ndm , 2 : idm - 1 , 2 : jdm - 1 )) dfdt = 0 do concurrent ( i = 2 : idm - 1 , j = 2 : jdm - 1 , m = 1 : mdm , n = 1 : ndm ) dfdt ( m , n , i , j ) = - 0.25_rk & * ( u ( m , n , i + 1 , j ) * ( dy ( i , j ) + dy ( i + 1 , j )) * ( f ( m , n , i , j ) + f ( m , n , i + 1 , j )) & - u ( m , n , i , j ) * ( dy ( i - 1 , j ) + dy ( i , j )) * ( f ( m , n , i - 1 , j ) + f ( m , n , i , j )) & + v ( m , n , i , j ) * ( dy ( i , j ) + dy ( i , j + 1 )) * ( f ( m , n , i , j ) + f ( m , n , i , j + 1 )) & - v ( m , n , i , j - 1 ) * ( dy ( i , j - 1 ) + dy ( i , j )) * ( f ( m , n , i , j - 1 ) + f ( m , n , i , j )))& / ( dx ( i , j ) * dy ( i , j )) enddo endfunction advectCentered2ndOrder2dRank2","tags":"","loc":"proc/advectcentered2ndorder2drank2.html","title":"advectCentered2ndOrder2dRank2 – wavy"},{"text":"public interface advectUpwind1stOrder Calls interface~~advectupwind1storder~~CallsGraph interface~advectupwind1storder advectUpwind1stOrder proc~advectupwind1storder1drank0 advectUpwind1stOrder1dRank0 interface~advectupwind1storder->proc~advectupwind1storder1drank0 proc~advectupwind1storder1drank1 advectUpwind1stOrder1dRank1 interface~advectupwind1storder->proc~advectupwind1storder1drank1 proc~advectupwind1storder2drank0 advectUpwind1stOrder2dRank0 interface~advectupwind1storder->proc~advectupwind1storder2drank0 proc~advectupwind1storder1drank2 advectUpwind1stOrder1dRank2 interface~advectupwind1storder->proc~advectupwind1storder1drank2 proc~advectupwind1storder2drank1 advectUpwind1stOrder2dRank1 interface~advectupwind1storder->proc~advectupwind1storder2drank1 proc~advectupwind1storder2drank2 advectUpwind1stOrder2dRank2 interface~advectupwind1storder->proc~advectupwind1storder2drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures advectUpwind1stOrder1dRank0 advectUpwind1stOrder1dRank1 advectUpwind1stOrder1dRank2 advectUpwind1stOrder2dRank0 advectUpwind1stOrder2dRank1 advectUpwind1stOrder2dRank2 Module Procedures private pure function advectUpwind1stOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectUpwind1stOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency","tags":"","loc":"interface/advectupwind1storder.html","title":"advectUpwind1stOrder – wavy"},{"text":"public interface advectCentered2ndOrder Calls interface~~advectcentered2ndorder~~CallsGraph interface~advectcentered2ndorder advectCentered2ndOrder proc~advectcentered2ndorder1drank0 advectCentered2ndOrder1dRank0 interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank0 proc~advectcentered2ndorder2drank1 advectCentered2ndOrder2dRank1 interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank1 proc~advectcentered2ndorder1drank1 advectCentered2ndOrder1dRank1 interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank1 proc~advectcentered2ndorder2drank2 advectCentered2ndOrder2dRank2 interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank2 proc~advectcentered2ndorder2drank0 advectCentered2ndOrder2dRank0 interface~advectcentered2ndorder->proc~advectcentered2ndorder2drank0 proc~advectcentered2ndorder1drank2 advectCentered2ndOrder1dRank2 interface~advectcentered2ndorder->proc~advectcentered2ndorder1drank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures advectCentered2ndOrder1dRank0 advectCentered2ndOrder1dRank1 advectCentered2ndOrder1dRank2 advectCentered2ndOrder2dRank0 advectCentered2ndOrder2dRank1 advectCentered2ndOrder2dRank2 Module Procedures private pure function advectCentered2ndOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency","tags":"","loc":"interface/advectcentered2ndorder.html","title":"advectCentered2ndOrder – wavy"},{"text":"private pure function diff_1d(x) result(dx) Returns a centered-difference of a 1-d array, with first order\n differencing applied for the boundary points. This procedure is overloaded\n by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:),allocatable Called By proc~~diff_1d~~CalledByGraph proc~diff_1d diff_1d interface~diff diff interface~diff->proc~diff_1d proc~constructor_1d constructor_1d proc~constructor_1d->interface~diff proc~readjson readJSON proc~readjson->interface~diff proc~constructor_2d constructor_2d proc~constructor_2d->interface~diff proc~constructor~2 constructor proc~constructor~2->interface~diff interface~grid_type grid_type interface~grid_type->proc~constructor_1d interface~grid_type->proc~constructor_2d interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code diff_1d Source Code pure function diff_1d ( x ) result ( dx ) !! Returns a centered-difference of a 1-d array, with first order !! differencing applied for the boundary points. This procedure is overloaded !! by the generic procedure `diff`. real ( kind = rk ), dimension (:), intent ( in ) :: x !! Input array real ( kind = rk ), dimension (:), allocatable :: dx integer ( kind = ik ) :: idm idm = size ( x ) allocate ( dx ( idm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif dx ( 2 : idm - 1 ) = 0.5_rk * ( x ( 3 : idm ) - x ( 1 : idm - 2 )) dx ( 1 ) = x ( 2 ) - x ( 1 ) dx ( idm ) = x ( idm ) - x ( idm - 1 ) endfunction diff_1d","tags":"","loc":"proc/diff_1d.html","title":"diff_1d – wavy"},{"text":"private pure function diff_2d(x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n first order differencing applied for the boundary points. This procedure is\n overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:),allocatable Called By proc~~diff_2d~~CalledByGraph proc~diff_2d diff_2d interface~diff diff interface~diff->proc~diff_2d proc~constructor_1d constructor_1d proc~constructor_1d->interface~diff proc~readjson readJSON proc~readjson->interface~diff proc~constructor_2d constructor_2d proc~constructor_2d->interface~diff proc~constructor~2 constructor proc~constructor~2->interface~diff interface~grid_type grid_type interface~grid_type->proc~constructor_1d interface~grid_type->proc~constructor_2d interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code diff_2d Source Code pure function diff_2d ( x , dim ) result ( dx ) !! Returns a centered-difference of a 2-d array along dimension dim, with !! first order differencing applied for the boundary points. This procedure is !! overloaded by the generic procedure `diff`. real ( kind = rk ), dimension (:,:), intent ( in ) :: x !! Input array integer ( kind = ik ), intent ( in ) :: dim !! Dimension along which to differentiate real ( kind = rk ), dimension (:,:), allocatable :: dx integer ( kind = ik ) :: idm , jdm idm = size ( x , dim = 1 ) jdm = size ( x , dim = 2 ) allocate ( dx ( idm , jdm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif if ( dim == 1 ) then dx ( 2 : idm - 1 ,:) = 0.5_rk * ( x ( 3 : idm ,:) - x ( 1 : idm - 2 ,:)) dx ( 1 ,:) = x ( 2 ,:) - x ( 1 ,:) dx ( idm ,:) = x ( idm ,:) - x ( idm - 1 ,:) elseif ( dim == 2 ) then dx (:, 2 : idm - 1 ) = 0.5_rk * ( x (:, 3 : idm ) - x (:, 1 : idm - 2 )) dx (:, 1 ) = x ( 2 ,:) - x (:, 1 ) dx (:, idm ) = x (:, idm ) - x (:, idm - 1 ) else dx = 0 endif endfunction diff_2d","tags":"","loc":"proc/diff_2d.html","title":"diff_2d – wavy"},{"text":"private pure function diff_periodic_1d(x) result(dx) Returns a centered-difference of a 1-d array with periodic boundary\n conditions. This procedure is overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:),allocatable Called By proc~~diff_periodic_1d~~CalledByGraph proc~diff_periodic_1d diff_periodic_1d interface~diff_periodic diff_periodic interface~diff_periodic->proc~diff_periodic_1d proc~constructor~2 constructor proc~constructor~2->interface~diff_periodic proc~readjson readJSON proc~readjson->interface~diff_periodic interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code diff_periodic_1d Source Code pure function diff_periodic_1d ( x ) result ( dx ) !! Returns a centered-difference of a 1-d array with periodic boundary !! conditions. This procedure is overloaded by the generic procedure `diff`. real ( kind = rk ), dimension (:), intent ( in ) :: x !! Input array real ( kind = rk ), dimension (:), allocatable :: dx integer ( kind = ik ) :: idm idm = size ( x ) allocate ( dx ( idm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif dx ( 2 : idm - 1 ) = 0.5_rk * ( x ( 3 : idm ) - x ( 1 : idm - 2 )) dx ( 1 ) = 0.5_rk * ( x ( 2 ) - x ( idm )) dx ( idm ) = 0.5_rk * ( x ( 1 ) - x ( idm - 1 )) endfunction diff_periodic_1d","tags":"","loc":"proc/diff_periodic_1d.html","title":"diff_periodic_1d – wavy"},{"text":"private pure function diff_periodic_2d(x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n periodic boundary conditions. This procedure is overloaded by the generic\n procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:),allocatable Called By proc~~diff_periodic_2d~~CalledByGraph proc~diff_periodic_2d diff_periodic_2d interface~diff_periodic diff_periodic interface~diff_periodic->proc~diff_periodic_2d proc~constructor~2 constructor proc~constructor~2->interface~diff_periodic proc~readjson readJSON proc~readjson->interface~diff_periodic interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code diff_periodic_2d Source Code pure function diff_periodic_2d ( x , dim ) result ( dx ) !! Returns a centered-difference of a 2-d array along dimension dim, with !! periodic boundary conditions. This procedure is overloaded by the generic !! procedure `diff`. real ( kind = rk ), dimension (:,:), intent ( in ) :: x !! Input array integer ( kind = ik ), intent ( in ) :: dim !! Dimension along which to differentiate real ( kind = rk ), dimension (:,:), allocatable :: dx integer ( kind = ik ) :: idm , jdm idm = size ( x , dim = 1 ) jdm = size ( x , dim = 2 ) allocate ( dx ( idm , jdm )) if ( idm == 0 ) then return elseif ( idm == 1 ) then dx = 0 return endif if ( dim == 1 ) then dx ( 2 : idm - 1 ,:) = 0.5_rk * ( x ( 3 : idm ,:) - x ( 1 : idm - 2 ,:)) dx ( 1 ,:) = 0.5_rk * ( x ( 2 ,:) - x ( idm ,:)) dx ( idm ,:) = 0.5_rk * ( x ( 1 ,:) - x ( idm - 1 ,:)) elseif ( dim == 2 ) then dx (:, 2 : idm - 1 ) = 0.5_rk * ( x (:, 3 : idm ) - x (:, 1 : idm - 2 )) dx (:, 1 ) = 0.5_rk * ( x (:, 2 ) - x (:, idm )) dx (:, idm ) = 0.5_rk * ( x (:, 1 ) - x (:, idm - 1 )) else dx = 0 endif endfunction diff_periodic_2d","tags":"","loc":"proc/diff_periodic_2d.html","title":"diff_periodic_2d – wavy"},{"text":"private pure function ones_int(length, kindflag) result(ones) Returns a 1-d array of integer ones. This procedure is overloaded by the\n generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:),allocatable Called By proc~~ones_int~~CalledByGraph proc~ones_int ones_int interface~ones ones interface~ones->proc~ones_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ones_int Source Code pure function ones_int ( length , kindflag ) result ( ones ) !! Returns a 1-d array of integer ones. This procedure is overloaded by the !! generic procedure `ones`. integer ( kind = ik ), intent ( in ) :: length !! Array length integer ( kind = ik ), intent ( in ) :: kindflag !! Array type integer ( kind = ik ), dimension (:), allocatable :: ones allocate ( ones ( length )) ones = 1 endfunction ones_int","tags":"","loc":"proc/ones_int.html","title":"ones_int – wavy"},{"text":"private pure function ones_real(length, kindflag) result(ones) Returns a 1-d array of floating-point ones. This procedure is overloaded by\n the generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:),allocatable Called By proc~~ones_real~~CalledByGraph proc~ones_real ones_real interface~ones ones interface~ones->proc~ones_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ones_real Source Code pure function ones_real ( length , kindflag ) result ( ones ) !! Returns a 1-d array of floating-point ones. This procedure is overloaded by !! the generic procedure `ones`. integer ( kind = ik ), intent ( in ) :: length !! Array length real ( kind = rk ), intent ( in ) :: kindflag !! Array type real ( kind = rk ), dimension (:), allocatable :: ones allocate ( ones ( length )) ones = 1._rk endfunction ones_real","tags":"","loc":"proc/ones_real.html","title":"ones_real – wavy"},{"text":"private pure function range_int(start, end, increment) result(range) Returns an array of integers given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: start Start value of the array integer(kind=ik), intent(in) :: end End value of the array integer(kind=ik), intent(in), optional :: increment Array increment Return Value integer(kind=ik),\n  dimension(:),allocatable Called By proc~~range_int~~CalledByGraph proc~range_int range_int interface~range range interface~range->proc~range_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code range_int Source Code pure function range_int ( start , end , increment ) result ( range ) !! Returns an array of integers given start, end, and increment values. If the !! increment argument is not passed, default increment is 1. This procedure is !! overloaded by the generic procedure `range`. integer ( kind = ik ), intent ( in ) :: start !! Start value of the array integer ( kind = ik ), intent ( in ) :: end !! End value of the array integer ( kind = ik ), intent ( in ), optional :: increment !! Array increment integer ( kind = ik ), dimension (:), allocatable :: range integer ( kind = ik ) :: i integer ( kind = ik ) :: increment_ integer ( kind = ik ) :: length if ( present ( increment )) then increment_ = increment else increment_ = 1 endif length = ( end - start ) / increment_ + 1 allocate ( range ( length )) do concurrent ( i = 1 : length ) range ( i ) = start + ( i - 1 ) * increment_ enddo endfunction range_int","tags":"","loc":"proc/range_int.html","title":"range_int – wavy"},{"text":"private pure function range_real(start, end, increment) result(range) Returns an array of reals given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: start Start value of the array real(kind=rk), intent(in) :: end End value of the array real(kind=rk), intent(in), optional :: increment Array increment Return Value real(kind=rk),\n  dimension(:),allocatable Called By proc~~range_real~~CalledByGraph proc~range_real range_real interface~range range interface~range->proc~range_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code range_real Source Code pure function range_real ( start , end , increment ) result ( range ) !! Returns an array of reals given start, end, and increment values. If the !! increment argument is not passed, default increment is 1. This procedure is !! overloaded by the generic procedure `range`. real ( kind = rk ), intent ( in ) :: start !! Start value of the array real ( kind = rk ), intent ( in ) :: end !! End value of the array real ( kind = rk ), intent ( in ), optional :: increment !! Array increment real ( kind = rk ), dimension (:), allocatable :: range real ( kind = rk ) :: increment_ integer ( kind = ik ) :: i integer ( kind = ik ) :: length if ( present ( increment )) then increment_ = increment else increment_ = 1 endif length = int (( end - start ) / increment_ ) + 1 allocate ( range ( length )) do concurrent ( i = 1 : length ) range ( i ) = start + ( i - 1 ) * increment_ enddo endfunction range_real","tags":"","loc":"proc/range_real.html","title":"range_real – wavy"},{"text":"private pure function tile_1d_int(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:),allocatable Called By proc~~tile_1d_int~~CalledByGraph proc~tile_1d_int tile_1d_int interface~tile tile interface~tile->proc~tile_1d_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_1d_int Source Code pure function tile_1d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 1-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array ), n )) do concurrent ( i = 1 : n ) tiled_array (:, i ) = array (:) enddo endfunction tile_1d_int","tags":"","loc":"proc/tile_1d_int.html","title":"tile_1d_int – wavy"},{"text":"private pure function tile_1d_real(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:),allocatable Called By proc~~tile_1d_real~~CalledByGraph proc~tile_1d_real tile_1d_real interface~tile tile interface~tile->proc~tile_1d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_1d_real Source Code pure function tile_1d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 1-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array ), n )) do concurrent ( i = 1 : n ) tiled_array (:, i ) = array (:) enddo endfunction tile_1d_real","tags":"","loc":"proc/tile_1d_real.html","title":"tile_1d_real – wavy"},{"text":"private pure function tile_2d_int(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:),allocatable Called By proc~~tile_2d_int~~CalledByGraph proc~tile_2d_int tile_2d_int interface~tile tile interface~tile->proc~tile_2d_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_2d_int Source Code pure function tile_2d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 2-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:, i ) = array (:,:) enddo endfunction tile_2d_int","tags":"","loc":"proc/tile_2d_int.html","title":"tile_2d_int – wavy"},{"text":"private pure function tile_2d_real(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:),allocatable Called By proc~~tile_2d_real~~CalledByGraph proc~tile_2d_real tile_2d_real interface~tile tile interface~tile->proc~tile_2d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_2d_real Source Code pure function tile_2d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 2-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:, i ) = array (:,:) enddo endfunction tile_2d_real","tags":"","loc":"proc/tile_2d_real.html","title":"tile_2d_real – wavy"},{"text":"private pure function tile_3d_int(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:,:),allocatable Called By proc~~tile_3d_int~~CalledByGraph proc~tile_3d_int tile_3d_int interface~tile tile interface~tile->proc~tile_3d_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_3d_int Source Code pure function tile_3d_int ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 3-d input array of integers. This !! procedure is overloaded by the generic procedure `tile`. integer ( kind = ik ), dimension (:,:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array integer ( kind = ik ), dimension (:,:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:,:, i ) = array (:,:,:) enddo endfunction tile_3d_int","tags":"","loc":"proc/tile_3d_int.html","title":"tile_3d_int – wavy"},{"text":"private pure function tile_3d_real(array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:,:),allocatable Called By proc~~tile_3d_real~~CalledByGraph proc~tile_3d_real tile_3d_real interface~tile tile interface~tile->proc~tile_3d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tile_3d_real Source Code pure function tile_3d_real ( array , n ) result ( tiled_array ) !! Tiles the input array `n` times. Returns a tiled array that has rank equal !! to `size(shape(array))+1` and that has values equal to values of `array`, !! repeated `n` times. This version is for 3-d input array of reals. This !! procedure is overloaded by the generic procedure `tile`. real ( kind = rk ), dimension (:,:,:), intent ( in ) :: array !! Input array integer ( kind = ik ), intent ( in ) :: n !! Number of times to copy input array real ( kind = rk ), dimension (:,:,:,:), allocatable :: tiled_array integer ( kind = ik ) :: i allocate ( tiled_array ( size ( array , dim = 1 ), size ( array , dim = 2 ), size ( array , dim = 3 ), n )) do concurrent ( i = 1 : n ) tiled_array (:,:,:, i ) = array (:,:,:) enddo endfunction tile_3d_real","tags":"","loc":"proc/tile_3d_real.html","title":"tile_3d_real – wavy"},{"text":"private pure function zeros_int(length, kindflag) result(zeros) Returns a 1-d array of integer zeros. This procedure is overloaded by the\n generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:),allocatable Called By proc~~zeros_int~~CalledByGraph proc~zeros_int zeros_int interface~zeros zeros interface~zeros->proc~zeros_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code zeros_int Source Code pure function zeros_int ( length , kindflag ) result ( zeros ) !! Returns a 1-d array of integer zeros. This procedure is overloaded by the !! generic procedure `zeros`. integer ( kind = ik ), intent ( in ) :: length !! Array length integer ( kind = ik ), intent ( in ) :: kindflag !! Array type integer ( kind = ik ), dimension (:), allocatable :: zeros allocate ( zeros ( length )) zeros = 0 endfunction zeros_int","tags":"","loc":"proc/zeros_int.html","title":"zeros_int – wavy"},{"text":"private pure function zeros_real(length, kindflag) result(zeros) Returns a 1-d array of floating-point zeros. This procedure is overloaded by\n the generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:),allocatable Called By proc~~zeros_real~~CalledByGraph proc~zeros_real zeros_real interface~zeros zeros interface~zeros->proc~zeros_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code zeros_real Source Code pure function zeros_real ( length , kindflag ) result ( zeros ) !! Returns a 1-d array of floating-point zeros. This procedure is overloaded by !! the generic procedure `zeros`. integer ( kind = ik ), intent ( in ) :: length !! Array length real ( kind = rk ), intent ( in ) :: kindflag !! Array type real ( kind = rk ), dimension (:), allocatable :: zeros allocate ( zeros ( length )) zeros = 0._rk endfunction zeros_real","tags":"","loc":"proc/zeros_real.html","title":"zeros_real – wavy"},{"text":"public interface diff Calls interface~~diff~~CallsGraph interface~diff diff proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~diff~~CalledByGraph interface~diff diff proc~constructor_1d constructor_1d proc~constructor_1d->interface~diff proc~readjson readJSON proc~readjson->interface~diff proc~constructor_2d constructor_2d proc~constructor_2d->interface~diff proc~constructor~2 constructor proc~constructor~2->interface~diff interface~grid_type grid_type interface~grid_type->proc~constructor_1d interface~grid_type->proc~constructor_2d interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures diff_1d diff_2d Module Procedures private pure function diff_1d (x) result(dx) Returns a centered-difference of a 1-d array, with first order\n differencing applied for the boundary points. This procedure is overloaded\n by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n first order differencing applied for the boundary points. This procedure is\n overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable","tags":"","loc":"interface/diff.html","title":"diff – wavy"},{"text":"public interface diff_periodic Calls interface~~diff_periodic~~CallsGraph interface~diff_periodic diff_periodic proc~diff_periodic_1d diff_periodic_1d interface~diff_periodic->proc~diff_periodic_1d proc~diff_periodic_2d diff_periodic_2d interface~diff_periodic->proc~diff_periodic_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~diff_periodic~~CalledByGraph interface~diff_periodic diff_periodic proc~constructor~2 constructor proc~constructor~2->interface~diff_periodic proc~readjson readJSON proc~readjson->interface~diff_periodic interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures diff_periodic_1d diff_periodic_2d Module Procedures private pure function diff_periodic_1d (x) result(dx) Returns a centered-difference of a 1-d array with periodic boundary\n conditions. This procedure is overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_periodic_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n periodic boundary conditions. This procedure is overloaded by the generic\n procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable","tags":"","loc":"interface/diff_periodic.html","title":"diff_periodic – wavy"},{"text":"public interface ones Calls interface~~ones~~CallsGraph interface~ones ones proc~ones_real ones_real interface~ones->proc~ones_real proc~ones_int ones_int interface~ones->proc~ones_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ones_int ones_real Module Procedures private pure function ones_int (length, kindflag) result(ones) Returns a 1-d array of integer ones. This procedure is overloaded by the\n generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function ones_real (length, kindflag) result(ones) Returns a 1-d array of floating-point ones. This procedure is overloaded by\n the generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable","tags":"","loc":"interface/ones.html","title":"ones – wavy"},{"text":"public interface range Calls interface~~range~~CallsGraph interface~range range proc~range_real range_real interface~range->proc~range_real proc~range_int range_int interface~range->proc~range_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures range_int range_real Module Procedures private pure function range_int (start, end, increment) result(range) Returns an array of integers given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: start Start value of the array integer(kind=ik), intent(in) :: end End value of the array integer(kind=ik), intent(in), optional :: increment Array increment Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function range_real (start, end, increment) result(range) Returns an array of reals given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: start Start value of the array real(kind=rk), intent(in) :: end End value of the array real(kind=rk), intent(in), optional :: increment Array increment Return Value real(kind=rk),\n  dimension(:), allocatable","tags":"","loc":"interface/range.html","title":"range – wavy"},{"text":"public interface tile Calls interface~~tile~~CallsGraph interface~tile tile proc~tile_2d_int tile_2d_int interface~tile->proc~tile_2d_int proc~tile_3d_real tile_3d_real interface~tile->proc~tile_3d_real proc~tile_2d_real tile_2d_real interface~tile->proc~tile_2d_real proc~tile_1d_int tile_1d_int interface~tile->proc~tile_1d_int proc~tile_3d_int tile_3d_int interface~tile->proc~tile_3d_int proc~tile_1d_real tile_1d_real interface~tile->proc~tile_1d_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures tile_1d_int tile_1d_real tile_2d_int tile_2d_real tile_3d_int tile_3d_real Module Procedures private pure function tile_1d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:), allocatable private pure function tile_1d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function tile_2d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:), allocatable private pure function tile_2d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:), allocatable private pure function tile_3d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:,:), allocatable private pure function tile_3d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable","tags":"","loc":"interface/tile.html","title":"tile – wavy"},{"text":"public interface zeros Calls interface~~zeros~~CallsGraph interface~zeros zeros proc~zeros_int zeros_int interface~zeros->proc~zeros_int proc~zeros_real zeros_real interface~zeros->proc~zeros_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures zeros_int zeros_real Module Procedures private pure function zeros_int (length, kindflag) result(zeros) Returns a 1-d array of integer zeros. This procedure is overloaded by the\n generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function zeros_real (length, kindflag) result(zeros) Returns a 1-d array of floating-point zeros. This procedure is overloaded by\n the generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable","tags":"","loc":"interface/zeros.html","title":"zeros – wavy"},{"text":"public pure elemental function sin_DCCM2012(spectrum, wspd, wdir, input_height, ustar, vonkarman) result(tendency) Uses: mod_spectrum mod_aerodynamic_drag mod_const proc~~sin_dccm2012~~UsesGraph proc~sin_dccm2012 sin_DCCM2012 module~mod_spectrum mod_spectrum module~mod_spectrum->proc~sin_dccm2012 mod_aerodynamic_drag mod_aerodynamic_drag mod_aerodynamic_drag->proc~sin_dccm2012 module~mod_const mod_const module~mod_const->proc~sin_dccm2012 module~mod_const->module~mod_spectrum json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_const module~mod_precision->module~mod_utility datetime_module datetime_module datetime_module->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. TODO implement currents averaged over the effective depth layer for\n modulation of phase speed. Returns a spectrum instance with the wave growth ($S_{in}$) tendency\n formulated by Donelan et al. (2012) and based on the sheltering hypothesis\n by Jeffreys (1924, 1925). The result instance has the units of 1/s. This source function must be\n re-evaluated if any of the input parameters change. References: Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling\n waves and wind stress, J. Geophys. Res. Oceans , 117 , C00J23,\n doi:10.1029/2011JC007787. Jeffreys, H., 1924: On the formation of waves by wind, Proc. R. Soc. A , 107 , 189–206. Jeffreys, H., 1925: On the formation of waves by wind, II, Proc. R. Soc.\n A , 110 , 341–347. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Input spectrum instance real(kind=rk), intent(in) :: wspd Input wind speed [m/s] real(kind=rk), intent(in) :: wdir Input wind direction [rad], mathematical convention real(kind=rk), intent(in) :: input_height Height of input wind speed [m/s] real(kind=rk), intent(in) :: ustar Air-side friction velocity [m/s] real(kind=rk), intent(in) :: vonkarman Von Karman constant Return Value type( spectrum_type ) Calls proc~~sin_dccm2012~~CallsGraph proc~sin_dccm2012 sin_DCCM2012 getfrequency getfrequency proc~sin_dccm2012->getfrequency getwaterdensity getwaterdensity proc~sin_dccm2012->getwaterdensity windatreferenceheight windatreferenceheight proc~sin_dccm2012->windatreferenceheight getphasespeed getphasespeed proc~sin_dccm2012->getphasespeed getwavenumber getwavenumber proc~sin_dccm2012->getwavenumber getgravity getgravity proc~sin_dccm2012->getgravity getwavelength getwavelength proc~sin_dccm2012->getwavelength getairdensity getairdensity proc~sin_dccm2012->getairdensity getdirections getdirections proc~sin_dccm2012->getdirections Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sin_DCCM2012 Source Code pure elemental function sin_DCCM2012 ( spectrum , wspd , wdir , input_height , ustar ,& vonkarman ) result ( tendency ) !! TODO implement currents averaged over the effective depth layer for !! modulation of phase speed. !! Returns a spectrum instance with the wave growth ($S_{in}$) tendency !! formulated by Donelan et al. (2012) and based on the sheltering hypothesis !! by Jeffreys (1924, 1925). !! !! The result instance has the units of 1/s. This source function must be !! re-evaluated if any of the input parameters change. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. !! !! Jeffreys, H., 1924: On the formation of waves by wind, *Proc. R. Soc. A*, !! **107**, 189–206. !! !! Jeffreys, H., 1925: On the formation of waves by wind, II, *Proc. R. Soc. !! A*, **110**, 341–347. use mod_spectrum , only : spectrum_type use mod_aerodynamic_drag , only : windAtReferenceHeight use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Input spectrum instance real ( kind = rk ), intent ( in ) :: wspd !! Input wind speed [m/s] real ( kind = rk ), intent ( in ) :: wdir !! Input wind direction [rad], mathematical convention real ( kind = rk ), intent ( in ) :: input_height !! Height of input wind speed [m/s] real ( kind = rk ), intent ( in ) :: ustar !! Air-side friction velocity [m/s] real ( kind = rk ), intent ( in ) :: vonkarman !! Von Karman constant type ( spectrum_type ) :: tendency real ( kind = rk ), dimension (:,:), allocatable :: s_in real ( kind = rk ), dimension (:), allocatable :: f real ( kind = rk ), dimension (:), allocatable :: th real ( kind = rk ), dimension (:), allocatable :: k real ( kind = rk ), dimension (:), allocatable :: cp real ( kind = rk ), dimension (:), allocatable :: omega real ( kind = rk ), dimension (:), allocatable :: half_wavelength real ( kind = rk ), dimension (:), allocatable :: wspd_input real ( kind = rk ) :: grav real ( kind = rk ) :: rho_air real ( kind = rk ) :: rho_water real ( kind = rk ), parameter :: a1_windsea = 0.11_rk real ( kind = rk ), parameter :: a1_swell = 0.01_rk real ( kind = rk ), parameter :: a1_opposed = 0.10_rk real ( kind = rk ), parameter :: field_scale_negative = a1_opposed / a1_windsea real ( kind = rk ), parameter :: field_scale_swell = a1_swell / a1_opposed real ( kind = rk ), dimension (:,:), allocatable :: sheltering_coefficient integer :: nfreq , nfreqs integer :: ndir , ndirs tendency = spectrum grav = spectrum % getGravity () rho_air = spectrum % getAirDensity () rho_water = spectrum % getWaterDensity () f = spectrum % getFrequency () th = spectrum % getDirections () k = spectrum % getWavenumber () cp = spectrum % getPhaseSpeed () half_wavelength = 0.5_rk * spectrum % getWavelength () omega = twopi * f nfreqs = size ( f ) ndirs = size ( th ) ! Evaluate wind speed at height of half-wavelength of each wave component wspd_input = windAtReferenceHeight ( wspd , input_height , half_wavelength , ustar ,& vonkarman ) allocate ( s_in ( nfreqs , ndirs )) allocate ( sheltering_coefficient ( nfreqs , ndirs )) ! Set the initial sheltering coefficient to a1_windsea everywhere sheltering_coefficient = a1_windsea do concurrent ( nfreq = 1 : nfreqs , ndir = 1 : ndirs ) ! If input is negative, adjust the sheltering coefficient to a1_opposed if ( wspd_input ( nfreq ) * cos ( wdir - th ( ndir )) - cp ( nfreq ) < 0 ) then sheltering_coefficient ( nfreq , ndir ) = sheltering_coefficient ( nfreq , ndir )& * field_scale_negative ! If input is negative but has positive misalignment, adjust the ! sheltering coefficient to a1_swell if ( cos ( wdir - th ( ndir )) > 0 ) then sheltering_coefficient ( nfreq , ndir ) = sheltering_coefficient ( nfreq , ndir )& * field_scale_swell endif endif enddo do concurrent ( ndir = 1 : ndirs ) s_in (:, ndir ) = sheltering_coefficient (:, ndir ) * rho_air / rho_water & * ( wspd_input * cos ( wdir - th ( ndir )) - cp ) * abs ( wspd_input * cos ( wdir - th ( ndir )) - cp )& * omega * k / grav enddo tendency = s_in deallocate ( s_in , sheltering_coefficient ) endfunction sin_DCCM2012","tags":"","loc":"proc/sin_dccm2012.html","title":"sin_DCCM2012 – wavy"},{"text":"public pure elemental function sds_DCCM2012(spectrum, sds_coefficient, sds_power, mss_coefficient) result(tendency) Uses: mod_spectrum mod_const proc~~sds_dccm2012~~UsesGraph proc~sds_dccm2012 sds_DCCM2012 module~mod_spectrum mod_spectrum module~mod_spectrum->proc~sds_dccm2012 module~mod_const mod_const module~mod_const->proc~sds_dccm2012 module~mod_const->module~mod_spectrum json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_const module~mod_precision->module~mod_utility datetime_module datetime_module datetime_module->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Returns a spectrum instance with the wave dissipation ($S_{ds}$) tendency\n formulated by Donelan et al. (2012). The result instance has the units of 1/s. This source function must be\n re-evaluated every time the spectrum is updated. References: Donelan, M. A., B. K. Haus, W. J. Plant, and O. Troianowski, 2010:\n Modulation of short wind waves by long waves, J. Geophys. Res. Oceans , 115 , C10003, doi:10.1029/2009JC005794. Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling\n waves and wind stress, J. Geophys. Res. Oceans , 117 , C00J23,\n doi:10.1029/2011JC007787. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Linear coefficient of the dissipation function real(kind=rk), intent(in) :: sds_coefficient Linear coefficient of the dissipation function real(kind=rk), intent(in) :: sds_power The exponent of the saturation spectrum real(kind=rk), intent(in) :: mss_coefficient Linear coefficient of the mean square slope adjustment to Sds Return Value type( spectrum_type ) Result tendency instance Calls proc~~sds_dccm2012~~CallsGraph proc~sds_dccm2012 sds_DCCM2012 getfrequency2d getfrequency2d proc~sds_dccm2012->getfrequency2d saturationspectrum saturationspectrum proc~sds_dccm2012->saturationspectrum meansquareslopedirectional meansquareslopedirectional proc~sds_dccm2012->meansquareslopedirectional Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sds_DCCM2012 Source Code pure elemental function sds_DCCM2012 ( spectrum , sds_coefficient , sds_power ,& mss_coefficient ) result ( tendency ) !! Returns a spectrum instance with the wave dissipation ($S_{ds}$) tendency !! formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. This source function must be !! re-evaluated every time the spectrum is updated. !! !! References: !! !! Donelan, M. A., B. K. Haus, W. J. Plant, and O. Troianowski, 2010: !! Modulation of short wind waves by long waves, *J. Geophys. Res. Oceans*, !! **115**, C10003, doi:10.1029/2009JC005794. !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Linear coefficient of the dissipation function real ( kind = rk ), intent ( in ) :: sds_coefficient !! Linear coefficient of the dissipation function real ( kind = rk ), intent ( in ) :: sds_power !! The exponent of the saturation spectrum real ( kind = rk ), intent ( in ) :: mss_coefficient !! Linear coefficient of the mean square slope adjustment to Sds type ( spectrum_type ) :: tendency !! Result tendency instance tendency = sds_coefficient * twopi * spectrum % getFrequency2d ()& * spectrum % saturationSpectrum () ** sds_power & * ( 1 + mss_coefficient * spectrum % meanSquareSlopeDirectional ()) ** 2 endfunction sds_DCCM2012","tags":"","loc":"proc/sds_dccm2012.html","title":"sds_DCCM2012 – wavy"},{"text":"public pure elemental function sdt_DCCM2012(spectrum, sdt_coefficient, ustar) result(tendency) Uses: mod_spectrum proc~~sdt_dccm2012~~UsesGraph proc~sdt_dccm2012 sdt_DCCM2012 module~mod_spectrum mod_spectrum module~mod_spectrum->proc~sdt_dccm2012 json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_utility module~mod_const mod_const module~mod_precision->module~mod_const datetime_module datetime_module datetime_module->module~mod_spectrum module~mod_const->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Returns a spectrum instance with the wave dissipation due to turbulence\n ($S_{dt}$) tendency formulated by Donelan et al. (2012). The result instance has the units of 1/s. This source function can be\n evaluated once and stored if wavenumber array, air and water densities, and\n friction velocity are held constant. References: Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling\n waves and wind stress, J. Geophys. Res. Oceans , 117 , C00J23,\n doi:10.1029/2011JC007787. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: sdt_coefficient Linear coefficient of the turbulent dissipation function real(kind=rk), intent(in) :: ustar Air-side friction velocity [m/s] Return Value type( spectrum_type ) Result tendency instance Calls proc~~sdt_dccm2012~~CallsGraph proc~sdt_dccm2012 sdt_DCCM2012 getairdensity getairdensity proc~sdt_dccm2012->getairdensity getwavenumber2d getwavenumber2d proc~sdt_dccm2012->getwavenumber2d getwaterdensity getwaterdensity proc~sdt_dccm2012->getwaterdensity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sdt_DCCM2012 Source Code pure elemental function sdt_DCCM2012 ( spectrum , sdt_coefficient , ustar )& result ( tendency ) !! Returns a spectrum instance with the wave dissipation due to turbulence !! ($S_{dt}$) tendency formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. This source function can be !! evaluated once and stored if wavenumber array, air and water densities, and !! friction velocity are held constant. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: sdt_coefficient !! Linear coefficient of the turbulent dissipation function real ( kind = rk ), intent ( in ) :: ustar !! Air-side friction velocity [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance tendency = sdt_coefficient * sqrt ( spectrum % getAirDensity ()& / spectrum % getWaterDensity ()) * ustar * spectrum % getWavenumber2d () endfunction sdt_DCCM2012","tags":"","loc":"proc/sdt_dccm2012.html","title":"sdt_DCCM2012 – wavy"},{"text":"public pure elemental function sbf_DCCM2012(spectrum, friction_coefficient, percolation_coefficient) result(tendency) Uses: mod_spectrum proc~~sbf_dccm2012~~UsesGraph proc~sbf_dccm2012 sbf_DCCM2012 module~mod_spectrum mod_spectrum module~mod_spectrum->proc~sbf_dccm2012 json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_utility module~mod_const mod_const module~mod_precision->module~mod_const datetime_module datetime_module datetime_module->module~mod_spectrum module~mod_const->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Returns a spectrum instance with the wave dissipation tendency due to\n bottom friction and percolation, formulated by Donelan et al. (2012). The result instance has the units of 1/s. If the mean water depth and\n wavenumber arrays are constant, this source function can be evaluated once\n and stored. Otherwise, the function must be re-evaluated if the mean water\n depth or wavenumber array change. References: Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling\n waves and wind stress, J. Geophys. Res. Oceans , 117 , C00J23,\n doi:10.1029/2011JC007787. Shemdin, P., K. Hasselmann, S. V. Hsiao, and K. Herterich, 1978: Non-linear\n and linear bottom interaction effects in shallow water, p347-372 in:\n Turbulent fluxes through the sea surface, wave dynamics and prediction, A.\n Favre and K. Hasselmann (eds), Plenum, New York, 677p. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: friction_coefficient Bottom friction coefficient [m/s] real(kind=rk), intent(in) :: percolation_coefficient Bottom permeability coefficient [m/s] Return Value type( spectrum_type ) Result tendency instance Calls proc~~sbf_dccm2012~~CallsGraph proc~sbf_dccm2012 sbf_DCCM2012 getdepth getdepth proc~sbf_dccm2012->getdepth getwavenumber2d getwavenumber2d proc~sbf_dccm2012->getwavenumber2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sbf_DCCM2012 Source Code pure elemental function sbf_DCCM2012 ( spectrum , friction_coefficient ,& percolation_coefficient ) result ( tendency ) !! Returns a spectrum instance with the wave dissipation tendency due to !! bottom friction and percolation, formulated by Donelan et al. (2012). !! !! The result instance has the units of 1/s. If the mean water depth and !! wavenumber arrays are constant, this source function can be evaluated once !! and stored. Otherwise, the function must be re-evaluated if the mean water !! depth or wavenumber array change. !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. !! !! Shemdin, P., K. Hasselmann, S. V. Hsiao, and K. Herterich, 1978: Non-linear !! and linear bottom interaction effects in shallow water, p347-372 in: !! Turbulent fluxes through the sea surface, wave dynamics and prediction, A. !! Favre and K. Hasselmann (eds), Plenum, New York, 677p. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: friction_coefficient !! Bottom friction coefficient [m/s] real ( kind = rk ), intent ( in ) :: percolation_coefficient !! Bottom permeability coefficient [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance real ( kind = rk ) :: d real ( kind = rk ), dimension (:,:), allocatable :: k d = spectrum % getDepth () k = spectrum % getWavenumber2d () tendency = friction_coefficient * k / sinh ( 2 * k * d )& + percolation_coefficient / cosh ( k * d ) ** 2 endfunction sbf_DCCM2012","tags":"","loc":"proc/sbf_dccm2012.html","title":"sbf_DCCM2012 – wavy"},{"text":"public pure elemental function sbf_JONSWAP(spectrum, friction_coefficient) result(tendency) Uses: mod_spectrum proc~~sbf_jonswap~~UsesGraph proc~sbf_jonswap sbf_JONSWAP module~mod_spectrum mod_spectrum module~mod_spectrum->proc~sbf_jonswap json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_utility module~mod_const mod_const module~mod_precision->module~mod_const datetime_module datetime_module datetime_module->module~mod_spectrum module~mod_const->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Returns a spectrum instance with the bottom friction ($S_{bot}$) tendency\n based on JONSWAP field data (Hasselmann et al., 1973). It is also the\n default parameterization scheme used in the WAM model (WAMDIG, 1988). References: Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell\n decay during the Joint North Sea Wave Project (JONSWAP). Dtsch. Hydrogh.\n Z. , Suppl. A, 8 , 12, 95pp. WAMDI Group, 1988. The WAM model – a third generation ocean wave prediction\n  model. J. Phys. Oceanogr. , 18 , 1775–1810. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: friction_coefficient Bottom friction coefficient [m/s] Return Value type( spectrum_type ) Result tendency instance Calls proc~~sbf_jonswap~~CallsGraph proc~sbf_jonswap sbf_JONSWAP getphasespeed2d getphasespeed2d proc~sbf_jonswap->getphasespeed2d getdepth getdepth proc~sbf_jonswap->getdepth getgravity getgravity proc~sbf_jonswap->getgravity getgroupspeed2d getgroupspeed2d proc~sbf_jonswap->getgroupspeed2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sbf_JONSWAP Source Code pure elemental function sbf_JONSWAP ( spectrum , friction_coefficient )& result ( tendency ) !! Returns a spectrum instance with the bottom friction ($S_{bot}$) tendency !! based on JONSWAP field data (Hasselmann et al., 1973). It is also the !! default parameterization scheme used in the WAM model (WAMDIG, 1988). !! !! References: !! !! Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell !! decay during the Joint North Sea Wave Project (JONSWAP). *Dtsch. Hydrogh. !! Z.*, Suppl. A, **8**, 12, 95pp. !! !! WAMDI Group, 1988. The WAM model – a third generation ocean wave prediction !!  model. *J. Phys. Oceanogr.*, **18**, 1775–1810. use mod_spectrum , only : spectrum_type type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance real ( kind = rk ), intent ( in ) :: friction_coefficient !! Bottom friction coefficient [m/s] type ( spectrum_type ) :: tendency !! Result tendency instance tendency = 2 * friction_coefficient & * ( spectrum % getPhaseSpeed2d () / spectrum % getGroupSpeed2d () - 0.5_rk )& / ( spectrum % getGravity () * spectrum % getDepth ()) endfunction sbf_JONSWAP","tags":"","loc":"proc/sbf_jonswap.html","title":"sbf_JONSWAP – wavy"},{"text":"public pure elemental function snl_DCCM2012(spectrum, sds_tendency, snl_coefficient) result(tendency) Uses: mod_spectrum mod_const proc~~snl_dccm2012~~UsesGraph proc~snl_dccm2012 snl_DCCM2012 module~mod_spectrum mod_spectrum module~mod_spectrum->proc~snl_dccm2012 module~mod_const mod_const module~mod_const->proc~snl_dccm2012 module~mod_const->module~mod_spectrum json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_const module~mod_precision->module~mod_utility datetime_module datetime_module datetime_module->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Returns a spectrum instance with the non-linear wave-wave energy transfer\n ($S_{nl}$) tendency formulated by Donelan et al. (2012). References: Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling\n waves and wind stress, J. Geophys. Res. Oceans , 117 , C00J23,\n doi:10.1029/2011JC007787. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance type( spectrum_type ), intent(in) :: sds_tendency Spectral dissipation tendency instance real(kind=rk), intent(in) :: snl_coefficient Linear coefficient of the dissipation function Return Value type( spectrum_type ) Result tendency instance Calls proc~~snl_dccm2012~~CallsGraph proc~snl_dccm2012 snl_DCCM2012 getfrequency getfrequency proc~snl_dccm2012->getfrequency getspectrum getspectrum proc~snl_dccm2012->getspectrum getwavenumber getwavenumber proc~snl_dccm2012->getwavenumber getwavenumberspacing getwavenumberspacing proc~snl_dccm2012->getwavenumberspacing getdirections getdirections proc~snl_dccm2012->getdirections float float proc~snl_dccm2012->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code snl_DCCM2012 Source Code pure elemental function snl_DCCM2012 ( spectrum , sds_tendency , snl_coefficient )& result ( tendency ) !! Returns a spectrum instance with the non-linear wave-wave energy transfer !! ($S_{nl}$) tendency formulated by Donelan et al. (2012). !! !! References: !! !! Donelan, M. A., M. Curcic, S. S. Chen, and A. K. Magnusson, 2012: Modeling !! waves and wind stress, *J. Geophys. Res. Oceans*, **117**, C00J23, !! doi:10.1029/2011JC007787. use mod_spectrum , only : spectrum_type use mod_const , only : twopi type ( spectrum_type ), intent ( in ) :: spectrum !! Spectrum instance type ( spectrum_type ), intent ( in ) :: sds_tendency !! Spectral dissipation tendency instance real ( kind = rk ), intent ( in ) :: snl_coefficient !! Linear coefficient of the dissipation function type ( spectrum_type ) :: tendency !! Result tendency instance real ( kind = rk ), dimension (:,:), allocatable :: sds_spectrum real ( kind = rk ), dimension (:,:), allocatable :: s_nl real ( kind = rk ), dimension (:), allocatable :: f real ( kind = rk ), dimension (:), allocatable :: th real ( kind = rk ), dimension (:), allocatable :: k real ( kind = rk ), dimension (:), allocatable :: dk real ( kind = rk ), dimension (:), allocatable :: w1 , w2 real ( kind = rk ) :: bf1 , bf1a , bf2 , dlnf integer :: nfreq , nfreqs integer :: ndir , ndirs f = spectrum % getFrequency () k = spectrum % getWavenumber () dk = spectrum % getWavenumberSpacing () th = spectrum % getDirections () nfreqs = size ( f ) ndirs = size ( th ) tendency = spectrum sds_spectrum = sds_tendency % getSpectrum () * spectrum % getSpectrum () allocate ( s_nl ( nfreqs , ndirs )) s_nl = 0 allocate ( w1 ( nfreqs ), w2 ( nfreqs )) w1 = 0 w2 = 0 dlnf = ( log ( f ( size ( f ))) - log ( f ( 1 ))) / float ( nfreqs - 1 ) bf1 = exp ( - 16 * dlnf ** 2 ) bf2 = exp ( - 64 * dlnf ** 2 ) bf1a = bf1 / ( bf1 + bf2 ) bf2 = bf2 / ( bf1 + bf2 ) bf1 = bf1a do nfreq = 1 , nfreqs - 2 w1 ( nfreq ) = snl_coefficient * bf1 * k ( nfreq + 1 ) * dk ( nfreq + 1 ) / ( k ( nfreq ) * dk ( nfreq )) w2 ( nfreq ) = snl_coefficient * bf2 * k ( nfreq + 2 ) * dk ( nfreq + 2 ) / ( k ( nfreq ) * dk ( nfreq )) enddo do concurrent ( ndir = 1 : ndirs ) do nfreq = 1 , nfreqs - 2 s_nl ( nfreq , ndir ) = w1 ( nfreq ) * sds_spectrum ( nfreq + 1 , ndir )& + w2 ( nfreq ) * sds_spectrum ( nfreq + 2 , ndir )& - snl_coefficient * sds_spectrum ( nfreq , ndir ) enddo enddo tendency = s_nl deallocate ( w1 , w2 , s_nl , sds_spectrum ) endfunction snl_DCCM2012","tags":"","loc":"proc/snl_dccm2012.html","title":"snl_DCCM2012 – wavy"},{"text":"public pure elemental function gravityClairaut(latitude) result(grav) Returns the gravitational acceleration at the Earth's surface as function\n of latitude, based on Clairaut's formula. TODO Reference Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: latitude Latitude [rad] Return Value real(kind=rk) Source Code gravityClairaut Source Code function gravityClairaut ( latitude ) result ( grav ) !! Returns the gravitational acceleration at the Earth's surface as function !! of latitude, based on Clairaut's formula. !! !! TODO Reference real ( kind = rk ), intent ( in ) :: latitude !! Latitude [rad] grav = 9.780327_rk * ( 1.0026454_rk & - 0.0026512_rk * cos ( 2 * latitude )& + 0.0000058_rk * cos ( 2 * latitude ) ** 2 ) endfunction gravityClairaut","tags":"","loc":"proc/gravityclairaut.html","title":"gravityClairaut – wavy"},{"text":"private pure function integrate_spectrum(func, initial, tendency, dt) Integrates spectrum forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial type( spectrum_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( spectrum_type ) type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) Called By proc~~integrate_spectrum~~CalledByGraph proc~integrate_spectrum integrate_spectrum interface~integrate integrate interface~integrate->proc~integrate_spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_spectrum Source Code pure type ( spectrum_type ) function integrate_spectrum ( func , initial , tendency , dt ) !! Integrates spectrum forward in time using a time integration method !! provided as the argument `func`. interface pure type ( spectrum_type ) function func ( initial , tendency , dt ) import :: spectrum_type , rk type ( spectrum_type ), intent ( in ) :: initial type ( spectrum_type ), intent ( in ) :: tendency real ( kind = rk ), intent ( in ) :: dt endfunction func endinterface type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] integrate_spectrum = func ( initial , tendency , dt ) endfunction integrate_spectrum","tags":"","loc":"proc/integrate_spectrum.html","title":"integrate_spectrum – wavy"},{"text":"private pure function integrate_domain(func, initial, tendency, dt) Integrates domain forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial type( domain_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( domain_type ) type( domain_type ), intent(in) :: initial Initial domain instance type( domain_type ), intent(in) :: tendency Spectrum domain instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) Called By proc~~integrate_domain~~CalledByGraph proc~integrate_domain integrate_domain interface~integrate integrate interface~integrate->proc~integrate_domain Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_domain Source Code pure type ( domain_type ) function integrate_domain ( func , initial , tendency , dt ) !! Integrates domain forward in time using a time integration method !! provided as the argument `func`. interface pure type ( domain_type ) function func ( initial , tendency , dt ) import :: domain_type , rk type ( domain_type ), intent ( in ) :: initial type ( domain_type ), intent ( in ) :: tendency real ( kind = rk ), intent ( in ) :: dt endfunction func endinterface type ( domain_type ), intent ( in ) :: initial !! Initial domain instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum domain instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] integrate_domain = func ( initial , tendency , dt ) endfunction integrate_domain","tags":"","loc":"proc/integrate_domain.html","title":"integrate_domain – wavy"},{"text":"private pure elemental function backward_euler_spectrum(initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order implicit backward \n Euler integration scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) Called By proc~~backward_euler_spectrum~~CalledByGraph proc~backward_euler_spectrum backward_euler_spectrum interface~backward_euler backward_euler interface~backward_euler->proc~backward_euler_spectrum proc~backward_euler_domain backward_euler_domain interface~backward_euler->proc~backward_euler_domain proc~backward_euler_domain->interface~backward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code backward_euler_spectrum Source Code pure elemental type ( spectrum_type ) function backward_euler_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum forward in time using a 1st order implicit backward !! Euler integration scheme. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial / ( - tendency * dt + 1._rk ) endfunction backward_euler_spectrum","tags":"","loc":"proc/backward_euler_spectrum.html","title":"backward_euler_spectrum – wavy"},{"text":"private pure elemental function backward_euler_domain(initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order implicit \n backward Euler integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) Calls proc~~backward_euler_domain~~CallsGraph proc~backward_euler_domain backward_euler_domain setspectrum setspectrum proc~backward_euler_domain->setspectrum getspectrum getspectrum proc~backward_euler_domain->getspectrum interface~backward_euler backward_euler proc~backward_euler_domain->interface~backward_euler interface~backward_euler->proc~backward_euler_domain proc~backward_euler_spectrum backward_euler_spectrum interface~backward_euler->proc~backward_euler_spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~backward_euler_domain~~CalledByGraph proc~backward_euler_domain backward_euler_domain interface~backward_euler backward_euler proc~backward_euler_domain->interface~backward_euler interface~backward_euler->proc~backward_euler_domain Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code backward_euler_domain Source Code pure elemental type ( domain_type ) function backward_euler_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using a 1st order implicit !! backward Euler integration scheme. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial call domain % setSpectrum ( backward_euler ( initial % getSpectrum (),& tendency % getSpectrum (), dt )) endfunction backward_euler_domain","tags":"","loc":"proc/backward_euler_domain.html","title":"backward_euler_domain – wavy"},{"text":"private pure elemental function exact_exponential_spectrum(initial, tendency, dt) result(spec) Integrates a spectrum instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) Calls proc~~exact_exponential_spectrum~~CallsGraph proc~exact_exponential_spectrum exact_exponential_spectrum setspectrum setspectrum proc~exact_exponential_spectrum->setspectrum getspectrum getspectrum proc~exact_exponential_spectrum->getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~exact_exponential_spectrum~~CalledByGraph proc~exact_exponential_spectrum exact_exponential_spectrum interface~exact_exponential exact_exponential interface~exact_exponential->proc~exact_exponential_spectrum proc~exact_exponential_domain exact_exponential_domain interface~exact_exponential->proc~exact_exponential_domain proc~exact_exponential_domain->interface~exact_exponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code exact_exponential_spectrum Source Code pure elemental type ( spectrum_type ) function exact_exponential_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum instance forward in time using the exact exponential. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial call spec % setSpectrum ( exp ( tendency % getSpectrum () * dt )) !spec = (initial * exp(tendency % getSpectrum() * dt)) spec = initial * spec endfunction exact_exponential_spectrum","tags":"","loc":"proc/exact_exponential_spectrum.html","title":"exact_exponential_spectrum – wavy"},{"text":"private pure elemental function exact_exponential_domain(initial, tendency, dt) result(domain) Integrates a domain instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) Calls proc~~exact_exponential_domain~~CallsGraph proc~exact_exponential_domain exact_exponential_domain interface~exact_exponential exact_exponential proc~exact_exponential_domain->interface~exact_exponential getspectrum getspectrum proc~exact_exponential_domain->getspectrum interface~exact_exponential->proc~exact_exponential_domain proc~exact_exponential_spectrum exact_exponential_spectrum interface~exact_exponential->proc~exact_exponential_spectrum proc~exact_exponential_spectrum->getspectrum setspectrum setspectrum proc~exact_exponential_spectrum->setspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~exact_exponential_domain~~CalledByGraph proc~exact_exponential_domain exact_exponential_domain interface~exact_exponential exact_exponential proc~exact_exponential_domain->interface~exact_exponential interface~exact_exponential->proc~exact_exponential_domain Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code exact_exponential_domain Source Code pure elemental type ( domain_type ) function exact_exponential_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using the exact exponential. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial domain = exact_exponential ( initial % getSpectrum (),& tendency % getSpectrum (), dt ) endfunction exact_exponential_domain","tags":"","loc":"proc/exact_exponential_domain.html","title":"exact_exponential_domain – wavy"},{"text":"private pure elemental function forward_euler_spectrum(initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order Euler integration\n scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) Called By proc~~forward_euler_spectrum~~CalledByGraph proc~forward_euler_spectrum forward_euler_spectrum interface~forward_euler forward_euler interface~forward_euler->proc~forward_euler_spectrum proc~forward_euler_domain forward_euler_domain interface~forward_euler->proc~forward_euler_domain proc~forward_euler_domain->interface~forward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code forward_euler_spectrum Source Code pure elemental type ( spectrum_type ) function forward_euler_spectrum ( initial ,& tendency , dt ) result ( spec ) !! Integrates a spectrum forward in time using a 1st order Euler integration !! scheme. type ( spectrum_type ), intent ( in ) :: initial !! Initial spectrum instance type ( spectrum_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] spec = initial + tendency * dt endfunction forward_euler_spectrum","tags":"","loc":"proc/forward_euler_spectrum.html","title":"forward_euler_spectrum – wavy"},{"text":"private pure elemental function forward_euler_domain(initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order Euler\n integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) Calls proc~~forward_euler_domain~~CallsGraph proc~forward_euler_domain forward_euler_domain interface~forward_euler forward_euler proc~forward_euler_domain->interface~forward_euler getspectrum getspectrum proc~forward_euler_domain->getspectrum interface~forward_euler->proc~forward_euler_domain proc~forward_euler_spectrum forward_euler_spectrum interface~forward_euler->proc~forward_euler_spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~forward_euler_domain~~CalledByGraph proc~forward_euler_domain forward_euler_domain interface~forward_euler forward_euler proc~forward_euler_domain->interface~forward_euler interface~forward_euler->proc~forward_euler_domain Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code forward_euler_domain Source Code pure elemental type ( domain_type ) function forward_euler_domain ( initial ,& tendency , dt ) result ( domain ) !! Integrates a domain instance forward in time using a 1st order Euler !! integration scheme. type ( domain_type ), intent ( in ) :: initial !! Initial spectrum instance type ( domain_type ), intent ( in ) :: tendency !! Spectrum tendency instance real ( kind = rk ), intent ( in ) :: dt !! Time step [s] domain = initial domain = forward_euler ( initial % getSpectrum (), tendency % getSpectrum (), dt ) endfunction forward_euler_domain","tags":"","loc":"proc/forward_euler_domain.html","title":"forward_euler_domain – wavy"},{"text":"public interface integrate Calls interface~~integrate~~CallsGraph interface~integrate integrate proc~integrate_spectrum integrate_spectrum interface~integrate->proc~integrate_spectrum proc~integrate_domain integrate_domain interface~integrate->proc~integrate_domain Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures integrate_spectrum integrate_domain Module Procedures private pure function integrate_spectrum (func, initial, tendency, dt) Integrates spectrum forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial type( spectrum_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( spectrum_type ) type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure function integrate_domain (func, initial, tendency, dt) Integrates domain forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial type( domain_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( domain_type ) type( domain_type ), intent(in) :: initial Initial domain instance type( domain_type ), intent(in) :: tendency Spectrum domain instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type )","tags":"","loc":"interface/integrate.html","title":"integrate – wavy"},{"text":"public interface exact_exponential Calls interface~~exact_exponential~~CallsGraph interface~exact_exponential exact_exponential proc~exact_exponential_spectrum exact_exponential_spectrum interface~exact_exponential->proc~exact_exponential_spectrum proc~exact_exponential_domain exact_exponential_domain interface~exact_exponential->proc~exact_exponential_domain setspectrum setspectrum proc~exact_exponential_spectrum->setspectrum getspectrum getspectrum proc~exact_exponential_spectrum->getspectrum proc~exact_exponential_domain->interface~exact_exponential proc~exact_exponential_domain->getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~exact_exponential~~CalledByGraph interface~exact_exponential exact_exponential proc~exact_exponential_domain exact_exponential_domain interface~exact_exponential->proc~exact_exponential_domain proc~exact_exponential_domain->interface~exact_exponential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures exact_exponential_spectrum exact_exponential_domain Module Procedures private pure elemental function exact_exponential_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function exact_exponential_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type )","tags":"","loc":"interface/exact_exponential.html","title":"exact_exponential – wavy"},{"text":"public interface backward_euler Calls interface~~backward_euler~~CallsGraph interface~backward_euler backward_euler proc~backward_euler_spectrum backward_euler_spectrum interface~backward_euler->proc~backward_euler_spectrum proc~backward_euler_domain backward_euler_domain interface~backward_euler->proc~backward_euler_domain proc~backward_euler_domain->interface~backward_euler setspectrum setspectrum proc~backward_euler_domain->setspectrum getspectrum getspectrum proc~backward_euler_domain->getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~backward_euler~~CalledByGraph interface~backward_euler backward_euler proc~backward_euler_domain backward_euler_domain interface~backward_euler->proc~backward_euler_domain proc~backward_euler_domain->interface~backward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures backward_euler_spectrum backward_euler_domain Module Procedures private pure elemental function backward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order implicit backward \n Euler integration scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function backward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order implicit \n backward Euler integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type )","tags":"","loc":"interface/backward_euler.html","title":"backward_euler – wavy"},{"text":"public interface forward_euler Calls interface~~forward_euler~~CallsGraph interface~forward_euler forward_euler proc~forward_euler_spectrum forward_euler_spectrum interface~forward_euler->proc~forward_euler_spectrum proc~forward_euler_domain forward_euler_domain interface~forward_euler->proc~forward_euler_domain proc~forward_euler_domain->interface~forward_euler getspectrum getspectrum proc~forward_euler_domain->getspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~forward_euler~~CalledByGraph interface~forward_euler forward_euler proc~forward_euler_domain forward_euler_domain interface~forward_euler->proc~forward_euler_domain proc~forward_euler_domain->interface~forward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures forward_euler_spectrum forward_euler_domain Module Procedures private pure elemental function forward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order Euler integration\n scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function forward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order Euler\n integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type )","tags":"","loc":"interface/forward_euler.html","title":"forward_euler – wavy"},{"text":"public pure elemental function waveAge(cp, u) Returns wave age, the ratio of phase speed and friction velocity or wind\n speed, depending on the caller's definition of wave age. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: cp Phase speed [m/s] real(kind=realkind), intent(in) :: u Friction velocity or wind speed [m/s] Return Value real(kind=realkind)","tags":"","loc":"proc/waveage.html","title":"waveAge – wavy"},{"text":"public pure elemental function nondimensionalDepth(wspd, depth, grav) Returns nondimensional depth based on input wind speed [m/s], mean water\n depth [m], and gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: depth Mean water depth [m] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionaldepth.html","title":"nondimensionalDepth – wavy"},{"text":"public pure elemental function nondimensionalEnergy(wspd, sigma, grav) Returns nondimensional energy based on input wind speed, RMS of wave\n variance, and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: sigma Root mean square of wave variance real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionalenergy.html","title":"nondimensionalEnergy – wavy"},{"text":"public pure elemental function nondimensionalFetch(wspd, fetch, grav) Returns nondimensional energy based on input wind speed, RMS of wave\n variance, and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: fetch Fetch [m] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionalfetch.html","title":"nondimensionalFetch – wavy"},{"text":"public pure elemental function nondimensionalFrequency(wspd, fpeak, grav) Returns nondimensional frequency based on input wind speed, peak frequency,\n and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: fpeak Peak frequency [Hz] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionalfrequency.html","title":"nondimensionalFrequency – wavy"},{"text":"public pure elemental function nondimensionalRoughness_S1974(z0, ustar, grav) Returns the aerodynamic roughness length scaled by friction velocity\n squared and gravitational acceleration, after Stewart (1974). References: TODO reference Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: z0 Roughness length [m] real(kind=realkind), intent(in) :: ustar Friction velocity [m/s] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionalroughness_s1974.html","title":"nondimensionalRoughness_S1974 – wavy"},{"text":"public pure elemental function nondimensionalRoughness_H1986(z0, hs) Returns the aerodynamic roughness length scaled by significant wave height,\n after Huang (1986). TODO reference Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: z0 Roughness length [m] real(kind=realkind), intent(in) :: hs Significant wave height [m] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionalroughness_h1986.html","title":"nondimensionalRoughness_H1986 – wavy"},{"text":"public pure elemental function nondimensionalTime(wspd, time, grav) Returns nondimensional time (duration) based on input wind speed, duration,\n and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: time Time [s] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"proc/nondimensionaltime.html","title":"nondimensionalTime – wavy"},{"text":"private pure elemental function constructor(fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) result(spectrum) Constructor function for the spectrum object. monochromatic Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: fmin Minimum frequency bin [Hz] real(kind=rk), intent(in) :: fmax Maximum frequency bin [Hz] real(kind=rk), intent(in) :: df Frequency increment, df = f(n+1)/f(n) integer, intent(in) :: ndirs Number of directional bins real(kind=rk), intent(in) :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: air_density Air density [kg/m&#94;3] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value type( spectrum_type ) Calls proc~~constructor~2~~CallsGraph proc~constructor~2 constructor f f proc~constructor~2->f proc~wavenumber wavenumber proc~constructor~2->proc~wavenumber cg cg proc~constructor~2->cg interface~diff_periodic diff_periodic proc~constructor~2->interface~diff_periodic th th proc~constructor~2->th cp cp proc~constructor~2->cp proc~setcurrent2d setCurrent2d proc~constructor~2->proc~setcurrent2d dk dk proc~constructor~2->dk k k proc~constructor~2->k dth dth proc~constructor~2->dth spec spec proc~constructor~2->spec interface~diff diff proc~constructor~2->interface~diff proc~diff_periodic_1d diff_periodic_1d interface~diff_periodic->proc~diff_periodic_1d proc~diff_periodic_2d diff_periodic_2d interface~diff_periodic->proc~diff_periodic_2d proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~constructor~2~~CalledByGraph proc~constructor~2 constructor interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code constructor Source Code pure elemental type ( spectrum_type ) function constructor ( fmin , fmax , df , ndirs ,& depth , grav , air_density , water_density , surface_tension ) result ( spectrum ) !! Constructor function for the spectrum object. real ( kind = rk ), intent ( in ) :: fmin !! Minimum frequency bin [Hz] real ( kind = rk ), intent ( in ) :: fmax !! Maximum frequency bin [Hz] real ( kind = rk ), intent ( in ) :: df !! Frequency increment, df = f(n+1)/f(n) integer , intent ( in ) :: ndirs !! Number of directional bins real ( kind = rk ), intent ( in ) :: depth !! Mean water depth [m] real ( kind = rk ), intent ( in ), optional :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), intent ( in ), optional :: air_density !! Air density [kg/m&#94;3] real ( kind = rk ), intent ( in ), optional :: water_density !! Water density [kg/m&#94;3] real ( kind = rk ), intent ( in ), optional :: surface_tension !! Surface tension [N/m] integer :: n integer :: nfreqs if ( present ( grav )) then spectrum % grav = grav else spectrum % grav = 9.8_rk endif if ( present ( air_density )) then spectrum % air_density = air_density else spectrum % air_density = 1.2_rk endif if ( present ( water_density )) then spectrum % water_density = water_density else spectrum % water_density = 1 e3_rk endif if ( present ( surface_tension )) then spectrum % surface_tension = surface_tension else spectrum % surface_tension = 0.07_rk endif spectrum % depth = depth if ( fmin == fmax ) then !! monochromatic nfreqs = 1 else nfreqs = int (( log ( fmax ) - log ( fmin )) / log ( df )) endif allocate ( spectrum % spec ( nfreqs , ndirs )) spectrum % spec = 0 allocate ( spectrum % f ( nfreqs )) allocate ( spectrum % df ( nfreqs )) allocate ( spectrum % k ( nfreqs )) allocate ( spectrum % dk ( nfreqs )) allocate ( spectrum % cp ( nfreqs )) allocate ( spectrum % cg ( nfreqs )) allocate ( spectrum % th ( ndirs )) if ( nfreqs == 1 ) then spectrum % f ( n ) = fmin else do concurrent ( n = 1 : nfreqs ) spectrum % f ( n ) = exp ( log ( fmin ) + ( n - 1 ) * log ( df )) enddo endif do concurrent ( n = 1 : nfreqs ) spectrum % k ( n ) = wavenumber ( spectrum % f ( n ), & spectrum % depth , & spectrum % water_density ,& spectrum % grav , & spectrum % surface_tension ) enddo spectrum % cp = twopi * spectrum % f / spectrum % k spectrum % cg = twopi * diff ( spectrum % f ) / diff ( spectrum % k ) do concurrent ( n = 1 : ndirs ) spectrum % th ( n ) = ( n - 0.5 * ( ndirs + 1 )) * twopi / ndirs enddo spectrum % df = diff ( spectrum % f ) spectrum % dk = diff ( spectrum % k ) if ( ndirs > 1 ) then spectrum % dth = diff_periodic ( spectrum % th ) spectrum % dth ( 1 ) = spectrum % dth ( 2 ) spectrum % dth ( ndirs ) = spectrum % dth ( ndirs - 1 ) else spectrum % dth = [ 1 ] endif call spectrum % setCurrent2d ([ 0._rk ],[ 0._rk ],[ 0._rk ]) endfunction constructor","tags":"","loc":"proc/constructor~2.html","title":"constructor – wavy"},{"text":"private pure elemental function getAirDensity(self) result(air_density) Returns the air_density [kg/m&#94;3] of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Air density [kg/m&#94;3] Called By proc~~getairdensity~2~~CalledByGraph proc~getairdensity~2 getAirDensity proc~writejson~2 writeJSON proc~writejson~2->proc~getairdensity~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getAirDensity Source Code pure elemental function getAirDensity ( self ) result ( air_density ) !! Returns the air_density [kg/m&#94;3] of the `spectrum` instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: air_density !! Air density [kg/m&#94;3] air_density = self % air_density endfunction getAirDensity","tags":"","loc":"proc/getairdensity~2.html","title":"getAirDensity – wavy"},{"text":"private pure elemental function isAllocated(self) Returns the allocation status of the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self domain instance Return Value logical Source Code isAllocated Source Code pure elemental logical function isAllocated ( self ) !! Returns the allocation status of the spectrum array. class ( spectrum_type ), intent ( in ) :: self !! `domain` instance isAllocated = allocated ( self % spec ) endfunction isAllocated","tags":"","loc":"proc/isallocated~2.html","title":"isAllocated – wavy"},{"text":"private pure elemental function isMonochromatic(self) Returns .true. if only one frequency bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) Called By proc~~ismonochromatic~~CalledByGraph proc~ismonochromatic isMonochromatic proc~getamplitude getAmplitude proc~getamplitude->proc~ismonochromatic Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code isMonochromatic Source Code pure elemental function isMonochromatic ( self ) !! Returns `.true.` if only one frequency bin is allocated, !! and `.false.` otherwise. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance logical :: isMonochromatic !! return value (boolean) if ( size ( self % f ) == 1 ) then isMonochromatic = . true . else isMonochromatic = . false . endif endfunction isMonochromatic","tags":"","loc":"proc/ismonochromatic.html","title":"isMonochromatic – wavy"},{"text":"private pure elemental function isOmnidirectional(self) Returns .true. if only one direction bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) Source Code isOmnidirectional Source Code pure elemental function isOmnidirectional ( self ) !! Returns `.true.` if only one direction bin is allocated, !! and `.false.` otherwise. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance logical :: isOmnidirectional !! return value (boolean) if ( size ( self % th ) == 1 ) then isOmnidirectional = . true . else isOmnidirectional = . false . endif endfunction isOmnidirectional","tags":"","loc":"proc/isomnidirectional.html","title":"isOmnidirectional – wavy"},{"text":"private pure function getFrequency(self) result(f) Returns the frequency [Hz] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Frequency [Hz] Called By proc~~getfrequency~2~~CalledByGraph proc~getfrequency~2 getFrequency proc~writejson~2 writeJSON proc~writejson~2->proc~getfrequency~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getFrequency Source Code pure function getFrequency ( self ) result ( f ) !! Returns the frequency [Hz] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: f !! Frequency [Hz] f = self % f endfunction getFrequency","tags":"","loc":"proc/getfrequency~2.html","title":"getFrequency – wavy"},{"text":"private pure function getFrequency2d(self) result(f) Returns the frequency [Hz] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Frequency [Hz] Called By proc~~getfrequency2d~~CalledByGraph proc~getfrequency2d getFrequency2d proc~getwaveaction getWaveAction proc~getwaveaction->proc~getfrequency2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getFrequency2d Source Code pure function getFrequency2d ( self ) result ( f ) !! Returns the frequency [Hz] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: f !! Frequency [Hz] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( f ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) f (:, ndir ) = self % f enddo endfunction getFrequency2d","tags":"","loc":"proc/getfrequency2d.html","title":"getFrequency2d – wavy"},{"text":"private pure function getWavenumber(self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Wavenumber [rad/m] Called By proc~~getwavenumber~~CalledByGraph proc~getwavenumber getWavenumber proc~writejson~2 writeJSON proc~writejson~2->proc~getwavenumber Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getWavenumber Source Code pure function getWavenumber ( self ) result ( k ) !! Returns the wavenumber [rad/m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: k !! Wavenumber [rad/m] k = self % k endfunction getWavenumber","tags":"","loc":"proc/getwavenumber.html","title":"getWavenumber – wavy"},{"text":"private pure function getWavenumberSpacing(self) result(dk) Returns the wavenumber spacing [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Wavenumber spacing [rad/m] Source Code getWavenumberSpacing Source Code pure function getWavenumberSpacing ( self ) result ( dk ) !! Returns the wavenumber spacing [rad/m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: dk !! Wavenumber spacing [rad/m] dk = self % dk endfunction getWavenumberSpacing","tags":"","loc":"proc/getwavenumberspacing.html","title":"getWavenumberSpacing – wavy"},{"text":"private pure function getWavenumber2d(self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Wavenumber [rad/m] Source Code getWavenumber2d Source Code pure function getWavenumber2d ( self ) result ( k ) !! Returns the wavenumber [rad/m] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: k !! Wavenumber [rad/m] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( k ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) k (:, ndir ) = self % k enddo endfunction getWavenumber2d","tags":"","loc":"proc/getwavenumber2d.html","title":"getWavenumber2d – wavy"},{"text":"private pure function getWavelength(self) result(lambda) Returns the wavelength [m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Wavelength [m] Source Code getWavelength Source Code pure function getWavelength ( self ) result ( lambda ) !! Returns the wavelength [m] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: lambda !! Wavelength [m] lambda = twopi / self % k endfunction getWavelength","tags":"","loc":"proc/getwavelength.html","title":"getWavelength – wavy"},{"text":"private pure function getDirections(self) result(th) Returns the directions [rad] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Directions [rad] Called By proc~~getdirections~2~~CalledByGraph proc~getdirections~2 getDirections proc~writejson~2 writeJSON proc~writejson~2->proc~getdirections~2 proc~getamplitude getAmplitude proc~getamplitude->proc~getdirections~2 proc~stokesdrift2d stokesDrift2d proc~stokesdrift2d->proc~getdirections~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getDirections Source Code pure function getDirections ( self ) result ( th ) !! Returns the directions [rad] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: th !! Directions [rad] th = self % th endfunction getDirections","tags":"","loc":"proc/getdirections~2.html","title":"getDirections – wavy"},{"text":"private pure function getDirections2d(self) result(th) Returns the directions [rad] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Directions [rad] Source Code getDirections2d Source Code pure function getDirections2d ( self ) result ( th ) !! Returns the directions [rad] array of the spectrum instance, reshaped to !! match the spectrum array shape. This method is most useful for conforming !! shape array in 2-d spectrum computations. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: th !! Directions [rad] integer :: ndirs , nfreqs integer :: nfreq nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( th ( nfreqs , ndirs )) do concurrent ( nfreq = 1 : nfreqs ) th ( nfreq ,:) = self % th enddo endfunction getDirections2d","tags":"","loc":"proc/getdirections2d.html","title":"getDirections2d – wavy"},{"text":"private pure function getPhaseSpeed(self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Phase speed [m/s] Source Code getPhaseSpeed Source Code pure function getPhaseSpeed ( self ) result ( cp ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: cp !! Phase speed [m/s] cp = self % cp endfunction getPhaseSpeed","tags":"","loc":"proc/getphasespeed~2.html","title":"getPhaseSpeed – wavy"},{"text":"private pure function getPhaseSpeed2d(self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Phase speed [m/s] Source Code getPhaseSpeed2d Source Code pure function getPhaseSpeed2d ( self ) result ( cp ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: cp !! Phase speed [m/s] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( cp ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) cp (:, ndir ) = self % cp enddo endfunction getPhaseSpeed2d","tags":"","loc":"proc/getphasespeed2d.html","title":"getPhaseSpeed2d – wavy"},{"text":"private pure function getGroupSpeed(self) result(cg) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Group speed [m/s] Source Code getGroupSpeed Source Code pure function getGroupSpeed ( self ) result ( cg ) !! Returns the phase speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: cg !! Group speed [m/s] cg = self % cg endfunction getGroupSpeed","tags":"","loc":"proc/getgroupspeed~2.html","title":"getGroupSpeed – wavy"},{"text":"private pure function getGroupSpeed2d(self) result(cg) Returns the group speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Group speed [m/s] Source Code getGroupSpeed2d Source Code pure function getGroupSpeed2d ( self ) result ( cg ) !! Returns the group speed [m/s] array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: cg !! Group speed [m/s] integer :: ndirs , nfreqs integer :: ndir nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( cg ( nfreqs , ndirs )) do concurrent ( ndir = 1 : ndirs ) cg (:, ndir ) = self % cg enddo endfunction getGroupSpeed2d","tags":"","loc":"proc/getgroupspeed2d.html","title":"getGroupSpeed2d – wavy"},{"text":"private pure function getSpectrum(self) result(spec) Returns the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Spectrum array Called By proc~~getspectrum~2~~CalledByGraph proc~getspectrum~2 getSpectrum proc~spectrum_add_spectrum spectrum_add_spectrum proc~spectrum_add_spectrum->proc~getspectrum~2 proc~spectrum_mult_real spectrum_mult_real proc~spectrum_mult_real->proc~getspectrum~2 proc~real2d_mult_spectrum real2d_mult_spectrum proc~real2d_mult_spectrum->proc~getspectrum~2 proc~spectrum_unary_minus spectrum_unary_minus proc~spectrum_unary_minus->proc~getspectrum~2 proc~eq~2 eq proc~eq~2->proc~getspectrum~2 proc~spectrum_add_real spectrum_add_real proc~spectrum_add_real->proc~getspectrum~2 proc~spectrum_sub_real spectrum_sub_real proc~spectrum_sub_real->proc~getspectrum~2 proc~real_mult_spectrum real_mult_spectrum proc~real_mult_spectrum->proc~getspectrum~2 proc~spectrum_sub_spectrum spectrum_sub_spectrum proc~spectrum_sub_spectrum->proc~getspectrum~2 proc~real_add_spectrum real_add_spectrum proc~real_add_spectrum->proc~getspectrum~2 proc~gt gt proc~gt->proc~getspectrum~2 proc~spectrum_mult_real2d spectrum_mult_real2d proc~spectrum_mult_real2d->proc~getspectrum~2 proc~writejson~2 writeJSON proc~writejson~2->proc~getspectrum~2 proc~real_div_spectrum real_div_spectrum proc~real_div_spectrum->proc~getspectrum~2 proc~lt lt proc~lt->proc~getspectrum~2 proc~spectrum_mult_spectrum spectrum_mult_spectrum proc~spectrum_mult_spectrum->proc~getspectrum~2 proc~ge ge proc~ge->proc~getspectrum~2 proc~spectrum_div_real spectrum_div_real proc~spectrum_div_real->proc~getspectrum~2 proc~real_sub_spectrum real_sub_spectrum proc~real_sub_spectrum->proc~getspectrum~2 proc~le le proc~le->proc~getspectrum~2 proc~spectrum_div_spectrum spectrum_div_spectrum proc~spectrum_div_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getSpectrum Source Code pure function getSpectrum ( self ) result ( spec ) !! Returns the spectrum array. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: spec !! Spectrum array spec = self % spec endfunction getSpectrum","tags":"","loc":"proc/getspectrum~2.html","title":"getSpectrum – wavy"},{"text":"private pure function getWaveAction(self) result(wave_action) Returns the wave action spectrum, which corresponds to the the wave\n variance spectrum normalized by the intrinsic frequency. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Wave action array Calls proc~~getwaveaction~~CallsGraph proc~getwaveaction getWaveAction proc~getfrequency2d getFrequency2d proc~getwaveaction->proc~getfrequency2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getWaveAction Source Code pure function getWaveAction ( self ) result ( wave_action ) !! Returns the wave action spectrum, which corresponds to the the wave !! variance spectrum normalized by the intrinsic frequency. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: wave_action !! Wave action array wave_action = self % spec / self % getFrequency2d () endfunction getWaveAction","tags":"","loc":"proc/getwaveaction.html","title":"getWaveAction – wavy"},{"text":"private pure function getAmplitude(self) result(a) Returns the amplitude array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Amplitude [m] Calls proc~~getamplitude~~CallsGraph proc~getamplitude getAmplitude spec spec proc~getamplitude->spec proc~ismonochromatic isMonochromatic proc~getamplitude->proc~ismonochromatic proc~getdirections~2 getDirections proc~getamplitude->proc~getdirections~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getAmplitude Source Code pure function getAmplitude ( self ) result ( a ) !! Returns the amplitude array. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: a !! Amplitude [m] integer :: ndir , ndirs if ( self % isMonochromatic ()) then a = sqrt ( 2 * self % spec ) else ndirs = size ( self % getDirections ()) do concurrent ( ndir = 1 : ndirs ) a (:, ndir ) = sqrt ( 2 * self % spec (:, ndir ) * self % df ) enddo endif endfunction getAmplitude","tags":"","loc":"proc/getamplitude.html","title":"getAmplitude – wavy"},{"text":"private pure function getCurrent_u(self) result(u) Returns the current velocity in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Mean current velocity in x-direction [m/s] Called By proc~~getcurrent_u~2~~CalledByGraph proc~getcurrent_u~2 getCurrent_u proc~writejson~2 writeJSON proc~writejson~2->proc~getcurrent_u~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getCurrent_u Source Code pure function getCurrent_u ( self ) result ( u ) !! Returns the current velocity in x-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: u !! Mean current velocity in x-direction [m/s] u = self % u endfunction getCurrent_u","tags":"","loc":"proc/getcurrent_u~2.html","title":"getCurrent_u – wavy"},{"text":"private pure function getCurrent_v(self) result(v) Returns the current velocity in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Mean current velocity in y-direction [m/s] Called By proc~~getcurrent_v~2~~CalledByGraph proc~getcurrent_v~2 getCurrent_v proc~writejson~2 writeJSON proc~writejson~2->proc~getcurrent_v~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getCurrent_v Source Code pure function getCurrent_v ( self ) result ( v ) !! Returns the current velocity in y-direction. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: v !! Mean current velocity in y-direction [m/s] v = self % v endfunction getCurrent_v","tags":"","loc":"proc/getcurrent_v~2.html","title":"getCurrent_v – wavy"},{"text":"private pure function getDepthLevels(self) result(z) Returns the depth levels at which the current arrays are defined. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Depth levels of current fields [m] Called By proc~~getdepthlevels~~CalledByGraph proc~getdepthlevels getDepthLevels proc~writejson~2 writeJSON proc~writejson~2->proc~getdepthlevels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getDepthLevels Source Code pure function getDepthLevels ( self ) result ( z ) !! Returns the depth levels at which the current arrays are defined. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: z !! Depth levels of current fields [m] z = self % z endfunction getDepthLevels","tags":"","loc":"proc/getdepthlevels.html","title":"getDepthLevels – wavy"},{"text":"private pure elemental function getDepth(self) result(depth) Returns the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean water depth [m] Called By proc~~getdepth~2~~CalledByGraph proc~getdepth~2 getDepth proc~writejson~2 writeJSON proc~writejson~2->proc~getdepth~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getDepth Source Code pure elemental function getDepth ( self ) result ( depth ) !! Returns the mean water depth [m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: depth !! Mean water depth [m] depth = self % depth endfunction getDepth","tags":"","loc":"proc/getdepth~2.html","title":"getDepth – wavy"},{"text":"private pure elemental function getElevation(self) result(elevation) Returns the mean surface elevation anomaly [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean surface elevation anomaly [m] Called By proc~~getelevation~2~~CalledByGraph proc~getelevation~2 getElevation proc~writejson~2 writeJSON proc~writejson~2->proc~getelevation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getElevation Source Code pure elemental function getElevation ( self ) result ( elevation ) !! Returns the mean surface elevation anomaly [m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: elevation !! Mean surface elevation anomaly [m] elevation = self % elevation endfunction getElevation","tags":"","loc":"proc/getelevation~2.html","title":"getElevation – wavy"},{"text":"private pure elemental function getGravity(self) result(grav) Returns the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Gravitational acceleration [m/s&#94;2] Called By proc~~getgravity~2~~CalledByGraph proc~getgravity~2 getGravity proc~writejson~2 writeJSON proc~writejson~2->proc~getgravity~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getGravity Source Code pure elemental function getGravity ( self ) result ( grav ) !! Returns the gravitational acceleration [m/s&#94;2]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: grav !! Gravitational acceleration [m/s&#94;2] grav = self % grav endfunction getGravity","tags":"","loc":"proc/getgravity~2.html","title":"getGravity – wavy"},{"text":"private pure elemental function getSurfaceTension(self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Surface tension [N/m] Called By proc~~getsurfacetension~2~~CalledByGraph proc~getsurfacetension~2 getSurfaceTension proc~writejson~2 writeJSON proc~writejson~2->proc~getsurfacetension~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getSurfaceTension Source Code pure elemental function getSurfaceTension ( self ) result ( surface_tension ) !! Returns the surface tension [N/m]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: surface_tension !! Surface tension [N/m] surface_tension = self % surface_tension endfunction getSurfaceTension","tags":"","loc":"proc/getsurfacetension~2.html","title":"getSurfaceTension – wavy"},{"text":"private pure elemental function getWaterDensity(self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Water density [kg/m&#94;3] Called By proc~~getwaterdensity~2~~CalledByGraph proc~getwaterdensity~2 getWaterDensity proc~writejson~2 writeJSON proc~writejson~2->proc~getwaterdensity~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code getWaterDensity Source Code pure elemental function getWaterDensity ( self ) result ( water_density ) !! Returns the water density [kg/m&#94;3]. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ) :: water_density !! Water density [kg/m&#94;3] water_density = self % water_density endfunction getWaterDensity","tags":"","loc":"proc/getwaterdensity~2.html","title":"getWaterDensity – wavy"},{"text":"private pure function omnidirectionalSpectrum(self) result(spec) Returns the omnidirectional spectrum that corresponds to the input\n directional spectrum, integrated over all directions. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:),allocatable Spectrum array Calls proc~~omnidirectionalspectrum~~CallsGraph proc~omnidirectionalspectrum omnidirectionalSpectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~omnidirectionalspectrum~~CalledByGraph proc~omnidirectionalspectrum omnidirectionalSpectrum proc~peakfrequencydiscrete peakFrequencyDiscrete proc~peakfrequencydiscrete->proc~omnidirectionalspectrum proc~peakfrequency peakFrequency proc~peakfrequency->proc~omnidirectionalspectrum proc~frequencymoment~2 frequencyMoment proc~frequencymoment~2->proc~omnidirectionalspectrum proc~stokesdrift stokesDrift proc~stokesdrift->proc~omnidirectionalspectrum proc~peakedness peakedness proc~peakedness->proc~omnidirectionalspectrum proc~peakedness->proc~frequencymoment~2 proc~significantwaveheight~2 significantWaveHeight proc~significantwaveheight~2->proc~frequencymoment~2 proc~meanperiodzerocrossing~2 meanPeriodZeroCrossing proc~meanperiodzerocrossing~2->proc~frequencymoment~2 proc~meanperiod~2 meanPeriod proc~meanperiod~2->proc~frequencymoment~2 proc~ursellnumber ursellNumber proc~ursellnumber->proc~significantwaveheight~2 proc~ursellnumber->proc~meanperiod~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code omnidirectionalSpectrum Source Code pure function omnidirectionalSpectrum ( self ) result ( spec ) !! Returns the omnidirectional spectrum that corresponds to the input !! directional spectrum, integrated over all directions. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), allocatable :: spec !! Spectrum array integer ( kind = ik ) :: ndir , ndirs , nfreqs nfreqs = size ( self % spec , dim = 1 ) ndirs = size ( self % spec , dim = 2 ) allocate ( spec ( nfreqs )) spec = 0 do ndir = 1 , ndirs spec (:) = spec (:) + self % spec (:, ndir ) * self % dth ( ndir ) enddo endfunction omnidirectionalSpectrum","tags":"","loc":"proc/omnidirectionalspectrum.html","title":"omnidirectionalSpectrum – wavy"},{"text":"private pure elemental function meanSquareSlope(self) Returns the mean square slope of the spectrum, which is the second\n moment of the wavenumber spectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~meansquareslope~~CallsGraph proc~meansquareslope meanSquareSlope proc~wavenumbermoment~2 wavenumberMoment proc~meansquareslope->proc~wavenumbermoment~2 proc~wavenumberspectrum wavenumberSpectrum proc~wavenumbermoment~2->proc~wavenumberspectrum cg cg proc~wavenumberspectrum->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/meansquareslope.html","title":"meanSquareSlope – wavy"},{"text":"private pure function meanSquareSlopeDirectional(self) result(mss) For each directional frequency bin, computes the mean square slope of all\n all waves longer than that bin, projected to the direction of that bin. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Directional mean square slope Calls proc~~meansquareslopedirectional~~CallsGraph proc~meansquareslopedirectional meanSquareSlopeDirectional k k proc~meansquareslopedirectional->k dk dk proc~meansquareslopedirectional->dk proc~wavenumberspectrum wavenumberSpectrum proc~meansquareslopedirectional->proc~wavenumberspectrum th th proc~meansquareslopedirectional->th cg cg proc~wavenumberspectrum->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code meanSquareSlopeDirectional Source Code pure function meanSquareSlopeDirectional ( self ) result ( mss ) !! For each directional frequency bin, computes the mean square slope of all !! all waves longer than that bin, projected to the direction of that bin. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: mss !! Directional mean square slope real ( kind = rk ), dimension (:,:), allocatable :: wavenumber_spectrum real ( kind = rk ), dimension (:,:), allocatable :: dir_projection integer :: nfreq , nfreqs integer :: ndir , ndirs nfreqs = size ( self % f ) ndirs = size ( self % th ) wavenumber_spectrum = self % wavenumberSpectrum () ! Compute projection of each wave direction onto every other direction allocate ( dir_projection ( ndirs , ndirs )) do concurrent ( ndir = 1 : ndirs ) dir_projection (:, ndir ) = abs ( cos ( self % th ( ndir ) - self % th (:))) enddo allocate ( mss ( nfreqs , ndirs )) mss = 0 do ndir = 1 , ndirs do nfreq = 2 , nfreqs mss ( nfreq , ndir ) = mss ( nfreq - 1 , ndir ) & + sum ( wavenumber_spectrum ( nfreq - 1 ,:) * dir_projection (:, ndir ))& * self % k ( nfreq - 1 ) ** 2 * self % dk ( nfreq - 1 ) enddo enddo deallocate ( dir_projection , wavenumber_spectrum ) endfunction meanSquareSlopeDirectional","tags":"","loc":"proc/meansquareslopedirectional.html","title":"meanSquareSlopeDirectional – wavy"},{"text":"private pure elemental function momentum_x(self) Returns total wave momentum [kg/m/s] in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~momentum_x~~CallsGraph proc~momentum_x momentum_x df df proc~momentum_x->df spec spec proc~momentum_x->spec cp cp proc~momentum_x->cp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/momentum_x.html","title":"momentum_x – wavy"},{"text":"private pure elemental function momentum_y(self) Returns total wave momentum [kg/m/s] in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~momentum_y~~CallsGraph proc~momentum_y momentum_y df df proc~momentum_y->df spec spec proc~momentum_y->spec cp cp proc~momentum_y->cp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/momentum_y.html","title":"momentum_y – wavy"},{"text":"private pure elemental function momentumFlux_xx(self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~momentumflux_xx~~CallsGraph proc~momentumflux_xx momentumFlux_xx df df proc~momentumflux_xx->df cp cp proc~momentumflux_xx->cp spec spec proc~momentumflux_xx->spec cg cg proc~momentumflux_xx->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/momentumflux_xx.html","title":"momentumFlux_xx – wavy"},{"text":"private pure elemental function momentumFlux_xy(self) Returns total advective flux [kg/m&#94;2/s&#94;2] in x-direction of momentum in\n y-direction and vice versa (flux in y-direction of momentum in\n y-direction), because \\int{Cgx My} == \\int{Cgy Mx}. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~momentumflux_xy~~CallsGraph proc~momentumflux_xy momentumFlux_xy df df proc~momentumflux_xy->df cp cp proc~momentumflux_xy->cp spec spec proc~momentumflux_xy->spec cg cg proc~momentumflux_xy->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/momentumflux_xy.html","title":"momentumFlux_xy – wavy"},{"text":"private pure elemental function momentumFlux_yy(self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~momentumflux_yy~~CallsGraph proc~momentumflux_yy momentumFlux_yy df df proc~momentumflux_yy->df cp cp proc~momentumflux_yy->cp spec spec proc~momentumflux_yy->spec cg cg proc~momentumflux_yy->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/momentumflux_yy.html","title":"momentumFlux_yy – wavy"},{"text":"private pure elemental function frequencyMoment(self, n) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) Calls proc~~frequencymoment~2~~CallsGraph proc~frequencymoment~2 frequencyMoment proc~omnidirectionalspectrum omnidirectionalSpectrum proc~frequencymoment~2->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~frequencymoment~2~~CalledByGraph proc~frequencymoment~2 frequencyMoment proc~significantwaveheight~2 significantWaveHeight proc~significantwaveheight~2->proc~frequencymoment~2 proc~peakedness peakedness proc~peakedness->proc~frequencymoment~2 proc~meanperiodzerocrossing~2 meanPeriodZeroCrossing proc~meanperiodzerocrossing~2->proc~frequencymoment~2 proc~meanperiod~2 meanPeriod proc~meanperiod~2->proc~frequencymoment~2 proc~ursellnumber ursellNumber proc~ursellnumber->proc~significantwaveheight~2 proc~ursellnumber->proc~meanperiod~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/frequencymoment~2.html","title":"frequencyMoment – wavy"},{"text":"private pure elemental function peakedness(self) Returns the peakedness parameter that quantifies the sharpness of the\n spectral peak, following Goda (1970). References: Goda, Y., 1970. Numerical experiments on waves statistics with spectral\n simulation. Report. Port and Harbour Research Institute , Japan, 9 ,\n 3-57. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~peakedness~~CallsGraph proc~peakedness peakedness proc~omnidirectionalspectrum omnidirectionalSpectrum proc~peakedness->proc~omnidirectionalspectrum proc~frequencymoment~2 frequencyMoment proc~peakedness->proc~frequencymoment~2 dth dth proc~omnidirectionalspectrum->dth proc~frequencymoment~2->proc~omnidirectionalspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/peakedness.html","title":"peakedness – wavy"},{"text":"private pure elemental function peakFrequency(self) Returns the peak frequency based on Young (1995). References: Young, I, 1995. The determination of confidence limits associated with\n estimates of the spectral peak frequency. Ocean Engng. , 22 , 669-686. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~peakfrequency~~CallsGraph proc~peakfrequency peakFrequency proc~omnidirectionalspectrum omnidirectionalSpectrum proc~peakfrequency->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/peakfrequency.html","title":"peakFrequency – wavy"},{"text":"private pure elemental function peakFrequencyDiscrete(self) Returns the peak frequency based on simple discrete maximum location of\n the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~peakfrequencydiscrete~~CallsGraph proc~peakfrequencydiscrete peakFrequencyDiscrete proc~omnidirectionalspectrum omnidirectionalSpectrum proc~peakfrequencydiscrete->proc~omnidirectionalspectrum f f proc~peakfrequencydiscrete->f dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/peakfrequencydiscrete.html","title":"peakFrequencyDiscrete – wavy"},{"text":"private pure elemental function wavenumberMoment(self, n) Returns the spectral wavenumber moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) Calls proc~~wavenumbermoment~2~~CallsGraph proc~wavenumbermoment~2 wavenumberMoment proc~wavenumberspectrum wavenumberSpectrum proc~wavenumbermoment~2->proc~wavenumberspectrum cg cg proc~wavenumberspectrum->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~wavenumbermoment~2~~CalledByGraph proc~wavenumbermoment~2 wavenumberMoment proc~meansquareslope meanSquareSlope proc~meansquareslope->proc~wavenumbermoment~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/wavenumbermoment~2.html","title":"wavenumberMoment – wavy"},{"text":"private pure function wavenumberSpectrum(self) result(spec) Returns the wavenumber spectrum array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Spectrum array Calls proc~~wavenumberspectrum~~CallsGraph proc~wavenumberspectrum wavenumberSpectrum cg cg proc~wavenumberspectrum->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~wavenumberspectrum~~CalledByGraph proc~wavenumberspectrum wavenumberSpectrum proc~saturationspectrum saturationSpectrum proc~saturationspectrum->proc~wavenumberspectrum proc~wavenumbermoment~2 wavenumberMoment proc~wavenumbermoment~2->proc~wavenumberspectrum proc~meansquareslopedirectional meanSquareSlopeDirectional proc~meansquareslopedirectional->proc~wavenumberspectrum proc~meansquareslope meanSquareSlope proc~meansquareslope->proc~wavenumbermoment~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code wavenumberSpectrum Source Code pure function wavenumberSpectrum ( self ) result ( spec ) !! Returns the wavenumber spectrum array of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: spec !! Spectrum array integer :: nfreq , nfreqs integer :: ndirs nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( spec ( nfreqs , ndirs )) do concurrent ( nfreq = 1 : nfreqs ) spec ( nfreq ,:) = self % spec ( nfreq ,:) * self % cg ( nfreq ) / twopi enddo endfunction wavenumberSpectrum","tags":"","loc":"proc/wavenumberspectrum.html","title":"wavenumberSpectrum – wavy"},{"text":"private pure function saturationSpectrum(self) Returns the saturation spectrum B(k) = F(k)k&#94;4. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:),allocatable Saturation spectrum result Calls proc~~saturationspectrum~~CallsGraph proc~saturationspectrum saturationSpectrum proc~wavenumberspectrum wavenumberSpectrum proc~saturationspectrum->proc~wavenumberspectrum cg cg proc~wavenumberspectrum->cg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code saturationSpectrum Source Code pure function saturationSpectrum ( self ) !! Returns the saturation spectrum B(k) = F(k)k&#94;4. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), allocatable :: saturationSpectrum !! Saturation spectrum result real ( kind = rk ), dimension (:,:), allocatable :: wavenumber_spectrum integer :: nfreqs , ndirs integer :: n nfreqs = size ( self % f ) ndirs = size ( self % th ) allocate ( saturationSpectrum ( nfreqs , ndirs )) wavenumber_spectrum = self % wavenumberSpectrum () do concurrent ( n = 1 : ndirs ) saturationSpectrum (:, n ) = wavenumber_spectrum (:, n ) * self % k ** 4 enddo endfunction saturationSpectrum","tags":"","loc":"proc/saturationspectrum.html","title":"saturationSpectrum – wavy"},{"text":"private pure elemental function significantWaveHeight(self) Returns the significant wave height [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~significantwaveheight~2~~CallsGraph proc~significantwaveheight~2 significantWaveHeight proc~frequencymoment~2 frequencyMoment proc~significantwaveheight~2->proc~frequencymoment~2 proc~omnidirectionalspectrum omnidirectionalSpectrum proc~frequencymoment~2->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~significantwaveheight~2~~CalledByGraph proc~significantwaveheight~2 significantWaveHeight proc~ursellnumber ursellNumber proc~ursellnumber->proc~significantwaveheight~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/significantwaveheight~2.html","title":"significantWaveHeight – wavy"},{"text":"private pure elemental function significantSurfaceOrbitalVelocity(self) result(uorb) Returns the significant surface orbital velocity [m/s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk)","tags":"","loc":"proc/significantsurfaceorbitalvelocity.html","title":"significantSurfaceOrbitalVelocity – wavy"},{"text":"private pure function stokesDrift(self, z) Exact solution of Stokes drift based on linear wave theory, given input \n omnidirectional spectrum and distance from surface z [m], negative \n downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:),allocatable Stokes drift array [m/s] Calls proc~~stokesdrift~~CallsGraph proc~stokesdrift stokesDrift proc~omnidirectionalspectrum omnidirectionalSpectrum proc~stokesdrift->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code stokesDrift Source Code pure function stokesDrift ( self , z ) !! Exact solution of Stokes drift based on linear wave theory, given input !! omnidirectional spectrum and distance from surface `z` [m], negative !! downward. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: z !! Distance from surface [m], negative downward real ( kind = rk ), dimension (:), allocatable :: stokesDrift !! Stokes drift array [m/s] integer ( kind = ik ) :: n allocate ( stokesDrift ( size ( z ))) do concurrent ( n = 1 : size ( z )) stokesDrift ( n ) = sum ( self % omnidirectionalSpectrum () * self % k & * exp ( 2 * self % k * z ( n )) * self % df ) enddo endfunction stokesDrift","tags":"","loc":"proc/stokesdrift.html","title":"stokesDrift – wavy"},{"text":"private pure function stokesDrift2d(self, z) Exact solution of Stokes drift based on linear wave theory, given input \n directional spectrum and distance from surface z [m], negative downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:,:),allocatable Stokes drift array [m/s] Calls proc~~stokesdrift2d~~CallsGraph proc~stokesdrift2d stokesDrift2d dth dth proc~stokesdrift2d->dth th th proc~stokesdrift2d->th proc~getdirections~2 getDirections proc~stokesdrift2d->proc~getdirections~2 spec spec proc~stokesdrift2d->spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code stokesDrift2d Source Code pure function stokesDrift2d ( self , z ) !! Exact solution of Stokes drift based on linear wave theory, given input !! directional spectrum and distance from surface `z` [m], negative downward. class ( spectrum_type ), intent ( in ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: z !! Distance from surface [m], negative downward real ( kind = rk ), dimension (:,:), allocatable :: stokesDrift2d !! Stokes drift array [m/s] integer ( kind = ik ) :: n , ndir , ndirs ndirs = size ( self % getDirections ()) allocate ( stokesDrift2d ( size ( z ), 2 )) stokesDrift2d = 0 do n = 1 , size ( z ) stokesDrift2d ( n ,:) = 0 do ndir = 1 , ndirs ! x-component of Stokes drift stokesDrift2d ( n , 1 ) = stokesDrift2d ( n , 1 )& + sum ( self % spec (:, ndir ) * cos ( self % th ( ndir ))& * self % k * exp ( 2 * self % k * z ( n ))& * self % df * self % dth ( ndir )) ! y-component of Stokes drift stokesDrift2d ( n , 2 ) = stokesDrift2d ( n , 2 )& + sum ( self % spec (:, ndir ) * sin ( self % th ( ndir ))& * self % k * exp ( 2 * self % k * z ( n ))& * self % df * self % dth ( ndir )) enddo enddo endfunction stokesDrift2d","tags":"","loc":"proc/stokesdrift2d.html","title":"stokesDrift2d – wavy"},{"text":"private pure elemental function meanPeriod(self) Returns the mean wave period [s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~meanperiod~2~~CallsGraph proc~meanperiod~2 meanPeriod proc~frequencymoment~2 frequencyMoment proc~meanperiod~2->proc~frequencymoment~2 proc~omnidirectionalspectrum omnidirectionalSpectrum proc~frequencymoment~2->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~meanperiod~2~~CalledByGraph proc~meanperiod~2 meanPeriod proc~ursellnumber ursellNumber proc~ursellnumber->proc~meanperiod~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/meanperiod~2.html","title":"meanPeriod – wavy"},{"text":"private pure elemental function meanPeriodZeroCrossing(self) Returns the zero-crossing mean wave period [s]: Tm02 = \\sqrt(m_0 / m_2) Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~meanperiodzerocrossing~2~~CallsGraph proc~meanperiodzerocrossing~2 meanPeriodZeroCrossing proc~frequencymoment~2 frequencyMoment proc~meanperiodzerocrossing~2->proc~frequencymoment~2 proc~omnidirectionalspectrum omnidirectionalSpectrum proc~frequencymoment~2->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/meanperiodzerocrossing~2.html","title":"meanPeriodZeroCrossing – wavy"},{"text":"private pure elemental function ursellNumber(self) Returns the Ursell number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Calls proc~~ursellnumber~~CallsGraph proc~ursellnumber ursellNumber proc~significantwaveheight~2 significantWaveHeight proc~ursellnumber->proc~significantwaveheight~2 proc~meanperiod~2 meanPeriod proc~ursellnumber->proc~meanperiod~2 proc~frequencymoment~2 frequencyMoment proc~significantwaveheight~2->proc~frequencymoment~2 proc~meanperiod~2->proc~frequencymoment~2 proc~omnidirectionalspectrum omnidirectionalSpectrum proc~frequencymoment~2->proc~omnidirectionalspectrum dth dth proc~omnidirectionalspectrum->dth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ursellnumber.html","title":"ursellNumber – wavy"},{"text":"private pure elemental function eq(self, s2) Logical equality comparison function. Overloads the == operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Calls proc~~eq~2~~CallsGraph proc~eq~2 eq proc~getspectrum~2 getSpectrum proc~eq~2->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eq Source Code pure elemental logical function eq ( self , s2 ) !! Logical equality comparison function. Overloads the `==` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance eq = all ( self % getSpectrum () == s2 % getSpectrum ()) endfunction eq","tags":"","loc":"proc/eq~2.html","title":"eq – wavy"},{"text":"private pure elemental function neq(self, s2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Source Code neq Source Code pure elemental logical function neq ( self , s2 ) !! Logical inequality comparison function. Overloads the `/=` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance neq = . not . self == s2 endfunction neq","tags":"","loc":"proc/neq~2.html","title":"neq – wavy"},{"text":"private pure elemental function gt(self, s2) Logical greater than comparison function. Overloads the > operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Calls proc~~gt~~CallsGraph proc~gt gt proc~getspectrum~2 getSpectrum proc~gt->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gt Source Code pure elemental logical function gt ( self , s2 ) !! Logical greater than comparison function. Overloads the `>` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance gt = all ( self % getSpectrum () > s2 % getSpectrum ()) endfunction gt","tags":"","loc":"proc/gt.html","title":"gt – wavy"},{"text":"private pure elemental function lt(self, s2) Logical less than comparison function. Overloads the < operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Calls proc~~lt~~CallsGraph proc~lt lt proc~getspectrum~2 getSpectrum proc~lt->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lt Source Code pure elemental logical function lt ( self , s2 ) !! Logical less than comparison function. Overloads the `<` operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance lt = all ( self % getSpectrum () < s2 % getSpectrum ()) endfunction lt","tags":"","loc":"proc/lt.html","title":"lt – wavy"},{"text":"private pure elemental function ge(self, s2) Logical greater than or equal comparison function. Overloads the >= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Calls proc~~ge~~CallsGraph proc~ge ge proc~getspectrum~2 getSpectrum proc~ge->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ge Source Code pure elemental logical function ge ( self , s2 ) !! Logical greater than or equal comparison function. Overloads the `>=` !! operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance ge = all ( self % getSpectrum () >= s2 % getSpectrum ()) endfunction ge","tags":"","loc":"proc/ge.html","title":"ge – wavy"},{"text":"private pure elemental function le(self, s2) Logical less than or equal comparison function. Overloads the <= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical Calls proc~~le~~CallsGraph proc~le le proc~getspectrum~2 getSpectrum proc~le->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code le Source Code pure elemental logical function le ( self , s2 ) !! Logical less than or equal comparison function. Overloads the `<=` !! operator. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance le = all ( self % getSpectrum () <= s2 % getSpectrum ()) endfunction le","tags":"","loc":"proc/le.html","title":"le – wavy"},{"text":"private pure elemental function spectrum_add_spectrum(self, s2) result(spec) Returns a spectrum instance with the spectrum array values being the sum of\n the two input spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~spectrum_add_spectrum~~CallsGraph proc~spectrum_add_spectrum spectrum_add_spectrum proc~getspectrum~2 getSpectrum proc~spectrum_add_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_add_spectrum Source Code pure elemental type ( spectrum_type ) function spectrum_add_spectrum ( self , s2 )& result ( spec ) !! Returns a spectrum instance with the spectrum array values being the sum of !! the two input spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () + s2 % getSpectrum () endfunction spectrum_add_spectrum","tags":"","loc":"proc/spectrum_add_spectrum.html","title":"spectrum_add_spectrum – wavy"},{"text":"private pure elemental function spectrum_sub_spectrum(self, s2) result(spec) Subtracts one spectrum instance from another and returns the resulting\n spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~spectrum_sub_spectrum~~CallsGraph proc~spectrum_sub_spectrum spectrum_sub_spectrum proc~getspectrum~2 getSpectrum proc~spectrum_sub_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_sub_spectrum Source Code pure elemental type ( spectrum_type ) function spectrum_sub_spectrum ( self , s2 )& result ( spec ) !! Subtracts one spectrum instance from another and returns the resulting !! spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () - s2 % getSpectrum () endfunction spectrum_sub_spectrum","tags":"","loc":"proc/spectrum_sub_spectrum.html","title":"spectrum_sub_spectrum – wavy"},{"text":"private pure elemental function spectrum_mult_spectrum(self, s2) result(spec) Returns a product of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~spectrum_mult_spectrum~~CallsGraph proc~spectrum_mult_spectrum spectrum_mult_spectrum proc~getspectrum~2 getSpectrum proc~spectrum_mult_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_mult_spectrum Source Code pure elemental type ( spectrum_type ) function spectrum_mult_spectrum ( self , s2 )& result ( spec ) !! Returns a product of two spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * s2 % getSpectrum () endfunction spectrum_mult_spectrum","tags":"","loc":"proc/spectrum_mult_spectrum.html","title":"spectrum_mult_spectrum – wavy"},{"text":"private pure elemental function spectrum_div_spectrum(self, s2) result(spec) Returns a division of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~spectrum_div_spectrum~~CallsGraph proc~spectrum_div_spectrum spectrum_div_spectrum proc~getspectrum~2 getSpectrum proc~spectrum_div_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_div_spectrum Source Code pure elemental type ( spectrum_type ) function spectrum_div_spectrum ( self , s2 )& result ( spec ) !! Returns a division of two spectrum instances. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance class ( spectrum_type ), intent ( in ) :: s2 !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () / s2 % getSpectrum () endfunction spectrum_div_spectrum","tags":"","loc":"proc/spectrum_div_spectrum.html","title":"spectrum_div_spectrum – wavy"},{"text":"private pure elemental function spectrum_add_real(self, a) result(spec) Returns a sum of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) Calls proc~~spectrum_add_real~~CallsGraph proc~spectrum_add_real spectrum_add_real proc~getspectrum~2 getSpectrum proc~spectrum_add_real->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_add_real Source Code pure elemental type ( spectrum_type ) function spectrum_add_real ( self , a )& result ( spec ) !! Returns a sum of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () + a endfunction spectrum_add_real","tags":"","loc":"proc/spectrum_add_real.html","title":"spectrum_add_real – wavy"},{"text":"private pure elemental function spectrum_sub_real(self, a) result(spec) Returns a difference of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) Calls proc~~spectrum_sub_real~~CallsGraph proc~spectrum_sub_real spectrum_sub_real proc~getspectrum~2 getSpectrum proc~spectrum_sub_real->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_sub_real Source Code pure elemental type ( spectrum_type ) function spectrum_sub_real ( self , a )& result ( spec ) !! Returns a difference of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () - a endfunction spectrum_sub_real","tags":"","loc":"proc/spectrum_sub_real.html","title":"spectrum_sub_real – wavy"},{"text":"private pure elemental function spectrum_mult_real(self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) Calls proc~~spectrum_mult_real~~CallsGraph proc~spectrum_mult_real spectrum_mult_real proc~getspectrum~2 getSpectrum proc~spectrum_mult_real->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_mult_real Source Code pure elemental type ( spectrum_type ) function spectrum_mult_real ( self , a )& result ( spec ) !! Returns a product of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () * a endfunction spectrum_mult_real","tags":"","loc":"proc/spectrum_mult_real.html","title":"spectrum_mult_real – wavy"},{"text":"private pure function spectrum_mult_real2d(self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: a r.h.s. real 2-d array Return Value type( spectrum_type ) Calls proc~~spectrum_mult_real2d~~CallsGraph proc~spectrum_mult_real2d spectrum_mult_real2d proc~getspectrum~2 getSpectrum proc~spectrum_mult_real2d->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_mult_real2d Source Code pure type ( spectrum_type ) function spectrum_mult_real2d ( self , a )& result ( spec ) !! Returns a product of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), dimension (:,:), intent ( in ) :: a !! r.h.s. real 2-d array spec = self spec = self % getSpectrum () * a endfunction spectrum_mult_real2d","tags":"","loc":"proc/spectrum_mult_real2d.html","title":"spectrum_mult_real2d – wavy"},{"text":"private pure elemental function spectrum_div_real(self, a) result(spec) Returns a division of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) Calls proc~~spectrum_div_real~~CallsGraph proc~spectrum_div_real spectrum_div_real proc~getspectrum~2 getSpectrum proc~spectrum_div_real->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_div_real Source Code pure elemental type ( spectrum_type ) function spectrum_div_real ( self , a ) result ( spec ) !! Returns a division of a spectrum instance and a real number. class ( spectrum_type ), intent ( in ) :: self !! l.h.s. spectrum instance real ( kind = rk ), intent ( in ) :: a !! r.h.s. real number spec = self spec = self % getSpectrum () / a endfunction spectrum_div_real","tags":"","loc":"proc/spectrum_div_real.html","title":"spectrum_div_real – wavy"},{"text":"private pure elemental function real_add_spectrum(a, self) result(spec) Returns a sum of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~real_add_spectrum~~CallsGraph proc~real_add_spectrum real_add_spectrum proc~getspectrum~2 getSpectrum proc~real_add_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_add_spectrum Source Code pure elemental type ( spectrum_type ) function real_add_spectrum ( a , self )& result ( spec ) !! Returns a sum of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () + a endfunction real_add_spectrum","tags":"","loc":"proc/real_add_spectrum.html","title":"real_add_spectrum – wavy"},{"text":"private pure elemental function real_sub_spectrum(a, self) result(spec) Returns a difference between a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~real_sub_spectrum~~CallsGraph proc~real_sub_spectrum real_sub_spectrum proc~getspectrum~2 getSpectrum proc~real_sub_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_sub_spectrum Source Code pure elemental type ( spectrum_type ) function real_sub_spectrum ( a , self )& result ( spec ) !! Returns a difference between a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = a - self % getSpectrum () endfunction real_sub_spectrum","tags":"","loc":"proc/real_sub_spectrum.html","title":"real_sub_spectrum – wavy"},{"text":"private pure elemental function real_mult_spectrum(a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~real_mult_spectrum~~CallsGraph proc~real_mult_spectrum real_mult_spectrum proc~getspectrum~2 getSpectrum proc~real_mult_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_mult_spectrum Source Code pure elemental type ( spectrum_type ) function real_mult_spectrum ( a , self )& result ( spec ) !! Returns a product of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * a endfunction real_mult_spectrum","tags":"","loc":"proc/real_mult_spectrum.html","title":"real_mult_spectrum – wavy"},{"text":"private pure function real2d_mult_spectrum(a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: a l.h.s. real 2-d array class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~real2d_mult_spectrum~~CallsGraph proc~real2d_mult_spectrum real2d_mult_spectrum proc~getspectrum~2 getSpectrum proc~real2d_mult_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real2d_mult_spectrum Source Code pure type ( spectrum_type ) function real2d_mult_spectrum ( a , self )& result ( spec ) !! Returns a product of a real number and a spectrum instance. real ( kind = rk ), dimension (:,:), intent ( in ) :: a !! l.h.s. real 2-d array class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = self % getSpectrum () * a endfunction real2d_mult_spectrum","tags":"","loc":"proc/real2d_mult_spectrum.html","title":"real2d_mult_spectrum – wavy"},{"text":"private pure elemental function real_div_spectrum(a, self) result(spec) Returns a division of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~real_div_spectrum~~CallsGraph proc~real_div_spectrum real_div_spectrum proc~getspectrum~2 getSpectrum proc~real_div_spectrum->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code real_div_spectrum Source Code pure elemental type ( spectrum_type ) function real_div_spectrum ( a , self ) result ( spec ) !! Returns a division of a real number and a spectrum instance. real ( kind = rk ), intent ( in ) :: a !! l.h.s. real number class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = a / self % getSpectrum () endfunction real_div_spectrum","tags":"","loc":"proc/real_div_spectrum.html","title":"real_div_spectrum – wavy"},{"text":"private pure elemental function spectrum_unary_minus(self) result(spec) Returns a negative value of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) Calls proc~~spectrum_unary_minus~~CallsGraph proc~spectrum_unary_minus spectrum_unary_minus proc~getspectrum~2 getSpectrum proc~spectrum_unary_minus->proc~getspectrum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum_unary_minus Source Code pure elemental type ( spectrum_type ) function spectrum_unary_minus ( self )& result ( spec ) !! Returns a negative value of the spectrum instance. class ( spectrum_type ), intent ( in ) :: self !! r.h.s. spectrum instance spec = self spec = - self % getSpectrum () endfunction spectrum_unary_minus","tags":"","loc":"proc/spectrum_unary_minus.html","title":"spectrum_unary_minus – wavy"},{"text":"private pure elemental function wavenumber(f, depth, water_density, grav, surface_tension) Solves the linear water wave dispersion relationship using a\n Newton-Raphson iteration loop. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Intrinsic frequency [Hz] real(kind=rk), intent(in), optional :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value real(kind=rk) Called By proc~~wavenumber~~CalledByGraph proc~wavenumber wavenumber proc~constructor~2 constructor proc~constructor~2->proc~wavenumber interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code wavenumber Source Code pure elemental function wavenumber ( f , depth , water_density , grav , surface_tension ) !! Solves the linear water wave dispersion relationship using a !! Newton-Raphson iteration loop. real ( kind = rk ), intent ( in ) :: f !! Intrinsic frequency [Hz] real ( kind = rk ), optional , intent ( in ) :: depth !! Mean water depth [m] real ( kind = rk ), optional , intent ( in ) :: water_density !! Water density [kg/m&#94;3] real ( kind = rk ), optional , intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), optional , intent ( in ) :: surface_tension !! Surface tension [N/m] real ( kind = rk ) :: wavenumber , dk , b , fnd , t integer :: counter associate ( k => wavenumber ) fnd = twopi * f * sqrt ( depth / grav ) k = fnd ** 2 b = surface_tension / ( water_density * grav * depth ** 2 ) counter = 1 dk = 2 e - 3_rk newton_raphson : do t = tanh ( k ) dk = - ( fnd ** 2 - k * t * ( 1 + b * k ** 2 ))& / ( 3 * b * k ** 2 * t + t + k * ( 1 + b * k ** 2 ) * ( 1 - t ** 2 )) k = k - dk if ( abs ( dk ) < eps . or . counter > 100 ) then exit newton_raphson endif counter = counter + 1 enddo newton_raphson k = k / depth endassociate endfunction wavenumber","tags":"","loc":"proc/wavenumber.html","title":"wavenumber – wavy"},{"text":"private pure subroutine setSpectrum1d(self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: spec Input 1-d spectrum array Source Code setSpectrum1d Source Code pure subroutine setSpectrum1d ( self , spec ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: spec !! Input 1-d spectrum array self % spec (:, 1 ) = spec endsubroutine setSpectrum1d","tags":"","loc":"proc/setspectrum1d~2.html","title":"setSpectrum1d – wavy"},{"text":"private pure subroutine setSpectrum2d(self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:,:) :: spec Input 2-d spectrum array Source Code setSpectrum2d Source Code pure subroutine setSpectrum2d ( self , spec ) !! Sets the 2-d spectrum array. This procedure is overloaded by the !! generic procedure setSpectrum. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:,:), intent ( in ) :: spec !! Input 2-d spectrum array self % spec = spec endsubroutine setSpectrum2d","tags":"","loc":"proc/setspectrum2d~2.html","title":"setSpectrum2d – wavy"},{"text":"private pure subroutine setCurrent1d(self, u, z) Sets the 1-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] Calls proc~~setcurrent1d~~CallsGraph proc~setcurrent1d setCurrent1d v v proc~setcurrent1d->v Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setCurrent1d Source Code pure subroutine setCurrent1d ( self , u , z ) !! Sets the 1-d current velocity field. This procedure is overloaded by the !! generic procedure setCurrent. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: u !! Current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: z !! Depth levels for the velocity array [m] self % u = u self % z = z allocate ( self % v ( size ( u ))) self % v = 0 endsubroutine setCurrent1d","tags":"","loc":"proc/setcurrent1d.html","title":"setCurrent1d – wavy"},{"text":"private pure subroutine setCurrent2d(self, u, v, z) Sets the 2-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: v Current velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] Called By proc~~setcurrent2d~~CalledByGraph proc~setcurrent2d setCurrent2d proc~constructor~2 constructor proc~constructor~2->proc~setcurrent2d interface~spectrum_type spectrum_type interface~spectrum_type->proc~constructor~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code setCurrent2d Source Code pure subroutine setCurrent2d ( self , u , v , z ) !! Sets the 2-d current velocity field. This procedure is overloaded by the !! generic procedure setCurrent. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), dimension (:), intent ( in ) :: u !! Current velocity in x-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: v !! Current velocity in y-direction [m/s] real ( kind = rk ), dimension (:), intent ( in ) :: z !! Depth levels for the velocity array [m] self % u = u self % v = v self % z = z endsubroutine setCurrent2d","tags":"","loc":"proc/setcurrent2d.html","title":"setCurrent2d – wavy"},{"text":"private pure elemental subroutine setDepth(self, depth) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: depth Mean water depth [m] Source Code setDepth Source Code pure elemental subroutine setDepth ( self , depth ) !! Sets the mean surface elevation value. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: depth !! Mean water depth [m] self % depth = depth endsubroutine setDepth","tags":"","loc":"proc/setdepth~2.html","title":"setDepth – wavy"},{"text":"private pure elemental subroutine setElevation(self, elevation) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: elevation Mean surface elevation anomaly [m] Source Code setElevation Source Code pure elemental subroutine setElevation ( self , elevation ) !! Sets the mean surface elevation value. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: elevation !! Mean surface elevation anomaly [m] self % elevation = elevation endsubroutine setElevation","tags":"","loc":"proc/setelevation~2.html","title":"setElevation – wavy"},{"text":"private pure elemental subroutine setGravity(self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Source Code setGravity Source Code pure elemental subroutine setGravity ( self , grav ) !! Sets the gravitational acceleration [m/s&#94;2]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] self % grav = grav endsubroutine setGravity","tags":"","loc":"proc/setgravity~2.html","title":"setGravity – wavy"},{"text":"private pure elemental subroutine setSurfaceTension(self, surface_tension) Sets the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: surface_tension Surface tension [N/m] Source Code setSurfaceTension Source Code pure elemental subroutine setSurfaceTension ( self , surface_tension ) !! Sets the surface tension [N/m]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: surface_tension !! Surface tension [N/m] self % surface_tension = surface_tension endsubroutine setSurfaceTension","tags":"","loc":"proc/setsurfacetension~2.html","title":"setSurfaceTension – wavy"},{"text":"private pure elemental subroutine setAirDensity(self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: air_density Air density [kg/m&#94;3] Source Code setAirDensity Source Code pure elemental subroutine setAirDensity ( self , air_density ) !! Sets the air density [kg/m&#94;3]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: air_density !! Air density [kg/m&#94;3] self % air_density = air_density endsubroutine setAirDensity","tags":"","loc":"proc/setairdensity~2.html","title":"setAirDensity – wavy"},{"text":"private pure elemental subroutine setWaterDensity(self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: water_density Water density [kg/m&#94;3] Source Code setWaterDensity Source Code pure elemental subroutine setWaterDensity ( self , water_density ) !! Sets the water density [kg/m&#94;3]. class ( spectrum_type ), intent ( inout ) :: self !! Spectrum instance real ( kind = rk ), intent ( in ) :: water_density !! Water density [kg/m&#94;3] self % water_density = water_density endsubroutine setWaterDensity","tags":"","loc":"proc/setwaterdensity~2.html","title":"setWaterDensity – wavy"},{"text":"private pure subroutine assign_array_1d(self, array) Assigns a 1-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:) :: array r.h.s. array of reals Calls proc~~assign_array_1d~~CallsGraph proc~assign_array_1d assign_array_1d setspectrum setspectrum proc~assign_array_1d->setspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_array_1d Source Code pure subroutine assign_array_1d ( self , array ) !! Assigns a 1-d array of reals to a `spectrum` instance. This procedure !! overloads the assignment ('=') operator. class ( spectrum_type ), intent ( inout ) :: self !! l.h.s. `spectrum` instance real ( kind = rk ), dimension (:), intent ( in ) :: array !! r.h.s. array of reals call self % setSpectrum ( array ) endsubroutine assign_array_1d","tags":"","loc":"proc/assign_array_1d.html","title":"assign_array_1d – wavy"},{"text":"private pure subroutine assign_array_2d(self, array) Assigns a 2-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: array r.h.s. array of reals Calls proc~~assign_array_2d~~CallsGraph proc~assign_array_2d assign_array_2d setspectrum setspectrum proc~assign_array_2d->setspectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_array_2d Source Code pure subroutine assign_array_2d ( self , array ) !! Assigns a 2-d array of reals to a `spectrum` instance. This procedure !! overloads the assignment ('=') operator. class ( spectrum_type ), intent ( inout ) :: self !! l.h.s. `spectrum` instance real ( kind = rk ), dimension (:,:), intent ( in ) :: array !! r.h.s. array of reals call self % setSpectrum ( array ) endsubroutine assign_array_2d","tags":"","loc":"proc/assign_array_2d.html","title":"assign_array_2d – wavy"},{"text":"private subroutine readJSON(self, filename) Read a spectrum instance from a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name Calls proc~~readjson~~CallsGraph proc~readjson readJSON interface~diff diff proc~readjson->interface~diff interface~diff_periodic diff_periodic proc~readjson->interface~diff_periodic initialize initialize proc~readjson->initialize destroy destroy proc~readjson->destroy load_file load_file proc~readjson->load_file get get proc~readjson->get proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d proc~diff_periodic_1d diff_periodic_1d interface~diff_periodic->proc~diff_periodic_1d proc~diff_periodic_2d diff_periodic_2d interface~diff_periodic->proc~diff_periodic_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code readJSON Source Code subroutine readJSON ( self , filename ) !! Read a spectrum instance from a JSON file. class ( spectrum_type ), intent ( inout ) :: self !! `spectrum` instance character ( len =* ), intent ( in ) :: filename !! JSON file name type ( json_file ) :: json logical :: found integer ( kind = ik ) :: nfreqs integer ( kind = ik ) :: ndirs real ( kind = rk ), dimension (:), allocatable :: arr call json % initialize () call json % load_file ( trim ( filename )) call json % get ( 'frequency' , self % f , found ) call json % get ( 'wavenumber' , self % k , found ) call json % get ( 'directions' , self % th , found ) call json % get ( 'spectrum' , arr , found ) nfreqs = size ( self % f ) ndirs = size ( self % th ) self % spec = reshape ( arr ,[ nfreqs , ndirs ]) call json % get ( 'depth' , self % depth , found ) call json % get ( 'elevation' , self % elevation , found ) call json % get ( 'gravity' , self % grav , found ) call json % get ( 'air_density' , self % air_density , found ) call json % get ( 'water_density' , self % water_density , found ) call json % get ( 'surface_tension' , self % surface_tension , found ) call json % get ( 'u-velocity' , self % u , found ) call json % get ( 'v-velocity' , self % v , found ) call json % get ( 'z' , self % z , found ) call json % destroy () self % df = diff ( self % f ) self % dk = diff ( self % k ) if ( ndirs > 1 ) then self % dth = diff_periodic ( self % th ) else self % dth = [ 1 ] endif self % cp = twopi * self % f / self % k self % cg = twopi * self % df / self % dk endsubroutine readJSON","tags":"","loc":"proc/readjson.html","title":"readJSON – wavy"},{"text":"private subroutine writeJSON(self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file Calls proc~~writejson~2~~CallsGraph proc~writejson~2 writeJSON proc~getwaterdensity~2 getWaterDensity proc~writejson~2->proc~getwaterdensity~2 proc~getspectrum~2 getSpectrum proc~writejson~2->proc~getspectrum~2 destroy destroy proc~writejson~2->destroy proc~getwavenumber getWavenumber proc~writejson~2->proc~getwavenumber add add proc~writejson~2->add proc~getdirections~2 getDirections proc~writejson~2->proc~getdirections~2 proc~getairdensity~2 getAirDensity proc~writejson~2->proc~getairdensity~2 proc~getcurrent_u~2 getCurrent_u proc~writejson~2->proc~getcurrent_u~2 proc~getcurrent_v~2 getCurrent_v proc~writejson~2->proc~getcurrent_v~2 proc~getsurfacetension~2 getSurfaceTension proc~writejson~2->proc~getsurfacetension~2 initialize initialize proc~writejson~2->initialize proc~getelevation~2 getElevation proc~writejson~2->proc~getelevation~2 proc~getdepthlevels getDepthLevels proc~writejson~2->proc~getdepthlevels proc~getgravity~2 getGravity proc~writejson~2->proc~getgravity~2 proc~getfrequency~2 getFrequency proc~writejson~2->proc~getfrequency~2 create_object create_object proc~writejson~2->create_object proc~getdepth~2 getDepth proc~writejson~2->proc~getdepth~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code writeJSON Source Code subroutine writeJSON ( self , filename , minify ) !! Writes a spectrum instance to a JSON file. class ( spectrum_type ), intent ( in ) :: self !! `spectrum` instance character ( len =* ), intent ( in ) :: filename !! JSON file name logical , intent ( in ) :: minify !! Logical switch to minify the JSON file type ( json_core ) :: json type ( json_value ), pointer :: ptr call json % initialize ( no_whitespace = minify , real_format = 'ES' ) call json % create_object ( ptr , '' ) call json % add ( ptr , 'frequency' , self % getFrequency ()) call json % add ( ptr , 'wavenumber' , self % getWavenumber ()) call json % add ( ptr , 'directions' , self % getDirections ()) call json % add ( ptr , 'spectrum' , pack ( self % getSpectrum (),. true .)) call json % add ( ptr , 'depth' , self % getDepth ()) call json % add ( ptr , 'elevation' , self % getElevation ()) call json % add ( ptr , 'gravity' , self % getGravity ()) call json % add ( ptr , 'air_density' , self % getAirDensity ()) call json % add ( ptr , 'water_density' , self % getWaterDensity ()) call json % add ( ptr , 'surface_tension' , self % getSurfaceTension ()) call json % add ( ptr , 'u-velocity' , self % getCurrent_u ()) call json % add ( ptr , 'v-velocity' , self % getCurrent_v ()) call json % add ( ptr , 'z' , self % getDepthLevels ()) call json % print ( ptr , trim ( filename )) call json % destroy ( ptr ) endsubroutine writeJSON","tags":"","loc":"proc/writejson~2.html","title":"writeJSON – wavy"},{"text":"public interface spectrum_type Calls interface~~spectrum_type~~CallsGraph interface~spectrum_type spectrum_type proc~constructor~2 constructor interface~spectrum_type->proc~constructor~2 f f proc~constructor~2->f proc~wavenumber wavenumber proc~constructor~2->proc~wavenumber cg cg proc~constructor~2->cg interface~diff_periodic diff_periodic proc~constructor~2->interface~diff_periodic th th proc~constructor~2->th cp cp proc~constructor~2->cp proc~setcurrent2d setCurrent2d proc~constructor~2->proc~setcurrent2d dk dk proc~constructor~2->dk k k proc~constructor~2->k dth dth proc~constructor~2->dth spec spec proc~constructor~2->spec interface~diff diff proc~constructor~2->interface~diff proc~diff_periodic_1d diff_periodic_1d interface~diff_periodic->proc~diff_periodic_1d proc~diff_periodic_2d diff_periodic_2d interface~diff_periodic->proc~diff_periodic_2d proc~diff_1d diff_1d interface~diff->proc~diff_1d proc~diff_2d diff_2d interface~diff->proc~diff_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures constructor Module Procedures private pure elemental function constructor (fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) result(spectrum) Constructor function for the spectrum object. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: fmin Minimum frequency bin [Hz] real(kind=rk), intent(in) :: fmax Maximum frequency bin [Hz] real(kind=rk), intent(in) :: df Frequency increment, df = f(n+1)/f(n) integer, intent(in) :: ndirs Number of directional bins real(kind=rk), intent(in) :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: air_density Air density [kg/m&#94;3] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value type( spectrum_type )","tags":"","loc":"interface/spectrum_type.html","title":"spectrum_type – wavy"},{"text":"public pure elemental function donelanHamiltonHui(f, fpeak, wspd, grav) result(spec) The omnidirectional spectrum function based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). References: Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional\n spectra of wind-generated waves. Phil. Trans. Royal Soc. London A.,\n 315, 509-562. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) Calls proc~~donelanhamiltonhui~~CallsGraph proc~donelanhamiltonhui donelanHamiltonHui nondimensionalfrequency nondimensionalfrequency proc~donelanhamiltonhui->nondimensionalfrequency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~donelanhamiltonhui~~CalledByGraph proc~donelanhamiltonhui donelanHamiltonHui proc~donelanhamiltonhuidirectionalspectrum donelanHamiltonHuiDirectionalSpectrum proc~donelanhamiltonhuidirectionalspectrum->proc~donelanhamiltonhui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/donelanhamiltonhui.html","title":"donelanHamiltonHui – wavy"},{"text":"public pure elemental function donelanHamiltonHuiDirectionalSpreading(f, wspd, fpeak, theta, theta_mean) result(spreading) Directional spreading function based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). Includes the\n high-frequency form for beta_s found by Banner (1990). References: Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional\n spectra of wind-generated waves. Phil. Trans. Royal Soc. London A. , 315 , 509-562. Banner, M. L., 1990. Equilibrium spectra of wind waves. J. Phys. \n Oceanogr. , 20 , 966-984. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: theta Wave direction [rad] real(kind=rk), intent(in) :: theta_mean Mean wave direction [rad] Return Value real(kind=rk) Called By proc~~donelanhamiltonhuidirectionalspreading~~CalledByGraph proc~donelanhamiltonhuidirectionalspreading donelanHamiltonHuiDirectionalSpreading proc~donelanhamiltonhuidirectionalspectrum donelanHamiltonHuiDirectionalSpectrum proc~donelanhamiltonhuidirectionalspectrum->proc~donelanhamiltonhuidirectionalspreading Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/donelanhamiltonhuidirectionalspreading.html","title":"donelanHamiltonHuiDirectionalSpreading – wavy"},{"text":"public pure function donelanHamiltonHuiDirectionalSpectrum(f, theta, wspd, fpeak, theta_mean, grav) result(spec) Returns directional frequency spectrum based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). Includes the high\n frequency form for beta_s found by Banner (1990). This function invokes the\n  DHH omnidirectional spectrum and the directional spreading functions to\n compute directional frequency spectrum: \n     F(f,\\theta) = F'(f) * D(f,\\theta)\n  References: Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional\n spectra of wind-generated waves. Phil. Trans. Royal Soc. London A.,\n 315, 509-562. Banner, M. L., 1990. Equilibrium spectra of wind waves. J. Phys. Oceanogr.,\n 20, 966-984. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Frequency [Hz] real(kind=rk), intent(in), dimension(:) :: theta Wave direction [rad] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: theta_mean Mean wave direction [rad] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk),\n  dimension(:,:),allocatable Calls proc~~donelanhamiltonhuidirectionalspectrum~~CallsGraph proc~donelanhamiltonhuidirectionalspectrum donelanHamiltonHuiDirectionalSpectrum proc~donelanhamiltonhui donelanHamiltonHui proc~donelanhamiltonhuidirectionalspectrum->proc~donelanhamiltonhui proc~donelanhamiltonhuidirectionalspreading donelanHamiltonHuiDirectionalSpreading proc~donelanhamiltonhuidirectionalspectrum->proc~donelanhamiltonhuidirectionalspreading nondimensionalfrequency nondimensionalfrequency proc~donelanhamiltonhui->nondimensionalfrequency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code donelanHamiltonHuiDirectionalSpectrum Source Code pure function donelanHamiltonHuiDirectionalSpectrum ( f , theta , wspd , fpeak ,& theta_mean , grav ) result ( spec ) !! Returns directional frequency spectrum based on the laboratory and field !! measurements by Donelan, Hamilton, and Hui (1985). Includes the high !! frequency form for beta_s found by Banner (1990). This function invokes the !!  DHH omnidirectional spectrum and the directional spreading functions to !! compute directional frequency spectrum: !! !!  !!     F(f,\\theta) = F'(f) * D(f,\\theta) !!  !! !! References: !! !! Donelan, M. A., J. Hamilton, and W. H. Hui, 1985. Directional !! spectra of wind-generated waves. Phil. Trans. Royal Soc. London A., !! 315, 509-562. !! !! Banner, M. L., 1990. Equilibrium spectra of wind waves. J. Phys. Oceanogr., !! 20, 966-984. real ( kind = rk ), dimension (:), intent ( in ) :: f !! Frequency [Hz] real ( kind = rk ), dimension (:), intent ( in ) :: theta !! Wave direction [rad] real ( kind = rk ), intent ( in ) :: wspd !! Wind speed at 10 m height [m/s] real ( kind = rk ), intent ( in ) :: fpeak !! Peak frequency [Hz] real ( kind = rk ), intent ( in ) :: theta_mean !! Mean wave direction [rad] real ( kind = rk ), intent ( in ) :: grav !! Gravitational acceleration [m/s&#94;2] real ( kind = rk ), dimension (:,:), allocatable :: spec integer ( kind = ik ) :: ndir allocate ( spec ( size ( f ), size ( theta ))) do concurrent ( ndir = 1 : size ( theta )) spec (:, ndir ) = donelanHamiltonHui ( f , fpeak , wspd , grav )& * donelanHamiltonHuiDirectionalSpreading ( f , wspd , fpeak , theta ( ndir ),& theta_mean ) enddo endfunction donelanHamiltonHuiDirectionalSpectrum","tags":"","loc":"proc/donelanhamiltonhuidirectionalspectrum.html","title":"donelanHamiltonHuiDirectionalSpectrum – wavy"},{"text":"public pure elemental function jonswap(f, wspd, fetch, grav) result(spec) Computes the JONSWAP equilibrium spectrum (Hasselmann et al. 1973) based on\n  input wind speed at the height of 10 m and fetch. References: Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell\n decay during the Joint North Sea Wave Project (JONSWAP). Dtsch. Hydrogh.\n Z., Suppl. A, 8, 12, 95pp. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fetch Fetch [m] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) Calls proc~~jonswap~~CallsGraph proc~jonswap jonswap proc~jonswappeakfrequency jonswapPeakFrequency proc~jonswap->proc~jonswappeakfrequency nondimensionalfetch nondimensionalfetch proc~jonswap->nondimensionalfetch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/jonswap.html","title":"jonswap – wavy"},{"text":"public pure elemental function jonswapPeakFrequency(wspd, fetch, grav) result(fpeak) Computes the JONSWAP equilibrium peak frequency [Hz] on the input\n based on the 10-m wind speed and fetch [km] (Hasselmann et al., 1973). References: Hasselmann, K. et al., 1973. Measurements of wind-wave growth and swell\n decay during the Joint North Sea Wave Project (JONSWAP). Dtsch. Hydrogh.\n Z., Suppl. A, 8, 12, 95pp. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fetch Fetch [m] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) Called By proc~~jonswappeakfrequency~~CalledByGraph proc~jonswappeakfrequency jonswapPeakFrequency proc~jonswap jonswap proc~jonswap->proc~jonswappeakfrequency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/jonswappeakfrequency.html","title":"jonswapPeakFrequency – wavy"},{"text":"public pure elemental function phillips(f, fpeak, grav) result(spec) Computes the Phillips (1958) equilibrium spectrum based on the input\n peak frequency [Hz]. References: Phillips, O.M., 1958. The equilibrium range in the spectrum of\n wind-generated waves. J. Fluid Mech., 4, 426–434.\n doi:10.1017/S0022112058000550. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk)","tags":"","loc":"proc/phillips.html","title":"phillips – wavy"},{"text":"public pure elemental function piersonMoskowitz(f, wspd, grav) result(spec) Computes the Pierson-Moskowitz (1964) equilibrium spectrum based on input\n wind speed at the height of 10 m. References: Pierson Jr., W. J., and L. Moskowitz (1964), A proposed spectral form for\n fully developed wind seas based on the similarity theory of S. A.\n Kitaigorodskii, J. Geophys. Res., 69(24), 5181–5190,\n doi:10.1029/JZ069i024p05181. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) Calls proc~~piersonmoskowitz~~CallsGraph proc~piersonmoskowitz piersonMoskowitz proc~piersonmoskowitzpeakfrequency piersonMoskowitzPeakFrequency proc~piersonmoskowitz->proc~piersonmoskowitzpeakfrequency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/piersonmoskowitz.html","title":"piersonMoskowitz – wavy"},{"text":"public pure elemental function piersonMoskowitzPeakFrequency(wspd, grav) result(fpeak) Computes the Pierson-Moskowitz (1964) peak frequency based on input wind\n speed at the height of 10 m. References: Pierson Jr., W. J., and L. Moskowitz (1964), A proposed spectral form for\n fully developed wind seas based on the similarity theory of S. A.\n Kitaigorodskii, J. Geophys. Res., 69(24), 5181–5190,\n doi:10.1029/JZ069i024p05181. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) Called By proc~~piersonmoskowitzpeakfrequency~~CalledByGraph proc~piersonmoskowitzpeakfrequency piersonMoskowitzPeakFrequency proc~piersonmoskowitz piersonMoskowitz proc~piersonmoskowitz->proc~piersonmoskowitzpeakfrequency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/piersonmoskowitzpeakfrequency.html","title":"piersonMoskowitzPeakFrequency – wavy"},{"text":"Uses: mod_precision mod_utility module~~mod_grid~~UsesGraph module~mod_grid mod_grid module~mod_precision mod_precision module~mod_precision->module~mod_grid module~mod_utility mod_utility module~mod_precision->module~mod_utility module~mod_utility->module~mod_grid iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_grid~~UsedByGraph module~mod_grid mod_grid module~mod_domain mod_domain module~mod_grid->module~mod_domain module~mod_time_integration mod_time_integration module~mod_domain->module~mod_time_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables stdout stderr Interfaces grid_type Derived Types grid_type Functions constructor_1d constructor_2d getLowerBounds getUpperBounds getAxisX getAxisY getGridSpacingX getGridSpacingY getGridRotation getLongitude getLatitude Variables Type Visibility Attributes Name Initial integer(kind=intkind), public, parameter :: stdout = 6 integer(kind=intkind), public, parameter :: stderr = 0 Interfaces public interface grid_type private function constructor_1d (lb, ub, x, dx) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:) :: dx Grid spacing in x-direction [m] Return Value type( grid_type ) private function constructor_2d (lb, ub, x, y, dx, dy, lon, lat) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in), dimension(:) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in), dimension(:) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:,:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: y Distance in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dy Grid spacing in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: lon Longitude [rad] real(kind=realkind), intent(in), optional dimension(:,:) :: lat Latitude [rad] Return Value type( grid_type ) Derived Types type, public :: grid_type Components Type Visibility Attributes Name Initial integer(kind=intkind), private, dimension(2) :: lb Lower bounds of the grid integer(kind=intkind), private, dimension(2) :: ub Upper bounds of the grid real(kind=realkind), private, dimension(:,:), allocatable :: x Distance in x-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: y Distance in y-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: dx Grid spacing in x-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: dy Grid spacing in y-direction [m] real(kind=realkind), private, dimension(:,:), allocatable :: lon Longitude [rad] real(kind=realkind), private, dimension(:,:), allocatable :: lat Latitude [rad] real(kind=realkind), private, dimension(:,:), allocatable :: alpha Grid rotation angle [rad] Constructor private  function constructor_1d (lb, ub, x, dx) private  function constructor_2d (lb, ub, x, y, dx, dy, lon, lat) Type-Bound Procedures procedure, public, pass(self) :: getLowerBounds procedure, public, pass(self) :: getUpperBounds procedure, public, pass(self) :: getAxisX procedure, public, pass(self) :: getAxisY procedure, public, pass(self) :: getGridSpacingX procedure, public, pass(self) :: getGridSpacingY procedure, public, pass(self) :: getGridRotation procedure, public, pass(self) :: getLongitude procedure, public, pass(self) :: getLatitude Functions private function constructor_1d (lb, ub, x, dx) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:) :: dx Grid spacing in x-direction [m] Return Value type( grid_type ) private function constructor_2d (lb, ub, x, y, dx, dy, lon, lat) result(grid) Arguments Type Intent Optional Attributes Name integer(kind=intkind), intent(in), dimension(:) :: lb Lower bound indices of the grid array integer(kind=intkind), intent(in), dimension(:) :: ub Upper bound indices of the grid array real(kind=realkind), intent(in), optional dimension(:,:) :: x Distance in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: y Distance in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: dy Grid spacing in y-direction [m] real(kind=realkind), intent(in), optional dimension(:,:) :: lon Longitude [rad] real(kind=realkind), intent(in), optional dimension(:,:) :: lat Latitude [rad] Return Value type( grid_type ) private pure function getLowerBounds (self) result(lb) Returns the lower bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Upper bound indices private pure function getUpperBounds (self) result(ub) Returns the upper bounds of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value integer(kind=intkind),\n  dimension(2) Lower bound indices private pure function getAxisX (self) result(x) Returns the x-coordinate of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable x-coordinate [m] private pure function getAxisY (self) result(y) Returns the y-coordinate [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable y-coordinate [m] private pure function getGridSpacingX (self) result(dx) Returns the grid spacing in x [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid spacing in x [m] private pure function getGridSpacingY (self) result(dy) Returns the grid spacing in y [m] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid spacing in y [m] private pure function getGridRotation (self) result(alpha) Returns the grid rotation angle [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Grid rotation [rad] private pure function getLongitude (self) result(lon) Returns the longitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Longitude [rad] private pure function getLatitude (self) result(lat) Returns the latitude array [rad] of the grid instance. Arguments Type Intent Optional Attributes Name class( grid_type ), intent(in) :: self Grid instance Return Value real(kind=realkind),\n  dimension(:,:), allocatable Latitude [rad]","tags":"","loc":"module/mod_grid.html","title":"mod_grid – wavy"},{"text":"Uses: mod_precision module~~mod_const~~UsesGraph module~mod_const mod_const module~mod_precision mod_precision module~mod_precision->module~mod_const iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_const~~UsedByGraph module~mod_const mod_const module~mod_spectral_shapes mod_spectral_shapes module~mod_const->module~mod_spectral_shapes proc~snl_dccm2012 snl_DCCM2012 module~mod_const->proc~snl_dccm2012 module~mod_spectrum mod_spectrum module~mod_const->module~mod_spectrum proc~sin_dccm2012 sin_DCCM2012 module~mod_const->proc~sin_dccm2012 module~mod_domain mod_domain module~mod_const->module~mod_domain proc~sds_dccm2012 sds_DCCM2012 module~mod_const->proc~sds_dccm2012 module~mod_spectrum->proc~snl_dccm2012 module~mod_spectrum->proc~sin_dccm2012 module~mod_spectrum->module~mod_domain module~mod_spectrum->proc~sds_dccm2012 proc~sbf_dccm2012 sbf_DCCM2012 module~mod_spectrum->proc~sbf_dccm2012 module~mod_time_integration mod_time_integration module~mod_spectrum->module~mod_time_integration proc~sdt_dccm2012 sdt_DCCM2012 module~mod_spectrum->proc~sdt_dccm2012 proc~sbf_jonswap sbf_JONSWAP module~mod_spectrum->proc~sbf_jonswap module~mod_domain->module~mod_time_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables WAVY_OMNIDIRECTIONAL WAVY_DIRECTIONAL WAVY_DIRECTIONAL_2D WAVY_REAL WAVY_INT huge_int tiny_real huge_real eps pi twopi stdout stderr Variables Type Visibility Attributes Name Initial integer(kind=ik), public, parameter, dimension(1) :: WAVY_OMNIDIRECTIONAL = [1] integer(kind=ik), public, parameter, dimension(1,1) :: WAVY_DIRECTIONAL = reshape([1], [1, 1]) integer(kind=ik), public, parameter, dimension(1,1,1) :: WAVY_DIRECTIONAL_2D = reshape([1], [1, 1, 1]) real(kind=rk), public, parameter :: WAVY_REAL = 1._rk integer(kind=ik), public, parameter :: WAVY_INT = 1 integer(kind=ik), public, parameter :: huge_int = huge(1_ik) real(kind=rk), public, parameter :: tiny_real = tiny(1e0_rk) real(kind=rk), public, parameter :: huge_real = huge(1e0_rk) real(kind=rk), public, parameter :: eps = tiny(1e0_rk) real(kind=rk), public, parameter :: pi = 3.14159265358979323846264338327950_rk real(kind=rk), public, parameter :: twopi = 2*pi integer(kind=ik), public, parameter :: stdout = 6 integer(kind=ik), public, parameter :: stderr = 0","tags":"","loc":"module/mod_const.html","title":"mod_const – wavy"},{"text":"Uses: mod_precision module~~mod_io~~UsesGraph module~mod_io mod_io module~mod_precision mod_precision module~mod_precision->module~mod_io iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/mod_io.html","title":"mod_io – wavy"},{"text":"Uses: mod_precision module~~mod_linear_wave_theory~~UsesGraph module~mod_linear_wave_theory mod_linear_wave_theory module~mod_precision mod_precision module~mod_precision->module~mod_linear_wave_theory iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions elevation pressure horizontalAcceleration horizontalVelocity verticalAcceleration verticalVelocity Functions public pure elemental function elevation (x, t, a, k, omega) Returns the elevation [m] of a sinusoid wave given its amplitude [m],\n wavenumber [rad/m], and frequency [Hz]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) public pure elemental function pressure (x, z, t, a, k, omega, rho, grav) Returns the pressure [Pa] at depth z (negative downward) for a sinusoid\n wave given its amplitude [m], wavenumber [rad/m], and frequency [Hz]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical displacement [m] from the surface, negative downward real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] real(kind=realkind), intent(in) :: rho Water density [kg/m&#94;3] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function horizontalAcceleration (x, z, t, a, k, omega) Returns the horizontal acceleration of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) public pure elemental function horizontalVelocity (x, z, t, a, k, omega) Returns the horizontal velocity of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) public pure elemental function verticalAcceleration (x, z, t, a, k, omega) Returns the vertical acceleration of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind) public pure elemental function verticalVelocity (x, z, t, a, k, omega) Returns the vertical velocity of a water particle under a sinusoid wave,\n given its amplitude, wavenumber, and frequency. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: x Horizontal space [m] real(kind=realkind), intent(in) :: z Vertical space, negative downward [m] real(kind=realkind), intent(in) :: t Time [s] real(kind=realkind), intent(in) :: a Wave amplitude [m] real(kind=realkind), intent(in) :: k Wavenumber [rad/m] real(kind=realkind), intent(in) :: omega Angular frequency [rad] Return Value real(kind=realkind)","tags":"","loc":"module/mod_linear_wave_theory.html","title":"mod_linear_wave_theory – wavy"},{"text":"Uses: mod_precision module~~mod_stokes~~UsesGraph module~mod_stokes mod_stokes module~mod_precision mod_precision module~mod_precision->module~mod_stokes iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/mod_stokes.html","title":"mod_stokes – wavy"},{"text":"Uses: mod_precision mod_spectrum mod_grid mod_const datetime_module json_module module~~mod_domain~~UsesGraph module~mod_domain mod_domain json_module json_module json_module->module~mod_domain module~mod_spectrum mod_spectrum json_module->module~mod_spectrum module~mod_spectrum->module~mod_domain datetime_module datetime_module datetime_module->module~mod_domain datetime_module->module~mod_spectrum module~mod_grid mod_grid module~mod_grid->module~mod_domain module~mod_const mod_const module~mod_const->module~mod_domain module~mod_const->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_domain module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_grid module~mod_precision->module~mod_const module~mod_utility mod_utility module~mod_precision->module~mod_utility module~mod_utility->module~mod_spectrum module~mod_utility->module~mod_grid iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_domain~~UsedByGraph module~mod_domain mod_domain module~mod_time_integration mod_time_integration module~mod_domain->module~mod_time_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces domain_type Derived Types domain_type Functions constructor advect1dRank1 advect1dRank2 advect2dRank2 isAllocated eq neq domain_add_domain domain_sub_domain domain_unary_minus domain_mult_domain domain_div_domain domain_add_real domain_sub_real domain_mult_real domain_div_real real_add_domain real_sub_domain real_mult_domain real_div_domain getCurrent_u getCurrent_v getDepth getElevation getFrequency getDirections getGravity getGrid getLowerBounds getUpperBounds getSpectrum getSpectrumArray getPhaseSpeed getGroupSpeed getGridSpacingXWithHalo getGridSpacingYWithHalo getSurfaceTension getAirDensity getWaterDensity frequencyMoment wavenumberMoment meanPeriod meanPeriodZeroCrossing significantWaveHeight Subroutines assign_spectrum_array_1d assign_spectrum_array_2d setDepth setElevation setGravity setSurfaceTension setAirDensity setWaterDensity setSpectrum1d setSpectrum2d setSpectrumArray1d1d setSpectrumArray1d2d setSpectrumArray2d2d writeJSON Interfaces public interface domain_type private function constructor (grid, spectrum, shallow_water_mode) result(domain) Constructor function for the domain object. Arguments Type Intent Optional Attributes Name type( grid_type ), intent(in) :: grid Input grid instance type( spectrum_type ), intent(in) :: spectrum Input spectrum instance logical, intent(in), optional :: shallow_water_mode Logical switch to enable shallow water solver Return Value type( domain_type ) Derived Types type, public :: domain_type Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: type_name type( grid_type ), private :: grid type( spectrum_type ), private, dimension(:,:), allocatable :: spectrum logical, private :: shallow_water_mode type(datetime), private :: start_time Simulation start time type(datetime), private :: end_time Simulation end time type(timedelta), private :: time_step Time step [s] real(kind=rk), private, dimension(:,:), allocatable :: dx real(kind=rk), private, dimension(:,:), allocatable :: dy real(kind=rk), private, dimension(:,:), allocatable :: u real(kind=rk), private, dimension(:,:), allocatable :: v real(kind=rk), private, dimension(:,:), allocatable :: eta real(kind=rk), private, dimension(:,:), allocatable :: depth integer(kind=ik), private, dimension(2) :: lb integer(kind=ik), private, dimension(2) :: ub integer(kind=ik), private :: nfreqs integer(kind=ik), private :: ndirs Constructor private  function constructor (grid, spectrum, shallow_water_mode) Constructor function for the domain object. Type-Bound Procedures procedure, public, pass(self) :: frequencyMoment procedure, public, pass(self) :: getCurrent_u procedure, public, pass(self) :: getCurrent_v procedure, public, pass(self) :: getGravity procedure, public, pass(self) :: getGrid procedure, public, pass(self) :: getGridSpacingXWithHalo procedure, public, pass(self) :: getGridSpacingYWithHalo procedure, public, pass(self) :: getDepth procedure, public, pass(self) :: getElevation procedure, public, pass(self) :: getFrequency procedure, public, pass(self) :: getDirections procedure, public, pass(self) :: getLowerBounds procedure, public, pass(self) :: getUpperBounds procedure, public, pass(self) :: getSpectrum procedure, public, pass(self) :: getSpectrumArray procedure, public, pass(self) :: getPhaseSpeed procedure, public, pass(self) :: getGroupSpeed procedure, public, pass(self) :: getSurfaceTension procedure, public, pass(self) :: getAirDensity procedure, public, pass(self) :: getWaterDensity procedure, public, pass(self) :: isAllocated procedure, public, pass(self) :: meanPeriod procedure, public, pass(self) :: meanPeriodZeroCrossing procedure, public, pass(self) :: setDepth procedure, public, pass(self) :: setElevation procedure, public, pass(self) :: setGravity procedure, public, pass(self) :: setSurfaceTension procedure, public, pass(self) :: setAirDensity procedure, public, pass(self) :: setWaterDensity procedure, public, pass(self) :: significantWaveHeight procedure, public, pass(self) :: wavenumberMoment procedure, public, pass(self) :: writeJSON procedure, private, pass(self) :: advect1dRank1 procedure, private, pass(self) :: advect1dRank2 procedure, private, pass(self) :: advect2dRank2 procedure, private, pass(self) :: assign_spectrum_array_1d procedure, private, pass(self) :: assign_spectrum_array_2d procedure, private, pass(self) :: domain_add_domain procedure, private, pass(self) :: domain_add_real procedure, private, pass(self) :: domain_sub_domain procedure, private, pass(self) :: domain_sub_real procedure, private, pass(self) :: domain_mult_domain procedure, private, pass(self) :: domain_mult_real procedure, private, pass(self) :: domain_div_domain procedure, private, pass(self) :: domain_div_real procedure, private, pass(self) :: domain_unary_minus procedure, private, pass(self) :: real_add_domain procedure, private, pass(self) :: real_sub_domain procedure, private, pass(self) :: real_mult_domain procedure, private, pass(self) :: real_div_domain procedure, private, pass(self) :: eq procedure, private, pass(self) :: neq procedure, private, pass(self) :: setSpectrum1d procedure, private, pass(self) :: setSpectrum2d procedure, private, pass(self) :: setSpectrumArray1d1d procedure, private, pass(self) :: setSpectrumArray1d2d procedure, private, pass(self) :: setSpectrumArray2d2d generic, public :: advect => advect1dRank1, advect1dRank2, advect2dRank2 generic, public :: setSpectrum => setSpectrum1d, setSpectrum2d generic, public :: setSpectrumArray => setSpectrumArray1d1d, setSpectrumArray1d2d, setSpectrumArray2d2d generic, public :: assignment(=) => assign_spectrum_array_1d, assign_spectrum_array_2d generic, public :: operator(+) => domain_add_domain, domain_add_real, real_add_domain generic, public :: operator(-) => domain_sub_domain, domain_sub_real, domain_unary_minus, real_sub_domain generic, public :: operator(*) => domain_mult_domain, domain_mult_real, real_mult_domain generic, public :: operator(/) => domain_div_domain, domain_div_real, real_div_domain generic, public :: operator(==) => eq generic, public :: operator(/=) => neq Functions private function constructor (grid, spectrum, shallow_water_mode) result(domain) Constructor function for the domain object. Arguments Type Intent Optional Attributes Name type( grid_type ), intent(in) :: grid Input grid instance type( spectrum_type ), intent(in) :: spectrum Input spectrum instance logical, intent(in), optional :: shallow_water_mode Logical switch to enable shallow water solver Return Value type( domain_type ) private pure function advect1dRank1 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works only in cases where ndirs == 1 . Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f real(kind=rk), intent(in), dimension(:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) private pure function advect1dRank2 (self, advection_method, halowidth, directional_type) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, dx) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:) :: u real(kind=rk), intent(in), dimension(:) :: dx Return Value real(kind=rk),\n  dimension(:,:,:), allocatable integer(kind=ik), intent(in) :: halowidth number of halo cells to use in the advection method integer(kind=ik), intent(in), dimension(:,:) :: directional_type A global constant that helps resolve the interface of this specific\n prodedure Return Value type( domain_type ) private pure function advect2dRank2 (self, advection_method, halowidth) result(adv) Computes the advective tendency for the domain instance given the desired\n advection method as an input function and the number of halo cells. This \n function works both when ndirs == 1 (omnidirectional) and when ndirs > 1 (directional). Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance public pure function advection_method(f, u, v, dx, dy) result(tendency) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f real(kind=rk), intent(in), dimension(:,:,:,:) :: u real(kind=rk), intent(in), dimension(:,:,:,:) :: v real(kind=rk), intent(in), dimension(:,:) :: dx real(kind=rk), intent(in), dimension(:,:) :: dy Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable integer(kind=ik), intent(in), dimension(:) :: halowidth number of halo cells to use in the advection method Return Value type( domain_type ) private pure elemental function isAllocated (self) Returns the allocation status of the domains sub-components. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value logical private pure elemental function eq (self, d2) Logical equality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical private pure elemental function neq (self, d2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value logical private pure elemental function domain_add_domain (self, d2) result(domain) Returns a sum of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_sub_domain (self, d2) result(domain) Returns a difference between two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_unary_minus (self) result(domain) Returns a negative domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance Return Value type( domain_type ) private pure elemental function domain_mult_domain (self, d2) result(domain) Returns a product of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_div_domain (self, d2) result(domain) Returns a division of two domain instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance class( domain_type ), intent(in) :: d2 r.h.s. domain instance Return Value type( domain_type ) private pure elemental function domain_add_real (self, a) result(domain) Returns a sum of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function domain_sub_real (self, a) result(domain) Returns a difference between a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function domain_mult_real (self, a) result(domain) Returns a product of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function domain_div_real (self, a) result(domain) Returns a division of a domain instance and a real number. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self l.h.s. domain instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( domain_type ) private pure elemental function real_add_domain (a, self) result(domain) Returns a sum of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) private pure elemental function real_sub_domain (a, self) result(domain) Returns a difference between a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) private pure elemental function real_mult_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) private pure elemental function real_div_domain (a, self) result(domain) Returns a product of a real number and a domain instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( domain_type ), intent(in) :: self r.h.s. domain instance Return Value type( domain_type ) private pure function getCurrent_u (self) result(u) Returns the 3-d array with values of Eulerian velocity (mean current) in \n x-direction [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Eulerian u-velocity [m/s] private pure function getCurrent_v (self) result(v) Returns the 3-d array with values of Eulerian velocity (mean current) in \n y-direction [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Eulerian v-velocity [m/s] private pure function getDepth (self) result(depth) Returns the mean water depth [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean water depth [m] private pure function getElevation (self) result(elevation) Returns the mean water elevation [m] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean water elevation [m] private pure function getFrequency (self) result(frequency) Returns the frequency [Hz] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:), allocatable Frequency [Hz] private pure function getDirections (self) result(directions) Returns the spectral direction bins [rad]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:), allocatable Directions [rad] private pure function getGravity (self) result(grav) Returns the gravitational acceleration [m/s&#94;2] array. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Gravitational acceleration [m/s&#94;2] private pure function getGrid (self) result(grid) Returns the grid instance that is the component of the domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( grid_type ) Grid instance component private pure function getLowerBounds (self) result(lb) Returns the lower bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Lower bound indices private pure function getUpperBounds (self) result(ub) Returns the upper bounds of the domain instance. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value integer(kind=ik),\n  dimension(2) Upper bound indices private pure function getSpectrum (self) result(spectrum) Returns the array of spectrum instances. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value type( spectrum_type ),\n  dimension(:,:), allocatable Array of spectrum instances private pure function getSpectrumArray (self, halowidth, periodic) result(spectrum_array) Returns a 4-dimensional spectrum array, where the first two dimensions are\n frequency and directional dimensions and the second two are spatial x and y\n dimensions. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Spectrum array private pure function getPhaseSpeed (self) result(cp) Returns a 3-d array with phase speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Phase speed [m/s] array private pure function getGroupSpeed (self, halowidth, periodic) result(cg) Returns a 3-d array with group speed values [m/s]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integers indicating how many cells to allocate for halo points logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Group speed [m/s] array private pure function getGridSpacingXWithHalo (self, halowidth, periodic) result(dx) Returns grid spacing array in x-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:), allocatable Grid spacing in x [m] private pure function getGridSpacingYWithHalo (self, halowidth, periodic) result(dy) Returns grid spacing array in y-direction including halo cells. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance integer(kind=ik), intent(in), dimension(2) :: halowidth Integer width of halo region logical, intent(in) :: periodic If .true. , halo cells will be updated with values corresponding to \n periodic boundary conditions Return Value real(kind=rk),\n  dimension(:,:), allocatable Grid spacing in y [m] private pure function getSurfaceTension (self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Surface tension [N/m] private pure function getAirDensity (self) result(air_density) Returns the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Air density [kg/m&#94;3] private pure function getWaterDensity (self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Water density [kg/m&#94;3] private pure function frequencyMoment (self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function wavenumberMoment (self, n) result(moment) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Spectrum instance integer(kind=ik), intent(in) :: n Order Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function meanPeriod (self) Returns the mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean period [s] array private pure function meanPeriodZeroCrossing (self) Returns the zero-crossing mean wave period [s] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Mean period [s] array private pure function significantWaveHeight (self) result(hs) Returns the significant wave height [m] for the whole domain. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self Domain instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Significant wave height [m] array Subroutines private pure subroutine assign_spectrum_array_1d (self, spectrum_array) Assigns a 1-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:) :: spectrum_array r.h.s. array of spectrum instances private pure subroutine assign_spectrum_array_2d (self, spectrum_array) Assigns a 2-d array of spectrum instances to a domain instance. This \n procedure overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self l.h.s. domain instance class( spectrum_type ), intent(in), dimension(:,:) :: spectrum_array r.h.s. array of spectrum instances private pure subroutine setDepth (self, depth) Sets the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: depth Mean water depth [m] private pure subroutine setElevation (self, elevation) Sets the mean water elevation [m]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: elevation Mean water elevation [m] private pure subroutine setGravity (self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: grav Gravitational acceleration [m/s&#94;2] private pure subroutine setSurfaceTension (self, surface_tension) Sets the surface tension [N/m&#94;2]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: surface_tension Surface tension [N/m&#94;2] private pure subroutine setAirDensity (self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: air_density Air density [kg/m&#94;3] private pure subroutine setWaterDensity (self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: water_density Water density [kg/m&#94;3] private pure subroutine setSpectrum1d (self, spectrum) Sets the 1-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:) :: spectrum Input 1-d array of spectrum object instances private pure subroutine setSpectrum2d (self, spectrum) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance type( spectrum_type ), intent(in), dimension(:,:) :: spectrum Input 2-d array of spectrum object instances private pure subroutine setSpectrumArray1d1d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for omnidirectional spectrum in 1-d space (1d-1d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:) :: spectrum_array Spectrum array private pure subroutine setSpectrumArray1d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for setting 1-d spectrum into 2-d physical space\n of 2-d spectrum into 1-d physical space. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:) :: spectrum_array Spectrum array private pure subroutine setSpectrumArray2d2d (self, spectrum_array) Sets the spectrum instances based on input spectrum array.\n This implementation is for directional spectrum in 2-d space (2d-2d) Arguments Type Intent Optional Attributes Name class( domain_type ), intent(inout) :: self Domain instance real(kind=rk), intent(in), dimension(:,:,:,:) :: spectrum_array Spectrum array private subroutine writeJSON (self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( domain_type ), intent(in) :: self domain instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file","tags":"","loc":"module/mod_domain.html","title":"mod_domain – wavy"},{"text":"Uses: mod_precision module~~mod_advection~~UsesGraph module~mod_advection mod_advection module~mod_precision mod_precision module~mod_precision->module~mod_advection iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces advectUpwind1stOrder advectCentered2ndOrder Functions advectUpwind1stOrder1dRank0 advectUpwind1stOrder1dRank1 advectUpwind1stOrder1dRank2 advectUpwind1stOrder2dRank0 advectUpwind1stOrder2dRank1 advectUpwind1stOrder2dRank2 advectCentered2ndOrder1dRank0 advectCentered2ndOrder1dRank1 advectCentered2ndOrder1dRank2 advectCentered2ndOrder2dRank0 advectCentered2ndOrder2dRank1 advectCentered2ndOrder2dRank2 Interfaces public interface advectUpwind1stOrder private pure function advectUpwind1stOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectUpwind1stOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency public interface advectCentered2ndOrder private pure function advectCentered2ndOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency Functions private pure function advectUpwind1stOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a first order,\n positive-definite upwind differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectUpwind1stOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency public pure function advectUpwind1stOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a first\n order, positive-definite upwind differencing. Fields f, u, and v are\n defined on a semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in x-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder1dRank0 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank1 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency public pure function advectCentered2ndOrder1dRank2 (f, u, dx) result(dfdt) Computes the advective tendency of an input field f given the advective\n velocity field u [m/s] and grid spacing dx [m], using a second order\n centered differencing. Fields f and u are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity [m/s] real(kind=rk), intent(in), dimension(:) :: dx Grid spacing [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank0 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank1 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:), allocatable Advective tendency private pure function advectCentered2ndOrder2dRank2 (f, u, v, dx, dy) result(dfdt) Computes the 2-d advective tendency of an input field f given the advective\n velocity field u and v [m/s] and grid spacing dx and dy [m], using a second\n order centered differencing. Fields f, u, and v are defined on a\n semi-staggered Arakawa C-grid: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:,:) :: f Input field to be advected real(kind=rk), intent(in), dimension(:,:,:,:) :: u Advective velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:,:,:,:) :: v Advective velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:,:) :: dx Grid spacing in x-direction [m] real(kind=rk), intent(in), dimension(:,:) :: dy Grid spacing in y-direction [m] Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable Advective tendency","tags":"","loc":"module/mod_advection.html","title":"mod_advection – wavy"},{"text":"Uses: mod_precision module~~mod_utility~~UsesGraph module~mod_utility mod_utility module~mod_precision mod_precision module~mod_precision->module~mod_utility iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_utility~~UsedByGraph module~mod_utility mod_utility module~mod_spectrum mod_spectrum module~mod_utility->module~mod_spectrum module~mod_grid mod_grid module~mod_utility->module~mod_grid proc~snl_dccm2012 snl_DCCM2012 module~mod_spectrum->proc~snl_dccm2012 proc~sbf_dccm2012 sbf_DCCM2012 module~mod_spectrum->proc~sbf_dccm2012 proc~sin_dccm2012 sin_DCCM2012 module~mod_spectrum->proc~sin_dccm2012 module~mod_time_integration mod_time_integration module~mod_spectrum->module~mod_time_integration proc~sdt_dccm2012 sdt_DCCM2012 module~mod_spectrum->proc~sdt_dccm2012 module~mod_domain mod_domain module~mod_spectrum->module~mod_domain proc~sbf_jonswap sbf_JONSWAP module~mod_spectrum->proc~sbf_jonswap proc~sds_dccm2012 sds_DCCM2012 module~mod_spectrum->proc~sds_dccm2012 module~mod_grid->module~mod_domain module~mod_domain->module~mod_time_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces diff diff_periodic ones range tile zeros Functions diff_1d diff_2d diff_periodic_1d diff_periodic_2d ones_int ones_real range_int range_real tile_1d_int tile_1d_real tile_2d_int tile_2d_real tile_3d_int tile_3d_real zeros_int zeros_real Interfaces public interface diff private pure function diff_1d (x) result(dx) Returns a centered-difference of a 1-d array, with first order\n differencing applied for the boundary points. This procedure is overloaded\n by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n first order differencing applied for the boundary points. This procedure is\n overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable public interface diff_periodic private pure function diff_periodic_1d (x) result(dx) Returns a centered-difference of a 1-d array with periodic boundary\n conditions. This procedure is overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_periodic_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n periodic boundary conditions. This procedure is overloaded by the generic\n procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable public interface ones private pure function ones_int (length, kindflag) result(ones) Returns a 1-d array of integer ones. This procedure is overloaded by the\n generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function ones_real (length, kindflag) result(ones) Returns a 1-d array of floating-point ones. This procedure is overloaded by\n the generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable public interface range private pure function range_int (start, end, increment) result(range) Returns an array of integers given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: start Start value of the array integer(kind=ik), intent(in) :: end End value of the array integer(kind=ik), intent(in), optional :: increment Array increment Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function range_real (start, end, increment) result(range) Returns an array of reals given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: start Start value of the array real(kind=rk), intent(in) :: end End value of the array real(kind=rk), intent(in), optional :: increment Array increment Return Value real(kind=rk),\n  dimension(:), allocatable public interface tile private pure function tile_1d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:), allocatable private pure function tile_1d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function tile_2d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:), allocatable private pure function tile_2d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:), allocatable private pure function tile_3d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:,:), allocatable private pure function tile_3d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable public interface zeros private pure function zeros_int (length, kindflag) result(zeros) Returns a 1-d array of integer zeros. This procedure is overloaded by the\n generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function zeros_real (length, kindflag) result(zeros) Returns a 1-d array of floating-point zeros. This procedure is overloaded by\n the generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable Functions private pure function diff_1d (x) result(dx) Returns a centered-difference of a 1-d array, with first order\n differencing applied for the boundary points. This procedure is overloaded\n by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n first order differencing applied for the boundary points. This procedure is\n overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function diff_periodic_1d (x) result(dx) Returns a centered-difference of a 1-d array with periodic boundary\n conditions. This procedure is overloaded by the generic procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: x Input array Return Value real(kind=rk),\n  dimension(:), allocatable private pure function diff_periodic_2d (x, dim) result(dx) Returns a centered-difference of a 2-d array along dimension dim, with\n periodic boundary conditions. This procedure is overloaded by the generic\n procedure diff . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: x Input array integer(kind=ik), intent(in) :: dim Dimension along which to differentiate Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function ones_int (length, kindflag) result(ones) Returns a 1-d array of integer ones. This procedure is overloaded by the\n generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function ones_real (length, kindflag) result(ones) Returns a 1-d array of floating-point ones. This procedure is overloaded by\n the generic procedure ones . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable private pure function range_int (start, end, increment) result(range) Returns an array of integers given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: start Start value of the array integer(kind=ik), intent(in) :: end End value of the array integer(kind=ik), intent(in), optional :: increment Array increment Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function range_real (start, end, increment) result(range) Returns an array of reals given start, end, and increment values. If the\n increment argument is not passed, default increment is 1. This procedure is\n overloaded by the generic procedure range . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: start Start value of the array real(kind=rk), intent(in) :: end End value of the array real(kind=rk), intent(in), optional :: increment Array increment Return Value real(kind=rk),\n  dimension(:), allocatable private pure function tile_1d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:), allocatable private pure function tile_1d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 1-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:), allocatable private pure function tile_2d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:), allocatable private pure function tile_2d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 2-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:), allocatable private pure function tile_3d_int (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of integers. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value integer(kind=ik),\n  dimension(:,:,:,:), allocatable private pure function tile_3d_real (array, n) result(tiled_array) Tiles the input array n times. Returns a tiled array that has rank equal\n to size(shape(array))+1 and that has values equal to values of array ,\n repeated n times. This version is for 3-d input array of reals. This\n procedure is overloaded by the generic procedure tile . Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:,:) :: array Input array integer(kind=ik), intent(in) :: n Number of times to copy input array Return Value real(kind=rk),\n  dimension(:,:,:,:), allocatable private pure function zeros_int (length, kindflag) result(zeros) Returns a 1-d array of integer zeros. This procedure is overloaded by the\n generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length integer(kind=ik), intent(in) :: kindflag Array type Return Value integer(kind=ik),\n  dimension(:), allocatable private pure function zeros_real (length, kindflag) result(zeros) Returns a 1-d array of floating-point zeros. This procedure is overloaded by\n the generic procedure zeros . Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: length Array length real(kind=rk), intent(in) :: kindflag Array type Return Value real(kind=rk),\n  dimension(:), allocatable","tags":"","loc":"module/mod_utility.html","title":"mod_utility – wavy"},{"text":"Uses: mod_precision module~~mod_source_functions~~UsesGraph module~mod_source_functions mod_source_functions module~mod_precision mod_precision module~mod_precision->module~mod_source_functions iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions sin_DCCM2012 sds_DCCM2012 sdt_DCCM2012 sbf_DCCM2012 sbf_JONSWAP snl_DCCM2012 Functions public pure elemental function sin_DCCM2012 (spectrum, wspd, wdir, input_height, ustar, vonkarman) result(tendency) TODO implement currents averaged over the effective depth layer for\n modulation of phase speed. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Input spectrum instance real(kind=rk), intent(in) :: wspd Input wind speed [m/s] real(kind=rk), intent(in) :: wdir Input wind direction [rad], mathematical convention real(kind=rk), intent(in) :: input_height Height of input wind speed [m/s] real(kind=rk), intent(in) :: ustar Air-side friction velocity [m/s] real(kind=rk), intent(in) :: vonkarman Von Karman constant Return Value type( spectrum_type ) public pure elemental function sds_DCCM2012 (spectrum, sds_coefficient, sds_power, mss_coefficient) result(tendency) Returns a spectrum instance with the wave dissipation ($S_{ds}$) tendency\n formulated by Donelan et al. (2012). Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Linear coefficient of the dissipation function real(kind=rk), intent(in) :: sds_coefficient Linear coefficient of the dissipation function real(kind=rk), intent(in) :: sds_power The exponent of the saturation spectrum real(kind=rk), intent(in) :: mss_coefficient Linear coefficient of the mean square slope adjustment to Sds Return Value type( spectrum_type ) Result tendency instance public pure elemental function sdt_DCCM2012 (spectrum, sdt_coefficient, ustar) result(tendency) Returns a spectrum instance with the wave dissipation due to turbulence\n ($S_{dt}$) tendency formulated by Donelan et al. (2012). Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: sdt_coefficient Linear coefficient of the turbulent dissipation function real(kind=rk), intent(in) :: ustar Air-side friction velocity [m/s] Return Value type( spectrum_type ) Result tendency instance public pure elemental function sbf_DCCM2012 (spectrum, friction_coefficient, percolation_coefficient) result(tendency) Returns a spectrum instance with the wave dissipation tendency due to\n bottom friction and percolation, formulated by Donelan et al. (2012). Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: friction_coefficient Bottom friction coefficient [m/s] real(kind=rk), intent(in) :: percolation_coefficient Bottom permeability coefficient [m/s] Return Value type( spectrum_type ) Result tendency instance public pure elemental function sbf_JONSWAP (spectrum, friction_coefficient) result(tendency) Returns a spectrum instance with the bottom friction ($S_{bot}$) tendency\n based on JONSWAP field data (Hasselmann et al., 1973). It is also the\n default parameterization scheme used in the WAM model (WAMDIG, 1988). Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance real(kind=rk), intent(in) :: friction_coefficient Bottom friction coefficient [m/s] Return Value type( spectrum_type ) Result tendency instance public pure elemental function snl_DCCM2012 (spectrum, sds_tendency, snl_coefficient) result(tendency) Returns a spectrum instance with the non-linear wave-wave energy transfer\n ($S_{nl}$) tendency formulated by Donelan et al. (2012). Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: spectrum Spectrum instance type( spectrum_type ), intent(in) :: sds_tendency Spectral dissipation tendency instance real(kind=rk), intent(in) :: snl_coefficient Linear coefficient of the dissipation function Return Value type( spectrum_type ) Result tendency instance","tags":"","loc":"module/mod_source_functions.html","title":"mod_source_functions – wavy"},{"text":"Uses: mod_precision module~~mod_gravity~~UsesGraph module~mod_gravity mod_gravity module~mod_precision mod_precision module~mod_precision->module~mod_gravity iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables gravitational_constant Functions gravityClairaut Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: gravitational_constant = 6.67408e-11_rk Functions public pure elemental function gravityClairaut (latitude) result(grav) Returns the gravitational acceleration at the Earth's surface as function\n of latitude, based on Clairaut's formula. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: latitude Latitude [rad] Return Value real(kind=rk)","tags":"","loc":"module/mod_gravity.html","title":"mod_gravity – wavy"},{"text":"Uses: mod_precision mod_spectrum mod_domain module~~mod_time_integration~~UsesGraph module~mod_time_integration mod_time_integration module~mod_spectrum mod_spectrum module~mod_spectrum->module~mod_time_integration module~mod_domain mod_domain module~mod_spectrum->module~mod_domain module~mod_precision mod_precision module~mod_precision->module~mod_time_integration module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_domain module~mod_utility mod_utility module~mod_precision->module~mod_utility module~mod_const mod_const module~mod_precision->module~mod_const module~mod_grid mod_grid module~mod_precision->module~mod_grid module~mod_domain->module~mod_time_integration json_module json_module json_module->module~mod_spectrum json_module->module~mod_domain module~mod_utility->module~mod_spectrum module~mod_utility->module~mod_grid datetime_module datetime_module datetime_module->module~mod_spectrum datetime_module->module~mod_domain module~mod_const->module~mod_spectrum module~mod_const->module~mod_domain iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision module~mod_grid->module~mod_domain var panmodulemod_time_integrationUsesGraph = svgPanZoom('#modulemod_time_integrationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces integrate exact_exponential backward_euler forward_euler Functions integrate_spectrum integrate_domain backward_euler_spectrum backward_euler_domain exact_exponential_spectrum exact_exponential_domain forward_euler_spectrum forward_euler_domain Interfaces public interface integrate private pure function integrate_spectrum (func, initial, tendency, dt) Integrates spectrum forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial type( spectrum_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( spectrum_type ) type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure function integrate_domain (func, initial, tendency, dt) Integrates domain forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial type( domain_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( domain_type ) type( domain_type ), intent(in) :: initial Initial domain instance type( domain_type ), intent(in) :: tendency Spectrum domain instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) public interface exact_exponential private pure elemental function exact_exponential_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function exact_exponential_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) public interface backward_euler private pure elemental function backward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order implicit backward \n Euler integration scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function backward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order implicit \n backward Euler integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) public interface forward_euler private pure elemental function forward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order Euler integration\n scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function forward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order Euler\n integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) Functions private pure function integrate_spectrum (func, initial, tendency, dt) Integrates spectrum forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial type( spectrum_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( spectrum_type ) type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure function integrate_domain (func, initial, tendency, dt) Integrates domain forward in time using a time integration method\n provided as the argument func . Arguments Type Intent Optional Attributes Name public pure function func(initial, tendency, dt) Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial type( domain_type ), intent(in) :: tendency real(kind=rk), intent(in) :: dt Return Value type( domain_type ) type( domain_type ), intent(in) :: initial Initial domain instance type( domain_type ), intent(in) :: tendency Spectrum domain instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) private pure elemental function backward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order implicit backward \n Euler integration scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function backward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order implicit \n backward Euler integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) private pure elemental function exact_exponential_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function exact_exponential_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using the exact exponential. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type ) private pure elemental function forward_euler_spectrum (initial, tendency, dt) result(spec) Integrates a spectrum forward in time using a 1st order Euler integration\n scheme. Arguments Type Intent Optional Attributes Name type( spectrum_type ), intent(in) :: initial Initial spectrum instance type( spectrum_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( spectrum_type ) private pure elemental function forward_euler_domain (initial, tendency, dt) result(domain) Integrates a domain instance forward in time using a 1st order Euler\n integration scheme. Arguments Type Intent Optional Attributes Name type( domain_type ), intent(in) :: initial Initial spectrum instance type( domain_type ), intent(in) :: tendency Spectrum tendency instance real(kind=rk), intent(in) :: dt Time step [s] Return Value type( domain_type )","tags":"","loc":"module/mod_time_integration.html","title":"mod_time_integration – wavy"},{"text":"Uses: mod_precision module~~mod_nondimensional~~UsesGraph module~mod_nondimensional mod_nondimensional module~mod_precision mod_precision module~mod_precision->module~mod_nondimensional iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_nondimensional~~UsedByGraph module~mod_nondimensional mod_nondimensional module~mod_spectral_shapes mod_spectral_shapes module~mod_nondimensional->module~mod_spectral_shapes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions waveAge nondimensionalDepth nondimensionalEnergy nondimensionalFetch nondimensionalFrequency nondimensionalRoughness_S1974 nondimensionalRoughness_H1986 nondimensionalTime Functions public pure elemental function waveAge (cp, u) Returns wave age, the ratio of phase speed and friction velocity or wind\n speed, depending on the caller's definition of wave age. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: cp Phase speed [m/s] real(kind=realkind), intent(in) :: u Friction velocity or wind speed [m/s] Return Value real(kind=realkind) public pure elemental function nondimensionalDepth (wspd, depth, grav) Returns nondimensional depth based on input wind speed [m/s], mean water\n depth [m], and gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: depth Mean water depth [m] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function nondimensionalEnergy (wspd, sigma, grav) Returns nondimensional energy based on input wind speed, RMS of wave\n variance, and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: sigma Root mean square of wave variance real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function nondimensionalFetch (wspd, fetch, grav) Returns nondimensional energy based on input wind speed, RMS of wave\n variance, and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: fetch Fetch [m] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function nondimensionalFrequency (wspd, fpeak, grav) Returns nondimensional frequency based on input wind speed, peak frequency,\n and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: fpeak Peak frequency [Hz] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function nondimensionalRoughness_S1974 (z0, ustar, grav) Returns the aerodynamic roughness length scaled by friction velocity\n squared and gravitational acceleration, after Stewart (1974). Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: z0 Roughness length [m] real(kind=realkind), intent(in) :: ustar Friction velocity [m/s] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind) public pure elemental function nondimensionalRoughness_H1986 (z0, hs) Returns the aerodynamic roughness length scaled by significant wave height,\n after Huang (1986). Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: z0 Roughness length [m] real(kind=realkind), intent(in) :: hs Significant wave height [m] Return Value real(kind=realkind) public pure elemental function nondimensionalTime (wspd, time, grav) Returns nondimensional time (duration) based on input wind speed, duration,\n and gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=realkind), intent(in) :: wspd Wind speed at reference height [m/s] real(kind=realkind), intent(in) :: time Time [s] real(kind=realkind), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=realkind)","tags":"","loc":"module/mod_nondimensional.html","title":"mod_nondimensional – wavy"},{"text":"Uses: iso_c_binding mod_precision mod_utility mod_const datetime_module json_module module~~mod_spectrum~~UsesGraph module~mod_spectrum mod_spectrum json_module json_module json_module->module~mod_spectrum module~mod_utility mod_utility module~mod_utility->module~mod_spectrum module~mod_precision mod_precision module~mod_precision->module~mod_spectrum module~mod_precision->module~mod_utility module~mod_const mod_const module~mod_precision->module~mod_const datetime_module datetime_module datetime_module->module~mod_spectrum module~mod_const->module~mod_spectrum iso_c_binding iso_c_binding iso_c_binding->module~mod_spectrum iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_spectrum~~UsedByGraph module~mod_spectrum mod_spectrum proc~snl_dccm2012 snl_DCCM2012 module~mod_spectrum->proc~snl_dccm2012 proc~sbf_dccm2012 sbf_DCCM2012 module~mod_spectrum->proc~sbf_dccm2012 proc~sin_dccm2012 sin_DCCM2012 module~mod_spectrum->proc~sin_dccm2012 module~mod_time_integration mod_time_integration module~mod_spectrum->module~mod_time_integration proc~sdt_dccm2012 sdt_DCCM2012 module~mod_spectrum->proc~sdt_dccm2012 module~mod_domain mod_domain module~mod_spectrum->module~mod_domain proc~sbf_jonswap sbf_JONSWAP module~mod_spectrum->proc~sbf_jonswap proc~sds_dccm2012 sds_DCCM2012 module~mod_spectrum->proc~sds_dccm2012 module~mod_domain->module~mod_time_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces spectrum_type Derived Types spectrum_type Functions constructor getAirDensity isAllocated isMonochromatic isOmnidirectional getFrequency getFrequency2d getWavenumber getWavenumberSpacing getWavenumber2d getWavelength getDirections getDirections2d getPhaseSpeed getPhaseSpeed2d getGroupSpeed getGroupSpeed2d getSpectrum getWaveAction getAmplitude getCurrent_u getCurrent_v getDepthLevels getDepth getElevation getGravity getSurfaceTension getWaterDensity omnidirectionalSpectrum meanSquareSlope meanSquareSlopeDirectional momentum_x momentum_y momentumFlux_xx momentumFlux_xy momentumFlux_yy frequencyMoment peakedness peakFrequency peakFrequencyDiscrete wavenumberMoment wavenumberSpectrum saturationSpectrum significantWaveHeight significantSurfaceOrbitalVelocity stokesDrift stokesDrift2d meanPeriod meanPeriodZeroCrossing ursellNumber eq neq gt lt ge le spectrum_add_spectrum spectrum_sub_spectrum spectrum_mult_spectrum spectrum_div_spectrum spectrum_add_real spectrum_sub_real spectrum_mult_real spectrum_mult_real2d spectrum_div_real real_add_spectrum real_sub_spectrum real_mult_spectrum real2d_mult_spectrum real_div_spectrum spectrum_unary_minus wavenumber Subroutines setSpectrum1d setSpectrum2d setCurrent1d setCurrent2d setDepth setElevation setGravity setSurfaceTension setAirDensity setWaterDensity assign_array_1d assign_array_2d readJSON writeJSON Interfaces public interface spectrum_type private pure elemental function constructor (fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) result(spectrum) Constructor function for the spectrum object. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: fmin Minimum frequency bin [Hz] real(kind=rk), intent(in) :: fmax Maximum frequency bin [Hz] real(kind=rk), intent(in) :: df Frequency increment, df = f(n+1)/f(n) integer, intent(in) :: ndirs Number of directional bins real(kind=rk), intent(in) :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: air_density Air density [kg/m&#94;3] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value type( spectrum_type ) Derived Types type, public :: spectrum_type Spectrum class. Components Type Visibility Attributes Name Initial type(datetime), private :: start_time Simulation start time type(datetime), private :: end_time Simulation end time type(timedelta), private :: time_step Time step [s] real(kind=rk), private, dimension(:,:), allocatable :: spec 2-d spectrum real(kind=rk), private, dimension(:), allocatable :: f Frequency [Hz] real(kind=rk), private, dimension(:), allocatable :: df Frequency spacing [Hz] real(kind=rk), private, dimension(:), allocatable :: k Wavenumber [rad/m] real(kind=rk), private, dimension(:), allocatable :: dk Wavenumber spacing [rad/m] real(kind=rk), private, dimension(:), allocatable :: th Direction [rad] real(kind=rk), private, dimension(:), allocatable :: dth Directional spacing [rad] real(kind=rk), private, dimension(:), allocatable :: cp Phase speed [m/s] real(kind=rk), private, dimension(:), allocatable :: cg Group speed [m/s] real(kind=rk), private, dimension(:), allocatable :: u Mean current velocity in x-direction [m/s] real(kind=rk), private, dimension(:), allocatable :: v Mean current velocity in y-direction [m/s] real(kind=rk), private, dimension(:), allocatable :: z Depth levels for current array [m] real(kind=rk), private :: air_density Air density [kg/m&#94;3] real(kind=rk), private :: depth Mean water depth [m] real(kind=rk), private :: elevation Mean surface elevation [m] real(kind=rk), private :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), private :: surface_tension Surface tension [N/m] real(kind=rk), private :: water_density Water density [kg/m&#94;3] Constructor private pure,elemental function constructor (fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) Constructor function for the spectrum object. Type-Bound Procedures procedure, public, pass(self) :: frequencyMoment procedure, public, pass(self) :: getAirDensity procedure, public, pass(self) :: getAmplitude procedure, public, pass(self) :: getCurrent_u procedure, public, pass(self) :: getCurrent_v procedure, public, pass(self) :: getDepth procedure, public, pass(self) :: getDepthLevels procedure, public, pass(self) :: getDirections procedure, public, pass(self) :: getDirections2d procedure, public, pass(self) :: getElevation procedure, public, pass(self) :: getFrequency procedure, public, pass(self) :: getFrequency2d procedure, public, pass(self) :: getGravity procedure, public, pass(self) :: getGroupSpeed procedure, public, pass(self) :: getGroupSpeed2d procedure, public, pass(self) :: getWaveAction procedure, public, pass(self) :: getWavelength procedure, public, pass(self) :: getWavenumber procedure, public, pass(self) :: getWavenumberSpacing procedure, public, pass(self) :: getWavenumber2d procedure, public, pass(self) :: getPhaseSpeed procedure, public, pass(self) :: getPhaseSpeed2d procedure, public, pass(self) :: getSpectrum procedure, public, pass(self) :: getSurfaceTension procedure, public, pass(self) :: getWaterDensity procedure, public, pass(self) :: isAllocated procedure, public, pass(self) :: isMonochromatic procedure, public, pass(self) :: isOmnidirectional procedure, public, pass(self) :: meanPeriod procedure, public, pass(self) :: meanPeriodZeroCrossing procedure, public, pass(self) :: meanSquareSlope procedure, public, pass(self) :: meanSquareSlopeDirectional procedure, public, pass(self) :: momentum_x procedure, public, pass(self) :: momentum_y procedure, public, pass(self) :: momentumFlux_xx procedure, public, pass(self) :: momentumFlux_xy procedure, public, pass(self) :: momentumFlux_yy procedure, public, pass(self) :: omnidirectionalSpectrum procedure, public, pass(self) :: peakedness procedure, public, pass(self) :: peakFrequency procedure, public, pass(self) :: peakFrequencyDiscrete procedure, public, pass(self) :: saturationSpectrum procedure, public, pass(self) :: setAirDensity procedure, public, pass(self) :: setCurrent1d procedure, public, pass(self) :: setCurrent2d procedure, public, pass(self) :: setDepth procedure, public, pass(self) :: setElevation procedure, public, pass(self) :: setGravity procedure, public, pass(self) :: setSurfaceTension procedure, public, pass(self) :: setWaterDensity procedure, public, pass(self) :: setSpectrum1d procedure, public, pass(self) :: setSpectrum2d procedure, public, pass(self) :: significantWaveHeight procedure, public, pass(self) :: significantSurfaceOrbitalVelocity procedure, public, pass(self) :: stokesDrift procedure, public, pass(self) :: stokesDrift2d procedure, public, pass(self) :: ursellNumber procedure, public, pass(self) :: wavenumberMoment procedure, public, pass(self) :: wavenumberSpectrum procedure, public, pass(self) :: readJSON procedure, public, pass(self) :: writeJSON procedure, private, pass(self) :: assign_array_1d procedure, private, pass(self) :: assign_array_2d procedure, private, pass(self) :: real_add_spectrum procedure, private, pass(self) :: real_sub_spectrum procedure, private, pass(self) :: real_mult_spectrum procedure, private, pass(self) :: real_div_spectrum procedure, private, pass(self) :: real2d_mult_spectrum procedure, private, pass(self) :: spectrum_add_spectrum procedure, private, pass(self) :: spectrum_add_real procedure, private, pass(self) :: spectrum_sub_spectrum procedure, private, pass(self) :: spectrum_sub_real procedure, private, pass(self) :: spectrum_mult_spectrum procedure, private, pass(self) :: spectrum_mult_real procedure, private, pass(self) :: spectrum_mult_real2d procedure, private, pass(self) :: spectrum_div_spectrum procedure, private, pass(self) :: spectrum_div_real procedure, private, pass(self) :: spectrum_unary_minus procedure, private, pass(self) :: eq procedure, private, pass(self) :: neq procedure, private, pass(self) :: gt procedure, private, pass(self) :: ge procedure, private, pass(self) :: lt procedure, private, pass(self) :: le generic, public :: setCurrent => setCurrent1d, setCurrent2d generic, public :: setSpectrum => setSpectrum1d, setSpectrum2d generic, public :: assignment(=) => assign_array_1d, assign_array_2d generic, public :: operator(+) => spectrum_add_spectrum, spectrum_add_real, real_add_spectrum generic, public :: operator(-) => spectrum_sub_spectrum, spectrum_sub_real, real_sub_spectrum, spectrum_unary_minus generic, public :: operator(*) => spectrum_mult_spectrum, spectrum_mult_real, spectrum_mult_real2d, real_mult_spectrum, real2d_mult_spectrum generic, public :: operator(/) => spectrum_div_spectrum, spectrum_div_real, real_div_spectrum generic, public :: operator(==) => eq generic, public :: operator(/=) => neq generic, public :: operator(>) => gt generic, public :: operator(>=) => ge generic, public :: operator( => lt generic, public :: operator(<=) => le Functions private pure elemental function constructor (fmin, fmax, df, ndirs, depth, grav, air_density, water_density, surface_tension) result(spectrum) Constructor function for the spectrum object. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: fmin Minimum frequency bin [Hz] real(kind=rk), intent(in) :: fmax Maximum frequency bin [Hz] real(kind=rk), intent(in) :: df Frequency increment, df = f(n+1)/f(n) integer, intent(in) :: ndirs Number of directional bins real(kind=rk), intent(in) :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: air_density Air density [kg/m&#94;3] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value type( spectrum_type ) private pure elemental function getAirDensity (self) result(air_density) Returns the air_density [kg/m&#94;3] of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Air density [kg/m&#94;3] private pure elemental function isAllocated (self) Returns the allocation status of the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self domain instance Return Value logical private pure elemental function isMonochromatic (self) Returns .true. if only one frequency bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) private pure elemental function isOmnidirectional (self) Returns .true. if only one direction bin is allocated,\n and .false. otherwise. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value logical return value (boolean) private pure function getFrequency (self) result(f) Returns the frequency [Hz] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Frequency [Hz] private pure function getFrequency2d (self) result(f) Returns the frequency [Hz] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Frequency [Hz] private pure function getWavenumber (self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavenumber [rad/m] private pure function getWavenumberSpacing (self) result(dk) Returns the wavenumber spacing [rad/m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavenumber spacing [rad/m] private pure function getWavenumber2d (self) result(k) Returns the wavenumber [rad/m] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Wavenumber [rad/m] private pure function getWavelength (self) result(lambda) Returns the wavelength [m] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Wavelength [m] private pure function getDirections (self) result(th) Returns the directions [rad] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Directions [rad] private pure function getDirections2d (self) result(th) Returns the directions [rad] array of the spectrum instance, reshaped to\n match the spectrum array shape. This method is most useful for conforming\n shape array in 2-d spectrum computations. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Directions [rad] private pure function getPhaseSpeed (self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Phase speed [m/s] private pure function getPhaseSpeed2d (self) result(cp) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Phase speed [m/s] private pure function getGroupSpeed (self) result(cg) Returns the phase speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Group speed [m/s] private pure function getGroupSpeed2d (self) result(cg) Returns the group speed [m/s] array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Group speed [m/s] private pure function getSpectrum (self) result(spec) Returns the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Spectrum array private pure function getWaveAction (self) result(wave_action) Returns the wave action spectrum, which corresponds to the the wave\n variance spectrum normalized by the intrinsic frequency. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Wave action array private pure function getAmplitude (self) result(a) Returns the amplitude array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Amplitude [m] private pure function getCurrent_u (self) result(u) Returns the current velocity in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Mean current velocity in x-direction [m/s] private pure function getCurrent_v (self) result(v) Returns the current velocity in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Mean current velocity in y-direction [m/s] private pure function getDepthLevels (self) result(z) Returns the depth levels at which the current arrays are defined. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Depth levels of current fields [m] private pure elemental function getDepth (self) result(depth) Returns the mean water depth [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean water depth [m] private pure elemental function getElevation (self) result(elevation) Returns the mean surface elevation anomaly [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Mean surface elevation anomaly [m] private pure elemental function getGravity (self) result(grav) Returns the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Gravitational acceleration [m/s&#94;2] private pure elemental function getSurfaceTension (self) result(surface_tension) Returns the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Surface tension [N/m] private pure elemental function getWaterDensity (self) result(water_density) Returns the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) Water density [kg/m&#94;3] private pure function omnidirectionalSpectrum (self) result(spec) Returns the omnidirectional spectrum that corresponds to the input\n directional spectrum, integrated over all directions. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:), allocatable Spectrum array private pure elemental function meanSquareSlope (self) Returns the mean square slope of the spectrum, which is the second\n moment of the wavenumber spectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure function meanSquareSlopeDirectional (self) result(mss) For each directional frequency bin, computes the mean square slope of all\n all waves longer than that bin, projected to the direction of that bin. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Directional mean square slope private pure elemental function momentum_x (self) Returns total wave momentum [kg/m/s] in x-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function momentum_y (self) Returns total wave momentum [kg/m/s] in y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function momentumFlux_xx (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function momentumFlux_xy (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in x-direction of momentum in\n y-direction and vice versa (flux in y-direction of momentum in\n y-direction), because \\int{Cgx My} == \\int{Cgy Mx}. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function momentumFlux_yy (self) Returns total advective flux [kg/m&#94;2/s&#94;2] in y-direction of momentum in\n y-direction. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function frequencyMoment (self, n) Returns the spectral frequency moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) private pure elemental function peakedness (self) Returns the peakedness parameter that quantifies the sharpness of the\n spectral peak, following Goda (1970). Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function peakFrequency (self) Returns the peak frequency based on Young (1995). Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function peakFrequencyDiscrete (self) Returns the peak frequency based on simple discrete maximum location of\n the spectrum array. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function wavenumberMoment (self, n) Returns the spectral wavenumber moment of order n. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance integer, intent(in) :: n Moment order Return Value real(kind=rk) private pure function wavenumberSpectrum (self) result(spec) Returns the wavenumber spectrum array of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Spectrum array private pure function saturationSpectrum (self) Returns the saturation spectrum B(k) = F(k)k&#94;4. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk),\n  dimension(:,:), allocatable Saturation spectrum result private pure elemental function significantWaveHeight (self) Returns the significant wave height [m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function significantSurfaceOrbitalVelocity (self) result(uorb) Returns the significant surface orbital velocity [m/s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure function stokesDrift (self, z) Exact solution of Stokes drift based on linear wave theory, given input \n omnidirectional spectrum and distance from surface z [m], negative \n downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:), allocatable Stokes drift array [m/s] private pure function stokesDrift2d (self, z) Exact solution of Stokes drift based on linear wave theory, given input \n directional spectrum and distance from surface z [m], negative downward. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: z Distance from surface [m], negative downward Return Value real(kind=rk),\n  dimension(:,:), allocatable Stokes drift array [m/s] private pure elemental function meanPeriod (self) Returns the mean wave period [s]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function meanPeriodZeroCrossing (self) Returns the zero-crossing mean wave period [s]: Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function ursellNumber (self) Returns the Ursell number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self Spectrum instance Return Value real(kind=rk) private pure elemental function eq (self, s2) Logical equality comparison function. Overloads the == operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function neq (self, s2) Logical inequality comparison function. Overloads the /= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function gt (self, s2) Logical greater than comparison function. Overloads the > operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function lt (self, s2) Logical less than comparison function. Overloads the < operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function ge (self, s2) Logical greater than or equal comparison function. Overloads the >= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function le (self, s2) Logical less than or equal comparison function. Overloads the <= operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value logical private pure elemental function spectrum_add_spectrum (self, s2) result(spec) Returns a spectrum instance with the spectrum array values being the sum of\n the two input spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_sub_spectrum (self, s2) result(spec) Subtracts one spectrum instance from another and returns the resulting\n spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_mult_spectrum (self, s2) result(spec) Returns a product of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_div_spectrum (self, s2) result(spec) Returns a division of two spectrum instances. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance class( spectrum_type ), intent(in) :: s2 r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_add_real (self, a) result(spec) Returns a sum of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function spectrum_sub_real (self, a) result(spec) Returns a difference of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function spectrum_mult_real (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure function spectrum_mult_real2d (self, a) result(spec) Returns a product of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: a r.h.s. real 2-d array Return Value type( spectrum_type ) private pure elemental function spectrum_div_real (self, a) result(spec) Returns a division of a spectrum instance and a real number. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self l.h.s. spectrum instance real(kind=rk), intent(in) :: a r.h.s. real number Return Value type( spectrum_type ) private pure elemental function real_add_spectrum (a, self) result(spec) Returns a sum of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function real_sub_spectrum (a, self) result(spec) Returns a difference between a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function real_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure function real2d_mult_spectrum (a, self) result(spec) Returns a product of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:,:) :: a l.h.s. real 2-d array class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function real_div_spectrum (a, self) result(spec) Returns a division of a real number and a spectrum instance. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a l.h.s. real number class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function spectrum_unary_minus (self) result(spec) Returns a negative value of the spectrum instance. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self r.h.s. spectrum instance Return Value type( spectrum_type ) private pure elemental function wavenumber (f, depth, water_density, grav, surface_tension) Solves the linear water wave dispersion relationship using a\n Newton-Raphson iteration loop. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Intrinsic frequency [Hz] real(kind=rk), intent(in), optional :: depth Mean water depth [m] real(kind=rk), intent(in), optional :: water_density Water density [kg/m&#94;3] real(kind=rk), intent(in), optional :: grav Gravitational acceleration [m/s&#94;2] real(kind=rk), intent(in), optional :: surface_tension Surface tension [N/m] Return Value real(kind=rk) Subroutines private pure subroutine setSpectrum1d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: spec Input 1-d spectrum array private pure subroutine setSpectrum2d (self, spec) Sets the 2-d spectrum array. This procedure is overloaded by the\n generic procedure setSpectrum. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:,:) :: spec Input 2-d spectrum array private pure subroutine setCurrent1d (self, u, z) Sets the 1-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] private pure subroutine setCurrent2d (self, u, v, z) Sets the 2-d current velocity field. This procedure is overloaded by the\n generic procedure setCurrent. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in), dimension(:) :: u Current velocity in x-direction [m/s] real(kind=rk), intent(in), dimension(:) :: v Current velocity in y-direction [m/s] real(kind=rk), intent(in), dimension(:) :: z Depth levels for the velocity array [m] private pure elemental subroutine setDepth (self, depth) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: depth Mean water depth [m] private pure elemental subroutine setElevation (self, elevation) Sets the mean surface elevation value. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: elevation Mean surface elevation anomaly [m] private pure elemental subroutine setGravity (self, grav) Sets the gravitational acceleration [m/s&#94;2]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] private pure elemental subroutine setSurfaceTension (self, surface_tension) Sets the surface tension [N/m]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: surface_tension Surface tension [N/m] private pure elemental subroutine setAirDensity (self, air_density) Sets the air density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: air_density Air density [kg/m&#94;3] private pure elemental subroutine setWaterDensity (self, water_density) Sets the water density [kg/m&#94;3]. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self Spectrum instance real(kind=rk), intent(in) :: water_density Water density [kg/m&#94;3] private pure subroutine assign_array_1d (self, array) Assigns a 1-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:) :: array r.h.s. array of reals private pure subroutine assign_array_2d (self, array) Assigns a 2-d array of reals to a spectrum instance. This procedure\n overloads the assignment ('=') operator. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self l.h.s. spectrum instance real(kind=rk), intent(in), dimension(:,:) :: array r.h.s. array of reals private subroutine readJSON (self, filename) Read a spectrum instance from a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(inout) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name private subroutine writeJSON (self, filename, minify) Writes a spectrum instance to a JSON file. Arguments Type Intent Optional Attributes Name class( spectrum_type ), intent(in) :: self spectrum instance character(len=*), intent(in) :: filename JSON file name logical, intent(in) :: minify Logical switch to minify the JSON file","tags":"","loc":"module/mod_spectrum.html","title":"mod_spectrum – wavy"},{"text":"Uses: mod_precision mod_const mod_nondimensional module~~mod_spectral_shapes~~UsesGraph module~mod_spectral_shapes mod_spectral_shapes module~mod_const mod_const module~mod_const->module~mod_spectral_shapes module~mod_precision mod_precision module~mod_precision->module~mod_spectral_shapes module~mod_precision->module~mod_const module~mod_nondimensional mod_nondimensional module~mod_precision->module~mod_nondimensional module~mod_nondimensional->module~mod_spectral_shapes iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions donelanHamiltonHui donelanHamiltonHuiDirectionalSpreading donelanHamiltonHuiDirectionalSpectrum jonswap jonswapPeakFrequency phillips piersonMoskowitz piersonMoskowitzPeakFrequency Functions public pure elemental function donelanHamiltonHui (f, fpeak, wspd, grav) result(spec) The omnidirectional spectrum function based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) public pure elemental function donelanHamiltonHuiDirectionalSpreading (f, wspd, fpeak, theta, theta_mean) result(spreading) Directional spreading function based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). Includes the\n high-frequency form for beta_s found by Banner (1990). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: theta Wave direction [rad] real(kind=rk), intent(in) :: theta_mean Mean wave direction [rad] Return Value real(kind=rk) public pure function donelanHamiltonHuiDirectionalSpectrum (f, theta, wspd, fpeak, theta_mean, grav) result(spec) Returns directional frequency spectrum based on the laboratory and field\n measurements by Donelan, Hamilton, and Hui (1985). Includes the high\n frequency form for beta_s found by Banner (1990). This function invokes the\n  DHH omnidirectional spectrum and the directional spreading functions to\n compute directional frequency spectrum: Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:) :: f Frequency [Hz] real(kind=rk), intent(in), dimension(:) :: theta Wave direction [rad] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: theta_mean Mean wave direction [rad] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk),\n  dimension(:,:), allocatable public pure elemental function jonswap (f, wspd, fetch, grav) result(spec) Computes the JONSWAP equilibrium spectrum (Hasselmann et al. 1973) based on\n  input wind speed at the height of 10 m and fetch. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fetch Fetch [m] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) public pure elemental function jonswapPeakFrequency (wspd, fetch, grav) result(fpeak) Computes the JONSWAP equilibrium peak frequency [Hz] on the input\n based on the 10-m wind speed and fetch [km] (Hasselmann et al., 1973). Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: fetch Fetch [m] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) public pure elemental function phillips (f, fpeak, grav) result(spec) Computes the Phillips (1958) equilibrium spectrum based on the input\n peak frequency [Hz]. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: fpeak Peak frequency [Hz] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) public pure elemental function piersonMoskowitz (f, wspd, grav) result(spec) Computes the Pierson-Moskowitz (1964) equilibrium spectrum based on input\n wind speed at the height of 10 m. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: f Frequency [Hz] real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk) public pure elemental function piersonMoskowitzPeakFrequency (wspd, grav) result(fpeak) Computes the Pierson-Moskowitz (1964) peak frequency based on input wind\n speed at the height of 10 m. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: wspd Wind speed at 10 m height [m/s] real(kind=rk), intent(in) :: grav Gravitational acceleration [m/s&#94;2] Return Value real(kind=rk)","tags":"","loc":"module/mod_spectral_shapes.html","title":"mod_spectral_shapes – wavy"},{"text":"Uses: iso_fortran_env module~~mod_precision~~UsesGraph module~mod_precision mod_precision iso_fortran_env iso_fortran_env iso_fortran_env->module~mod_precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mod_precision~~UsedByGraph module~mod_precision mod_precision module~mod_stokes mod_stokes module~mod_precision->module~mod_stokes module~mod_nondimensional mod_nondimensional module~mod_precision->module~mod_nondimensional module~mod_utility mod_utility module~mod_precision->module~mod_utility module~mod_spectral_shapes mod_spectral_shapes module~mod_precision->module~mod_spectral_shapes module~mod_spectrum mod_spectrum module~mod_precision->module~mod_spectrum module~mod_gravity mod_gravity module~mod_precision->module~mod_gravity module~mod_time_integration mod_time_integration module~mod_precision->module~mod_time_integration module~mod_advection mod_advection module~mod_precision->module~mod_advection module~mod_domain mod_domain module~mod_precision->module~mod_domain module~mod_io mod_io module~mod_precision->module~mod_io module~mod_grid mod_grid module~mod_precision->module~mod_grid module~mod_const mod_const module~mod_precision->module~mod_const module~mod_linear_wave_theory mod_linear_wave_theory module~mod_precision->module~mod_linear_wave_theory module~mod_source_functions mod_source_functions module~mod_precision->module~mod_source_functions module~mod_nondimensional->module~mod_spectral_shapes module~mod_utility->module~mod_spectrum module~mod_utility->module~mod_grid module~mod_spectrum->module~mod_time_integration module~mod_spectrum->module~mod_domain proc~snl_dccm2012 snl_DCCM2012 module~mod_spectrum->proc~snl_dccm2012 proc~sbf_dccm2012 sbf_DCCM2012 module~mod_spectrum->proc~sbf_dccm2012 proc~sin_dccm2012 sin_DCCM2012 module~mod_spectrum->proc~sin_dccm2012 proc~sdt_dccm2012 sdt_DCCM2012 module~mod_spectrum->proc~sdt_dccm2012 proc~sbf_jonswap sbf_JONSWAP module~mod_spectrum->proc~sbf_jonswap proc~sds_dccm2012 sds_DCCM2012 module~mod_spectrum->proc~sds_dccm2012 module~mod_domain->module~mod_time_integration module~mod_grid->module~mod_domain module~mod_const->module~mod_spectral_shapes module~mod_const->module~mod_spectrum module~mod_const->module~mod_domain module~mod_const->proc~snl_dccm2012 module~mod_const->proc~sin_dccm2012 module~mod_const->proc~sds_dccm2012 var panmodulemod_precisionUsedByGraph = svgPanZoom('#modulemod_precisionUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables realkind realkind realkind intkind Variables Type Visibility Attributes Name Initial integer, public, parameter :: realkind = real64 integer, private, parameter :: realkind = real128 integer, private, parameter :: realkind = real32 integer, public, parameter :: intkind = int32","tags":"","loc":"module/mod_precision.html","title":"mod_precision – wavy"}]}